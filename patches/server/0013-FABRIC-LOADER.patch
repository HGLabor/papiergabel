From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: mooziii <63669478+mooziii@users.noreply.github.com>
Date: Sun, 12 Jun 2022 15:31:01 +0200
Subject: [PATCH] FABRIC LOADER


diff --git a/build.gradle.kts b/build.gradle.kts
index 9c394994c81ef3b5f933b69e4e0dc889b0fa9d21..a511fb13924832bc8ed0dbd80711dd8c27741069 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -8,6 +8,11 @@ plugins {
     id("com.github.johnrengelman.shadow")
 }
 
+repositories {
+    mavenCentral()
+    maven("https://maven.fabricmc.net/")
+}
+
 dependencies {
     // papiergabel start
     implementation(project(":papiergabel-api"))
@@ -30,8 +35,25 @@ dependencies {
     // Paper end
     implementation("org.apache.logging.log4j:log4j-iostreams:2.17.1") // Paper
     implementation("org.apache.logging.log4j:log4j-slf4j18-impl:2.17.1") // Paper
+    // papiergabel start
+
     implementation("org.ow2.asm:asm:9.3")
-    implementation("org.ow2.asm:asm-commons:9.3") // Paper - ASM event executor generation
+    implementation("org.ow2.asm:asm-analysis:9.3")
+    implementation("org.ow2.asm:asm-commons:9.3")
+    implementation("org.ow2.asm:asm-tree:9.3")
+    implementation("org.ow2.asm:asm-util:9.3")
+
+    implementation("net.fabricmc:sponge-mixin:0.11.4+mixin.0.8.5") {
+        exclude(module = "launchwrapper")
+        exclude(module = "guava")
+    }
+
+    implementation("net.fabricmc:tiny-mappings-parser:0.3.0+build.17")
+    implementation("net.fabricmc:tiny-remapper:0.8.2")
+    implementation("net.fabricmc:access-widener:2.1.0")
+    implementation("org.ow2.sat4j:org.ow2.sat4j.core:2.3.6")
+    implementation("org.ow2.sat4j:org.ow2.sat4j.pb:2.3.6")
+    // papiergabel end
     implementation("org.spongepowered:configurate-yaml:4.1.2") // Paper - config files
     implementation("commons-lang:commons-lang:2.6")
     implementation("net.fabricmc:mapping-io:0.3.0") // Paper - needed to read mappings for stacktrace deobfuscation
diff --git a/src/main/java/de/hglabor/papiergabel/config/PapiergabelConfig.java b/src/main/java/de/hglabor/papiergabel/config/PapiergabelConfig.java
index a88daa12e7cfae7039694347932e135bbec838da..40bdc028c35df462e69386a7bf706d97ab43dbf0 100644
--- a/src/main/java/de/hglabor/papiergabel/config/PapiergabelConfig.java
+++ b/src/main/java/de/hglabor/papiergabel/config/PapiergabelConfig.java
@@ -18,6 +18,7 @@ public class PapiergabelConfig {
     public static Messages messages = new Messages();
     public static Knockback knockback = new Knockback();
     public static Fixes fixes = new Fixes();
+    public static Experimental experimental = new Experimental();
 
     @MustSerialize
     public static class Fixes {
@@ -38,6 +39,11 @@ public class PapiergabelConfig {
         public double knockbackVerticalLimit = 0.4D;
     }
 
+    @MustSerialize
+    public static class Experimental {
+        public boolean loadFabricMods = true;
+    }
+
     public static void set(PapiergabelConfig instance, File file) throws Exception {
         if(!file.exists()) {
             file.createNewFile();
diff --git a/src/main/java/net/fabricmc/api/ClientModInitializer.java b/src/main/java/net/fabricmc/api/ClientModInitializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c7c3c890226ca461bd3973a1f340c168ad4718c
--- /dev/null
+++ b/src/main/java/net/fabricmc/api/ClientModInitializer.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.api;
+
+/**
+ * A mod initializer ran only on {@link EnvType#CLIENT}.
+ *
+ * <p>This entrypoint is suitable for setting up client-specific logic, such as rendering
+ * or integrated server tweaks.</p>
+ *
+ * <p>In {@code fabric.mod.json}, the entrypoint is defined with {@code client} key.</p>
+ *
+ * @see ModInitializer
+ * @see DedicatedServerModInitializer
+ * @see net.fabricmc.loader.api.FabricLoader#getEntrypointContainers(String, Class)
+ */
+@FunctionalInterface
+public interface ClientModInitializer {
+	/**
+	 * Runs the mod initializer on the client environment.
+	 */
+	void onInitializeClient();
+}
diff --git a/src/main/java/net/fabricmc/api/DedicatedServerModInitializer.java b/src/main/java/net/fabricmc/api/DedicatedServerModInitializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..e70eb1970e134682d5d545dbd787ce2d2cc13b62
--- /dev/null
+++ b/src/main/java/net/fabricmc/api/DedicatedServerModInitializer.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.api;
+
+/**
+ * A mod initializer ran only on {@link EnvType#SERVER}.
+ *
+ * <p>In {@code fabric.mod.json}, the entrypoint is defined with {@code server} key.</p>
+ *
+ * @see ModInitializer
+ * @see ClientModInitializer
+ * @see net.fabricmc.loader.api.FabricLoader#getEntrypointContainers(String, Class)
+ */
+@FunctionalInterface
+public interface DedicatedServerModInitializer {
+	/**
+	 * Runs the mod initializer on the server environment.
+	 */
+	void onInitializeServer();
+}
diff --git a/src/main/java/net/fabricmc/api/EnvType.java b/src/main/java/net/fabricmc/api/EnvType.java
new file mode 100644
index 0000000000000000000000000000000000000000..253b6e8a3c8b6f7b80a67b218db273d05e164ac8
--- /dev/null
+++ b/src/main/java/net/fabricmc/api/EnvType.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.api;
+
+/**
+ * Represents a type of environment.
+ *
+ * <p>A type of environment is a jar file in a <i>Minecraft</i> version's json file's {@code download}
+ * subsection, including the {@code client.jar} and the {@code server.jar}.</p>
+ *
+ * @see Environment
+ * @see EnvironmentInterface
+ */
+public enum EnvType {
+	/**
+	 * Represents the client environment type, in which the {@code client.jar} for a
+	 * <i>Minecraft</i> version is the main game jar.
+	 *
+	 * <p>A client environment type has all client logic (client rendering and integrated
+	 * server logic), the data generator logic, and dedicated server logic. It encompasses
+	 * everything that is available on the {@linkplain #SERVER server environment type}.</p>
+	 */
+	CLIENT,
+	/**
+	 * Represents the server environment type, in which the {@code server.jar} for a
+	 * <i>Minecraft</i> version is the main game jar.
+	 *
+	 * <p>A server environment type has the dedicated server logic and data generator
+	 * logic, which are all included in the {@linkplain #CLIENT client environment type}.
+	 * However, the server environment type has its libraries embedded compared to the
+	 * client.</p>
+	 */
+	SERVER
+}
diff --git a/src/main/java/net/fabricmc/api/Environment.java b/src/main/java/net/fabricmc/api/Environment.java
new file mode 100644
index 0000000000000000000000000000000000000000..4724891651adb72570728e43e213ffe2f16460ac
--- /dev/null
+++ b/src/main/java/net/fabricmc/api/Environment.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.api;
+
+import java.lang.annotation.*;
+
+/**
+ * Applied to declare that the annotated element is present only in the specified environment.
+ *
+ * <p>Use with caution, as Fabric-loader will remove the annotated element in a mismatched environment!</p>
+ *
+ * <p>When the annotated element is removed, bytecode associated with the element will not be removed.
+ * For example, if a field is removed, its initializer code will not, and will cause an error on execution.</p>
+ *
+ * <p>If an overriding method has this annotation and its overridden method doesn't,
+ * unexpected behavior may happen. If an overridden method has this annotation
+ * while the overriding method doesn't, it is safe, but the method can be used from
+ * the overridden class only in the specified environment.</p>
+ *
+ * @see EnvironmentInterface
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PACKAGE})
+@Documented
+public @interface Environment {
+	/**
+	 * Returns the environment type that the annotated element is only present in.
+	 */
+	EnvType value();
+}
diff --git a/src/main/java/net/fabricmc/api/EnvironmentInterface.java b/src/main/java/net/fabricmc/api/EnvironmentInterface.java
new file mode 100644
index 0000000000000000000000000000000000000000..8d8427d336d7037deeccb3a2da38c512b5cc201f
--- /dev/null
+++ b/src/main/java/net/fabricmc/api/EnvironmentInterface.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.api;
+
+import java.lang.annotation.*;
+
+/**
+ * Applied to declare that a class implements an interface only in the specified environment.
+ *
+ * <p>Use with caution, as Fabric-loader will remove the interface from {@code implements} declaration
+ * of the class in a mismatched environment!</p>
+ *
+ * <p>Implemented methods are not removed. To remove implemented methods, use {@link Environment}.</p>
+ *
+ * @see Environment
+ */
+@Retention(RetentionPolicy.CLASS)
+@Repeatable(EnvironmentInterfaces.class)
+@Target(ElementType.TYPE)
+@Documented
+public @interface EnvironmentInterface {
+	/**
+	 * Returns the environment type that the specific interface is only implemented in.
+	 */
+	EnvType value();
+
+	/**
+	 * Returns the interface class.
+	 */
+	Class<?> itf();
+}
diff --git a/src/main/java/net/fabricmc/api/EnvironmentInterfaces.java b/src/main/java/net/fabricmc/api/EnvironmentInterfaces.java
new file mode 100644
index 0000000000000000000000000000000000000000..1fc1e426073a4f2629b2e882eccd0a4b6460b236
--- /dev/null
+++ b/src/main/java/net/fabricmc/api/EnvironmentInterfaces.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.api;
+
+import java.lang.annotation.*;
+
+/**
+ * A container of multiple {@link EnvironmentInterface} annotations on a class, often defined implicitly.
+ */
+@Retention(RetentionPolicy.CLASS)
+@Target(ElementType.TYPE)
+@Documented
+public @interface EnvironmentInterfaces {
+	/**
+	 * Returns the {@link EnvironmentInterface} annotations it holds.
+	 */
+	EnvironmentInterface[] value();
+}
diff --git a/src/main/java/net/fabricmc/api/ModInitializer.java b/src/main/java/net/fabricmc/api/ModInitializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..31d5379f5c5af001c342b24664844be2204b9845
--- /dev/null
+++ b/src/main/java/net/fabricmc/api/ModInitializer.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.api;
+
+/**
+ * A mod initializer.
+ *
+ * <p>In {@code fabric.mod.json}, the entrypoint is defined with {@code main} key.</p>
+ *
+ * @see ClientModInitializer
+ * @see DedicatedServerModInitializer
+ * @see net.fabricmc.loader.api.FabricLoader#getEntrypointContainers(String, Class)
+ */
+@FunctionalInterface
+public interface ModInitializer {
+	/**
+	 * Runs the mod initializer.
+	 */
+	void onInitialize();
+}
diff --git a/src/main/java/net/fabricmc/loader/DependencyException.java b/src/main/java/net/fabricmc/loader/DependencyException.java
new file mode 100644
index 0000000000000000000000000000000000000000..a3deca5107026dbf60e99fd4f788fe5f2b867af6
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/DependencyException.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader;
+
+/**
+ * @deprecated Internal API, do not use
+ */
+@Deprecated
+@SuppressWarnings("serial")
+public class DependencyException extends RuntimeException {
+	public DependencyException() { }
+
+	public DependencyException(String message) {
+		super(message);
+	}
+
+	public DependencyException(String message, Throwable cause) {
+		super(message, cause);
+	}
+
+	public DependencyException(Throwable cause) {
+		super(cause);
+	}
+
+	public DependencyException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
+		super(message, cause, enableSuppression, writableStackTrace);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/FabricLoader.java b/src/main/java/net/fabricmc/loader/FabricLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5ae85ecfaaa1ed73abf9d22e89174e4770d80f6
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/FabricLoader.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader;
+
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+
+import java.io.File;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * The main class for mod loading operations.
+ *
+ * @deprecated Use {@link net.fabricmc.loader.api.FabricLoader}
+ */
+@Deprecated
+public abstract class FabricLoader implements net.fabricmc.loader.api.FabricLoader {
+	/**
+	 * @deprecated Use {@link net.fabricmc.loader.api.FabricLoader#getInstance()} where possible,
+	 * report missing areas as an issue.
+	 */
+	@Deprecated
+	public static final FabricLoader INSTANCE = FabricLoaderImpl.InitHelper.get();
+
+	public File getModsDirectory() {
+		return getGameDir().resolve("mods").toFile();
+	}
+
+	@Override
+	public abstract <T> List<T> getEntrypoints(String key, Class<T> type);
+
+	@SuppressWarnings({ "unchecked", "rawtypes" })
+	public Collection<ModContainer> getModContainers() {
+		return (Collection) getAllMods();
+	}
+
+	@SuppressWarnings({ "unchecked", "rawtypes" })
+	public List<ModContainer> getMods() {
+		return (List) getAllMods();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/ModContainer.java b/src/main/java/net/fabricmc/loader/ModContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..b053543dfee7c7fb9b0c90c2cbc198aa8b14e29d
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/ModContainer.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader;
+
+import net.fabricmc.loader.impl.util.UrlUtil;
+import net.fabricmc.loader.metadata.LoaderModMetadata;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.file.Path;
+import java.util.List;
+
+/**
+ * @deprecated Use {@link net.fabricmc.loader.api.ModContainer} instead
+ */
+@Deprecated
+public abstract class ModContainer implements net.fabricmc.loader.api.ModContainer {
+	public abstract LoaderModMetadata getInfo();
+	protected abstract List<Path> getCodeSourcePaths();
+
+	public URL getOriginUrl() {
+		try {
+			return UrlUtil.asUrl(getCodeSourcePaths().get(0));
+		} catch (MalformedURLException e) {
+			throw new RuntimeException(e);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/EntrypointException.java b/src/main/java/net/fabricmc/loader/api/EntrypointException.java
new file mode 100644
index 0000000000000000000000000000000000000000..783b4f041e9a8c4d68079f1acbf189f17fffb229
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/EntrypointException.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api;
+
+/**
+ * Represents an exception that arises when obtaining entrypoints.
+ *
+ * @see FabricLoader#getEntrypointContainers(String, Class)
+ */
+@SuppressWarnings("serial")
+public class EntrypointException extends RuntimeException {
+	private final String key;
+
+	/**
+	 * @deprecated For internal use only, to be removed!
+	 */
+	@Deprecated
+	public EntrypointException(String key, Throwable cause) {
+		super("Exception while loading entries for entrypoint '" + key + "'!", cause);
+		this.key = key;
+	}
+
+	/**
+	 * @deprecated For internal use only, use regular exceptions!
+	 */
+	@Deprecated
+	public EntrypointException(String key, String causingMod, Throwable cause) {
+		super("Exception while loading entries for entrypoint '" + key + "' provided by '" + causingMod + "'", cause);
+		this.key = key;
+	}
+
+	/**
+	 * @deprecated For internal use only, to be removed!
+	 */
+	@Deprecated
+	public EntrypointException(String s) {
+		super(s);
+		this.key = "";
+	}
+
+	/**
+	 * @deprecated For internal use only, to be removed!
+	 */
+	@Deprecated
+	public EntrypointException(Throwable t) {
+		super(t);
+		this.key = "";
+	}
+
+	/**
+	 * Returns the key of entrypoint in which the exception arose.
+	 *
+	 * @return the key
+	 */
+	public String getKey() {
+		return key;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/FabricLoader.java b/src/main/java/net/fabricmc/loader/api/FabricLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..dae0778b6f3f671ca98de0a3ed30142c1e6e7bb7
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/FabricLoader.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.entrypoint.EntrypointContainer;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+
+import java.io.File;
+import java.nio.file.Path;
+import java.util.Collection;
+import java.util.List;
+import java.util.Optional;
+
+/**
+ * The public-facing FabricLoader instance.
+ *
+ * <p>To obtain a working instance, call {@link #getInstance()}.</p>
+ *
+ * @since 0.4.0
+ */
+public interface FabricLoader {
+	/**
+	 * Returns the public-facing Fabric Loader instance.
+	 */
+	static FabricLoader getInstance() {
+		FabricLoader ret = FabricLoaderImpl.INSTANCE;
+
+		if (ret == null) {
+			throw new RuntimeException("Accessed FabricLoader too early!");
+		}
+
+		return ret;
+	}
+
+	/**
+	 * Returns all entrypoints declared under a {@code key}, assuming they are of a specific type.
+	 *
+	 * @param key  the key in entrypoint declaration in {@code fabric.mod.json}
+	 * @param type the type of entrypoints
+	 * @param <T>  the type of entrypoints
+	 * @return the obtained entrypoints
+	 * @see #getEntrypointContainers(String, Class)
+	 */
+	<T> List<T> getEntrypoints(String key, Class<T> type);
+
+	/**
+	 * Returns all entrypoints declared under a {@code key}, assuming they are of a specific type.
+	 *
+	 * <p>The entrypoint is declared in the {@code fabric.mod.json} as following:
+	 * <pre><blockquote>
+	 *   "entrypoints": {
+	 *     "&lt;a key&gt;": [
+	 *       &lt;a list of entrypoint declarations&gt;
+	 *     ]
+	 *   }
+	 * </blockquote></pre>
+	 * Multiple keys can be present in the {@code entrypoints} section.</p>
+	 *
+	 * <p>An entrypoint declaration indicates that an arbitrary notation is sent
+	 * to a {@link LanguageAdapter} to offer an instance of entrypoint. It is
+	 * either a string, or an object. An object declaration
+	 * is of this form:<pre><blockquote>
+	 *   {
+	 *     "adapter": "&lt;a custom adatper&gt;"
+	 *     "value": "&lt;an arbitrary notation&gt;"
+	 *   }
+	 * </blockquote></pre>
+	 * A string declaration {@code <an arbitrary notation>} is equivalent to
+	 * <pre><blockquote>
+	 *   {
+	 *     "adapter": "default"
+	 *     "value": "&lt;an arbitrary notation&gt;"
+	 *   }
+	 * </blockquote></pre>
+	 * where the {@code default} adapter is the {@linkplain LanguageAdapter adapter}
+	 * offered by Fabric Loader. </p>
+	 *
+	 * @param key  the key in entrypoint declaration in {@code fabric.mod.json}
+	 * @param type the type of entrypoints
+	 * @param <T>  the type of entrypoints
+	 * @return the entrypoint containers related to this key
+	 * @throws EntrypointException if a problem arises during entrypoint creation
+	 * @see LanguageAdapter
+	 */
+	<T> List<EntrypointContainer<T>> getEntrypointContainers(String key, Class<T> type);
+
+	/**
+	 * Get the object share for inter-mod communication.
+	 *
+	 * <p>The share allows mods to exchange data without directly referencing each other. This makes simple interaction
+	 * easier by eliminating any compile- or run-time dependencies if the shared value type is independent of the mod
+	 * (only Java/game/Fabric types like collections, primitives, String, Consumer, Function, ...).
+	 *
+	 * <p>Active interaction is possible as well since the shared values can be arbitrary Java objects. For example
+	 * exposing a {@code Runnable} or {@code Function} allows the "API" user to directly invoke some program logic.
+	 *
+	 * <p>It is required to prefix the share key with the mod id like {@code mymod:someProperty}. Mods should not
+	 * modify entries by other mods. The share is thread safe.
+	 *
+	 * @return the global object share instance
+	 * @since 0.12.0
+	 */
+	ObjectShare getObjectShare();
+
+	/**
+	 * Get the current mapping resolver.
+	 *
+	 * <p>When performing reflection, a mod should always query the mapping resolver for
+	 * the remapped names of members than relying on other heuristics.</p>
+	 *
+	 * @return the current mapping resolver instance
+	 * @since 0.4.1
+	 */
+	MappingResolver getMappingResolver();
+
+	/**
+	 * Gets the container for a given mod.
+	 *
+	 * @param id the ID of the mod
+	 * @return the mod container, if present
+	 */
+	Optional<ModContainer> getModContainer(String id);
+
+	/**
+	 * Gets all mod containers.
+	 *
+	 * @return a collection of all loaded mod containers
+	 */
+	Collection<ModContainer> getAllMods();
+
+	/**
+	 * Checks if a mod with a given ID is loaded.
+	 *
+	 * @param id the ID of the mod, as defined in {@code fabric.mod.json}
+	 * @return whether or not the mod is present in this Fabric Loader instance
+	 */
+	boolean isModLoaded(String id);
+
+	/**
+	 * Checks if Fabric Loader is currently running in a "development"
+	 * environment. Can be used for enabling debug mode or additional checks.
+	 *
+	 * <p>This should not be used to make assumptions on certain features,
+	 * such as mappings, but as a toggle for certain functionalities.</p>
+	 *
+	 * @return whether or not Loader is currently in a "development"
+	 * environment
+	 */
+	boolean isDevelopmentEnvironment();
+
+	/**
+	 * Get the current environment type.
+	 *
+	 * @return the current environment type
+	 */
+	EnvType getEnvironmentType();
+
+	/**
+	 * Get the current game instance. Can represent a game client or
+	 * server object. As such, the exact return is dependent on the
+	 * current environment type.
+	 *
+	 * <p>The game instance may not always be available depending on the game version and {@link EnvType environment}.
+	 *
+	 * @return A client or server instance object
+	 * @deprecated This method is experimental and it's use is discouraged.
+	 */
+	/* @Nullable */
+	@Deprecated
+	Object getGameInstance();
+
+	/**
+	 * Get the current game working directory.
+	 *
+	 * @return the working directory
+	 */
+	Path getGameDir();
+
+	@Deprecated
+	File getGameDirectory();
+
+	/**
+	 * Get the current directory for game configuration files.
+	 *
+	 * @return the configuration directory
+	 */
+	Path getConfigDir();
+
+	@Deprecated
+	File getConfigDirectory();
+
+	/**
+	 * Gets the command line arguments used to launch the game.
+	 *
+	 * <p>The implementation will try to strip or obscure sensitive data like authentication tokens if {@code sanitize}
+	 * is set to true. Callers are highly encouraged to enable sanitization as compromising the information can easily
+	 * happen with logging, exceptions, serialization or other causes.
+	 *
+	 * <p>There is no guarantee that {@code sanitize} covers everything, so the launch arguments should still not be
+	 * logged or otherwise exposed routinely even if the parameter is set to {@code true}. In particular it won't
+	 * necessarily strip all information that can be used to identify the user.
+	 *
+	 * @param sanitize Whether to try to remove or obscure sensitive information
+	 * @return the launch arguments for the game
+	 */
+	String[] getLaunchArguments(boolean sanitize);
+}
diff --git a/src/main/java/net/fabricmc/loader/api/LanguageAdapter.java b/src/main/java/net/fabricmc/loader/api/LanguageAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..037622267386dc5f213027003937212657a28c3c
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/LanguageAdapter.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api;
+
+import net.fabricmc.loader.impl.util.DefaultLanguageAdapter;
+
+/**
+ * Creates instances of objects from custom notations.
+ *
+ * <p>It enables obtaining of other JVM languages' objects with custom instantiation logic.</p>
+ *
+ * <p>A language adapter is defined as so in {@code fabric.mod.json}:
+ * <pre><blockquote>
+ *   "languageAdapter": {
+ *     "&lt;a key&gt;": "&lt;the binary name of the language adapter class&gt;"
+ *   }
+ * </blockquote></pre>
+ * Multiple keys can be present in the {@code languageAdapter} section.</p>
+ *
+ * <p>In the declaration, the language adapter is referred by its <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1">binary name</a>,
+ * such as {@code "mypackage.MyClass$Inner"}. It must have a no-argument public constructor for the Loader to instantiate.</p>
+ *
+ * <p>The {@code default} language adapter from Fabric Loader can accept {@code value} as follows:
+ * <ul>
+ *   <li>A fully qualified reference to a class, in <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1">
+ *   binary name</a>, such as {@code package.MyClass$Inner}, where the class has a public no-argument constructor
+ *   and {@code type} is assignable from the class.
+ *
+ *   <p>An example of an entrypoint class
+ *   <pre><blockquote>
+ *     package net.fabricmc.example;
+ *     import net.fabricmc.api.ModInitializer;
+ *     public class ExampleMod implements ModInitializer {
+ *       public ExampleMod() {} // the constructor must be public no-argument
+ *       {@literal @}Override
+ *       public void onInitialize() {}
+ *     }
+ *   </blockquote></pre>
+ *   You would declare {@code "net.fabricmc.example.ExampleMod"}.</p>
+ *
+ *   <p>For each entrypoint reference, a new instance of the class is created.
+ * 	 If this class implements two separate entrypoints, there will be two distinct
+ * 	 instances of this class in two entrypoint containers.</p>
+ * 	 </li>
+ *
+ *   <li>A fully qualified reference to a class in binary name followed by {@code ::} and a
+ *   field name. The field must be static, and {@code type} must be assignable from
+ *   the field's class.
+ *
+ *   <p>An example of an entrypoint field
+ *   <pre><blockquote>
+ *     package net.fabricmc.example;
+ *     import net.fabricmc.api.ModInitializer;
+ *     public final class ExampleMod implements ModInitializer {
+ *       public static final ExampleMod INSTANCE = new ExampleMod();
+ *
+ *       private ExampleMod() {} // Doesn't need to be instantiable by loader
+ *
+ *       {@literal @}Override
+ *       public void onInitialize() {}
+ *     }
+ *   </blockquote></pre>
+ *   You would declare {@code "net.fabricmc.example.ExampleMod::INSTANCE"}.</p>
+ *   </li>
+ *
+ *   <li>A fully qualified reference to a class in binary name followed by {@code ::} and a
+ *   method name. The method must be capable to implement {@code type} as a
+ *   method reference. If the method is not static, the class must have an
+ *   accessible no-argument constructor for the Loader to create an instance.
+ *
+ *   <p>An example of an entrypoint method
+ *   <pre><blockquote>
+ *     package net.fabricmc.example;
+ *     public final class ExampleMod {
+ *       private ExampleMod() {} // doesn't need to be instantiable by others if method is static
+ *
+ *       public static void init() {}
+ *     }
+ *   </blockquote></pre>
+ *   You would declare {@code "net.fabricmc.example.ExampleMod::init"}.</p>
+ *   </li>
+ * </ul>
+ */
+public interface LanguageAdapter {
+	/**
+	 * Get an instance of the default language adapter.
+	 */
+	static LanguageAdapter getDefault() {
+		return DefaultLanguageAdapter.INSTANCE;
+	}
+
+	/**
+	 * Creates an object of {@code type} from an arbitrary string declaration.
+	 *
+	 * @param mod   the mod which the object is from
+	 * @param value the string declaration of the object
+	 * @param type  the type that the created object must be an instance of
+	 * @param <T>   the type
+	 * @return the created object
+	 * @throws LanguageAdapterException if a problem arises during creation, such as an invalid declaration
+	 */
+	<T> T create(ModContainer mod, String value, Class<T> type) throws LanguageAdapterException;
+}
diff --git a/src/main/java/net/fabricmc/loader/api/LanguageAdapterException.java b/src/main/java/net/fabricmc/loader/api/LanguageAdapterException.java
new file mode 100644
index 0000000000000000000000000000000000000000..84fe9a73562c03e46e592e61149a78382749b41e
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/LanguageAdapterException.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api;
+
+/**
+ * An exception that occurs during a {@link LanguageAdapter}'s object creation.
+ *
+ * @see LanguageAdapter
+ */
+@SuppressWarnings("serial")
+public class LanguageAdapterException extends Exception {
+	/**
+	 * Creates a new language adapter exception.
+	 *
+	 * @param s the message
+	 */
+	public LanguageAdapterException(String s) {
+		super(s);
+	}
+
+	/**
+	 * Creates a new language adapter exception.
+	 *
+	 * @param t the cause
+	 */
+	public LanguageAdapterException(Throwable t) {
+		super(t);
+	}
+
+	/**
+	 * Creates a new language adapter exception.
+	 *
+	 * @param s the message
+	 * @param t the cause
+	 */
+	public LanguageAdapterException(String s, Throwable t) {
+		super(s, t);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/MappingResolver.java b/src/main/java/net/fabricmc/loader/api/MappingResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..0cea14875d573c3555e20545657d924690d3d302
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/MappingResolver.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api;
+
+import java.util.Collection;
+
+/**
+ * Helper class for performing mapping resolution.
+ *
+ * <p><strong>Note</strong>: The target namespace (the one being mapped to) for mapping (or the
+ * source one for unmapping) is always implied to be the one Loader is
+ * currently operating in.</p>
+ *
+ * <p>All the {@code className} used in this resolver are in <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1">binary names</a>,
+ * such as {@code "mypackage.MyClass$Inner"}.</p>
+ *
+ * @since 0.4.1
+ */
+public interface MappingResolver {
+	/**
+	 * Get the list of all available mapping namespaces in the loaded instance.
+	 *
+	 * @return The list of all available namespaces.
+	 */
+	Collection<String> getNamespaces();
+
+	/**
+	 * Get the current namespace being used at runtime.
+	 *
+	 * @return the runtime namespace
+	 */
+	String getCurrentRuntimeNamespace();
+
+	/**
+	 * Map a class name to the mapping currently used at runtime.
+	 *
+	 * @param namespace the namespace of the provided class name
+	 * @param className the provided binary class name
+	 * @return the mapped class name, or {@code className} if no such mapping is present
+	 */
+	String mapClassName(String namespace, String className);
+
+	/**
+	 * Unmap a class name to the mapping currently used at runtime.
+	 *
+	 * @param targetNamespace The target namespace for unmapping.
+	 * @param className the provided binary class name of the mapping form currently used at runtime
+	 * @return the mapped class name, or {@code className} if no such mapping is present
+	 */
+	String unmapClassName(String targetNamespace, String className);
+
+	/**
+	 * Map a field name to the mapping currently used at runtime.
+	 *
+	 * @param namespace the namespace of the provided field name and descriptor
+	 * @param owner the binary name of the owner class of the field
+	 * @param name the name of the field
+	 * @param descriptor the descriptor of the field
+	 * @return the mapped field name, or {@code name} if no such mapping is present
+	 */
+	String mapFieldName(String namespace, String owner, String name, String descriptor);
+
+	/**
+	 * Map a method name to the mapping currently used at runtime.
+	 *
+	 * @param namespace the namespace of the provided method name and descriptor
+	 * @param owner the binary name of the owner class of the method
+	 * @param name the name of the method
+	 * @param descriptor the descriptor of the method
+	 * @return the mapped method name, or {@code name} if no such mapping is present
+	 */
+	String mapMethodName(String namespace, String owner, String name, String descriptor);
+}
diff --git a/src/main/java/net/fabricmc/loader/api/ModContainer.java b/src/main/java/net/fabricmc/loader/api/ModContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..ff44c884a8b37ee336f6d4f7c2a5851d21ae88cf
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/ModContainer.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api;
+
+import net.fabricmc.loader.api.metadata.ModMetadata;
+import net.fabricmc.loader.api.metadata.ModOrigin;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Collection;
+import java.util.List;
+import java.util.Optional;
+
+/**
+ * Represents a mod.
+ */
+public interface ModContainer {
+	/**
+	 * Returns the metadata of this mod.
+	 */
+	ModMetadata getMetadata();
+
+	/**
+	 * Returns the root directories of the mod (inside JAR/folder), exposing its contents.
+	 *
+	 * <p>The paths may point to regular folders or into mod JARs. Multiple root paths may occur in development
+	 * environments with {@code -Dfabric.classPathGroups} as used in multi-project mod setups.
+	 *
+	 * <p>A path returned by this method may be incompatible with {@link Path#toFile} as its FileSystem doesn't
+	 * necessarily represent the OS file system, but potentially a virtual view of jar contents or another abstraction.
+	 *
+	 * @return the root directories of the mod, may be empty for builtin or other synthetic mods
+	 */
+	List<Path> getRootPaths();
+
+	/**
+	 * Gets an NIO reference to a file inside the JAR/folder.
+	 *
+	 * <p>The path, if present, is guaranteed to exist!
+	 *
+	 * <p>A path returned by this method may be incompatible with {@link Path#toFile} as its FileSystem doesn't
+	 * necessarily represent the OS file system, but potentially a virtual view of jar contents or another abstraction.
+	 *
+	 * @param file The location from a root path, using {@code /} as a separator.
+	 * @return optional containing the path to a given file or empty if it can't be found
+	 */
+	default Optional<Path> findPath(String file) {
+		for (Path root : getRootPaths()) {
+			Path path = root.resolve(file.replace("/", root.getFileSystem().getSeparator()));
+			if (Files.exists(path)) return Optional.of(path);
+		}
+
+		return Optional.empty();
+	}
+
+	/**
+	 * Gets where the mod was loaded from originally, the mod jar/folder itself.
+	 *
+	 * <p>This location is not necessarily identical to the code source used at runtime, a mod may get copied or
+	 * otherwise transformed before being put on the class path. It thus mostly represents the installation and initial
+	 * loading, not what is being directly accessed at runtime.
+	 *
+	 * <p>The mod origin is provided for working with the installation like telling the user where a mod has been
+	 * installed at. Accessing the files inside a mod jar/folder should use {@link #findPath} and {@link #getRootPaths}
+	 * instead. Those also abstract jar accesses through the virtual {@code ZipFileSystem} away.
+	 *
+	 * @return mod origin
+	 */
+	ModOrigin getOrigin();
+
+	/**
+	 * Get the mod containing this mod (nested jar parent).
+	 *
+	 * @return mod containing this mod or empty if not nested
+	 */
+	Optional<ModContainer> getContainingMod();
+
+	/**
+	 * Get the active mods contained within this mod (nested jar children).
+	 *
+	 * @return active contained mods within this mod's jar
+	 */
+	Collection<ModContainer> getContainedMods();
+
+	// deprecated methods
+
+	/**
+	 * @deprecated use {@link #getRootPaths()} instead
+	 */
+	@Deprecated
+	default Path getRoot() {
+		return getRootPath();
+	}
+
+	/**
+	 * @deprecated use {@link #getRootPaths()} instead
+	 */
+	@Deprecated
+	Path getRootPath();
+
+	/**
+	 * @deprecated use {@link #findPath} instead
+	 */
+	@Deprecated
+	Path getPath(String file);
+}
diff --git a/src/main/java/net/fabricmc/loader/api/ObjectShare.java b/src/main/java/net/fabricmc/loader/api/ObjectShare.java
new file mode 100644
index 0000000000000000000000000000000000000000..fbc1c1ee0211940e5230b3614c735aafea50c979
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/ObjectShare.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api;
+
+import java.util.function.BiConsumer;
+
+/**
+ * Object share for inter-mod communication, obtainable through {@link FabricLoader#getObjectShare}.
+ *
+ * <p>The share allows mods to exchange data without directly referencing each other. This makes simple interaction
+ * easier by eliminating any compile- or run-time dependencies if the shared value type is independent of the mod
+ * (only Java/game/Fabric types like collections, primitives, String, Consumer, Function, ...).
+ *
+ * <p>Active interaction is possible as well since the shared values can be arbitrary Java objects. For example
+ * exposing a {@code Runnable} or {@code Function} allows the "API" user to directly invoke some program logic.
+ *
+ * <p>It is required to prefix the share key with the mod id like {@code mymod:someProperty}. Mods should not
+ * modify entries by other mods. The share is thread safe.
+ */
+public interface ObjectShare {
+	/**
+	 * Get the value for a specific key.
+	 *
+	 * <p>Java 16 introduced a convenient syntax for type safe queries that combines null check, type check and cast:
+	 * <pre>
+	 * if (FabricLoader.getInstance().getObjectShare().get("someMod:someValue") instanceof String value) {
+	 *   // use value here
+	 * }
+	 * </pre>
+	 *
+	 * <p>A generic type still needs a second unchecked cast due to erasure:
+	 * <pre>
+	 * if (FabricLoader.getInstance().getObjectShare().get("mymod:fuel") instanceof Consumer{@code<?>} c) {
+	 *   ((Consumer{@code<ItemStack>}) c).accept(someStack);
+	 * }
+	 * </pre>
+	 *
+	 * <p>Consider using {@link #whenAvailable} instead if the value may not be available yet. The mod load order is
+	 * undefined, so entries that are added during the same load phase should be queried in a later phase or be handled
+	 * through {@link whenAvailable}.
+	 *
+	 * @param key key to query, format {@code modid:subkey}
+	 * @return value associated with the key or null if none
+	 */
+	Object get(String key);
+
+	/**
+	 * Request being notified when a key/value becomes available.
+	 *
+	 * <p>This is primarily intended to resolve load order issues, when there is no good time to call {@link get}.
+	 *
+	 * <p>If there is already a value associated with the {@code key}, the consumer will be invoked directly, otherwise
+	 * when one of the {@code put} methods adds a value for the key. The invocation happens on the thread calling
+	 * {@link #whenAvailable} or on whichever thread calls {@code put} with the same {@code key}.
+	 *
+	 * <p>The request will only act once, not if the value changes again.
+	 *
+	 * <p>Example use:
+	 * <pre>
+	 * FabricLoader.getInstance().getObjectShare().whenAvailable("someMod:someValue", (k, v) -> {
+	 *   if (v instanceof String value) {
+	 *     // use value
+	 *   }
+	 * });
+	 * </pre>
+	 *
+	 * @param key key to react upon, format {@code modid:subkey}
+	 * @paran consumer consumer receiving the key/value pair: key first, value second
+	 */
+	void whenAvailable(String key, BiConsumer<String, Object> consumer);
+
+	/**
+	 * Set the value for a specific key.
+	 *
+	 * @param key key to add a value for, format {@code modid:subkey}
+	 * @param value value to add, must not be null
+	 * @return previous value associated with the key, null if none
+	 */
+	Object put(String key, Object value);
+
+	/**
+	 * Set the value for a specific key if there isn't one yet.
+	 *
+	 * <p>This is an atomic operation, thus thread safe contrary to using get+put.
+	 *
+	 * @param key key to add a value for, format {@code modid:subkey}
+	 * @param value value to add, must not be null
+	 * @return previous value associated with the key, null if none and thus the entry changed
+	 */
+	Object putIfAbsent(String key, Object value);
+
+	/**
+	 * Remove the value for a specific key.
+	 *
+	 * @param key key to remove the value for, format {@code modid:subkey}
+	 * @return previous value associated with the key, null if none
+	 */
+	Object remove(String key);
+}
diff --git a/src/main/java/net/fabricmc/loader/api/SemanticVersion.java b/src/main/java/net/fabricmc/loader/api/SemanticVersion.java
new file mode 100644
index 0000000000000000000000000000000000000000..2f839e336c03b2f4da482e25fbd56542d00381a1
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/SemanticVersion.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api;
+
+import net.fabricmc.loader.impl.util.version.VersionParser;
+
+import java.util.Optional;
+
+/**
+ * Represents a <a href="https://semver.org/">Sematic Version</a>.
+ *
+ * <p>Compared to a regular {@link Version}, this type of version receives better support
+ * for version comparisons in dependency notations, and is preferred.</p>
+ *
+ * @see Version
+ */
+public interface SemanticVersion extends Version {
+	/**
+	 * The value of {@linkplain #getVersionComponent(int) version component} that indicates
+	 * a {@linkplain #hasWildcard() wildcard}.
+	 */
+	int COMPONENT_WILDCARD = Integer.MIN_VALUE;
+
+	/**
+	 * Returns the number of components in this version.
+	 *
+	 * <p>For example, {@code 1.3.x} has 3 components.</p>
+	 *
+	 * @return the number of components
+	 */
+	int getVersionComponentCount();
+
+	/**
+	 * Returns the version component at {@code pos}.
+	 *
+	 * <p>May return {@link #COMPONENT_WILDCARD} to indicate a wildcard component.</p>
+	 *
+	 * <p>If the pos exceeds the number of components, returns {@link #COMPONENT_WILDCARD}
+	 * if the version {@linkplain #hasWildcard() has wildcard}; otherwise returns {@code 0}.</p>
+	 *
+	 * @param pos the position to check
+	 * @return the version component
+	 */
+	int getVersionComponent(int pos);
+
+	/**
+	 * Returns the prerelease key in the version notation.
+	 *
+	 * <p>The prerelease key is indicated by a {@code -} before a {@code +} in
+	 * the version notation.</p>
+	 *
+	 * @return the optional prerelease key
+	 */
+	Optional<String> getPrereleaseKey();
+
+	/**
+	 * Returns the build key in the version notation.
+	 *
+	 * <p>The build key is indicated by a {@code +} in the version notation.</p>
+	 *
+	 * @return the optional build key
+	 */
+	Optional<String> getBuildKey();
+
+	/**
+	 * Returns if a wildcard notation is present in this version.
+	 *
+	 * <p>A wildcard notation is a {@code x}, {@code X}, or {@code *} in the version string,
+	 * such as {@code 2.5.*}.</p>
+	 *
+	 * @return whether this version has a wildcard notation
+	 */
+	boolean hasWildcard();
+
+	/**
+	 * @deprecated Use {@link #compareTo(Version)} instead
+	 */
+	@Deprecated
+	default int compareTo(SemanticVersion o) {
+		return compareTo((Version) o);
+	}
+
+	/**
+	 * Parses a semantic version from a string notation.
+	 *
+	 * @param s the string notation of the version
+	 * @return the parsed version
+	 * @throws VersionParsingException if a problem arises during version parsing
+	 */
+	static SemanticVersion parse(String s) throws Exception {
+		return VersionParser.parseSemantic(s);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/Version.java b/src/main/java/net/fabricmc/loader/api/Version.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f0692fc9c48372c953b86fa7bf82b652bcbf946
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/Version.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api;
+
+import net.fabricmc.loader.api.metadata.ModMetadata;
+import net.fabricmc.loader.impl.util.version.VersionParser;
+
+/**
+ * Represents a version of a mod.
+ *
+ * @see ModMetadata#getVersion()
+ */
+public interface Version extends Comparable<Version> {
+	/**
+	 * Returns the user-friendly representation of this version.
+	 */
+	String getFriendlyString();
+
+	/**
+	 * Parses a version from a string notation.
+	 *
+	 * @param string the string notation of the version
+	 * @return the parsed version
+	 * @throws VersionParsingException if a problem arises during version parsing
+	 */
+	static Version parse(String string) throws Exception {
+		return VersionParser.parse(string, false);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/VersionParsingException.java b/src/main/java/net/fabricmc/loader/api/VersionParsingException.java
new file mode 100644
index 0000000000000000000000000000000000000000..53cb86a082f7141b774fa69cbec77108f8fe18bd
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/VersionParsingException.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api;
+
+@SuppressWarnings({ "deprecation", "serial" }) //Extending the deprecated one for backwards compatibility
+public class VersionParsingException extends Exception {
+	public VersionParsingException() {
+		super();
+	}
+
+	public VersionParsingException(Throwable t) {
+		super(t);
+	}
+
+	public VersionParsingException(String s) {
+		super(s);
+	}
+
+	public VersionParsingException(String s, Throwable t) {
+		super(s, t);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/entrypoint/EntrypointContainer.java b/src/main/java/net/fabricmc/loader/api/entrypoint/EntrypointContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..455a5eea3ca25b934c997ed4d522d26597756cc3
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/entrypoint/EntrypointContainer.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.entrypoint;
+
+import net.fabricmc.loader.api.ModContainer;
+
+/**
+ * A container holding both an entrypoint instance and the {@link ModContainer} which has provided the entrypoint.
+ *
+ * @param <T> The type of the entrypoint
+ * @see net.fabricmc.loader.api.FabricLoader#getEntrypointContainers(String, Class)
+ */
+public interface EntrypointContainer<T> {
+	/**
+	 * Returns the entrypoint instance. It will be constructed the first time you call this method.
+	 */
+	T getEntrypoint();
+
+	/**
+	 * Returns the mod that provided this entrypoint.
+	 */
+	ModContainer getProvider();
+}
diff --git a/src/main/java/net/fabricmc/loader/api/entrypoint/PreLaunchEntrypoint.java b/src/main/java/net/fabricmc/loader/api/entrypoint/PreLaunchEntrypoint.java
new file mode 100644
index 0000000000000000000000000000000000000000..a783735ca435793383a92c8dce346499e9054d0a
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/entrypoint/PreLaunchEntrypoint.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.entrypoint;
+
+/**
+ * Entrypoint getting invoked just before launching the game.
+ *
+ * <p><b>Avoid interfering with the game from this!</b> Accessing anything needs careful consideration to avoid
+ * interfering with its own initialization or otherwise harming its state. It is recommended to implement this interface
+ * on its own class to avoid running static initializers too early, e.g. because they were referenced in field or method
+ * signatures in the same class.
+ *
+ * <p>The entrypoint is exposed with {@code preLaunch} key in the mod json and runs for any environment. It usually
+ * executes several seconds before the {@code main}/{@code client}/{@code server} entrypoints.
+ *
+ * @see net.fabricmc.loader.api.FabricLoader#getEntrypointContainers(String, Class)
+ */
+@FunctionalInterface
+public interface PreLaunchEntrypoint {
+	/**
+	 * Runs the entrypoint.
+	 */
+	void onPreLaunch();
+}
diff --git a/src/main/java/net/fabricmc/loader/api/metadata/ContactInformation.java b/src/main/java/net/fabricmc/loader/api/metadata/ContactInformation.java
new file mode 100644
index 0000000000000000000000000000000000000000..7e8ce83f4d1e627153045e05acead418af20f1cd
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/metadata/ContactInformation.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.metadata;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Optional;
+
+/**
+ * Represents a contact information.
+ */
+public interface ContactInformation {
+	/**
+	 * An empty contact information.
+	 */
+	ContactInformation EMPTY = new ContactInformation() {
+		@Override
+		public Optional<String> get(String key) {
+			return Optional.empty();
+		}
+
+		@Override
+		public Map<String, String> asMap() {
+			return Collections.emptyMap();
+		}
+	};
+
+	/**
+	 * Gets a certain type of contact information.
+	 *
+	 * @param key the type of contact information
+	 * @return an optional contact information
+	 */
+	Optional<String> get(String key);
+
+	/**
+	 * Gets all contact information provided as a map from contact type to information.
+	 */
+	Map<String, String> asMap();
+}
diff --git a/src/main/java/net/fabricmc/loader/api/metadata/CustomValue.java b/src/main/java/net/fabricmc/loader/api/metadata/CustomValue.java
new file mode 100644
index 0000000000000000000000000000000000000000..4afa26d35458246abeb88c5da8bd225666c1a87f
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/metadata/CustomValue.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.metadata;
+
+import java.util.Map;
+
+/**
+ * Represents a custom value in the {@code fabric.mod.json}.
+ */
+public interface CustomValue {
+	/**
+	 * Returns the type of the value.
+	 */
+	CvType getType();
+
+	/**
+	 * Returns this value as an {@link CvType#OBJECT}.
+	 *
+	 * @return this value
+	 * @throws ClassCastException if this value is not an object
+	 */
+	CvObject getAsObject();
+
+	/**
+	 * Returns this value as an {@link CvType#ARRAY}.
+	 *
+	 * @return this value
+	 * @throws ClassCastException if this value is not an array
+	 */
+	CvArray getAsArray();
+
+	/**
+	 * Returns this value as a {@link CvType#STRING}.
+	 *
+	 * @return this value
+	 * @throws ClassCastException if this value is not a string
+	 */
+	String getAsString();
+
+	/**
+	 * Returns this value as a {@link CvType#NUMBER}.
+	 *
+	 * @return this value
+	 * @throws ClassCastException if this value is not a number
+	 */
+	Number getAsNumber();
+
+	/**
+	 * Returns this value as a {@link CvType#BOOLEAN}.
+	 *
+	 * @return this value
+	 * @throws ClassCastException if this value is not a boolean
+	 */
+	boolean getAsBoolean();
+
+	/**
+	 * Represents an {@link CvType#OBJECT} value.
+	 */
+	interface CvObject extends CustomValue, Iterable<Map.Entry<String, CustomValue>> {
+		/**
+		 * Returns the number of key-value pairs within this object value.
+		 */
+		int size();
+
+		/**
+		 * Returns whether a {@code key} is present within this object value.
+		 *
+		 * @param key the key to check
+		 * @return whether the key is present
+		 */
+		boolean containsKey(String key);
+
+		/**
+		 * Gets the value associated with a {@code key} within this object value.
+		 *
+		 * @param key the key to check
+		 * @return the value associated, or {@code null} if no such value is present
+		 */
+		CustomValue get(String key);
+	}
+
+	/**
+	 * Represents an {@link CvType#ARRAY} value.
+	 */
+	interface CvArray extends CustomValue, Iterable<CustomValue> {
+		/**
+		 * Returns the number of values within this array value.
+		 */
+		int size();
+
+		/**
+		 * Gets the value at {@code index} within this array value.
+		 *
+		 * @param index the index of the value
+		 * @return the value associated
+		 * @throws IndexOutOfBoundsException if the index is not within {{@link #size()}}
+		 */
+		CustomValue get(int index);
+	}
+
+	/**
+	 * The possible types of a custom value.
+	 */
+	enum CvType {
+		OBJECT, ARRAY, STRING, NUMBER, BOOLEAN, NULL;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/metadata/ModDependency.java b/src/main/java/net/fabricmc/loader/api/metadata/ModDependency.java
new file mode 100644
index 0000000000000000000000000000000000000000..07aad9480e6ef23e115c9380234258e7263c85ef
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/metadata/ModDependency.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.metadata;
+
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.metadata.version.VersionInterval;
+import net.fabricmc.loader.api.metadata.version.VersionPredicate;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Represents a dependency.
+ */
+public interface ModDependency {
+	/**
+	 * Get the kind of dependency.
+	 */
+	Kind getKind();
+
+	/**
+	 * Returns the ID of the mod to check.
+	 */
+	String getModId();
+
+	/**
+	 * Returns if the version fulfills this dependency's version requirement.
+	 *
+	 * @param version the version to check
+	 */
+	boolean matches(Version version);
+
+	/**
+	 * Returns a representation of the dependency's version requirements.
+	 *
+	 * @return representation of the dependency's version requirements
+	 */
+	Collection<VersionPredicate> getVersionRequirements();
+
+	/**
+	 * Returns the version intervals covered by the dependency's version requirements.
+	 *
+	 * <p>There may be multiple because the allowed range may not be consecutive.
+	 */
+	List<VersionInterval> getVersionIntervals();
+
+	enum Kind {
+		DEPENDS("depends", true, false),
+		RECOMMENDS("recommends", true, true),
+		SUGGESTS("suggests", true, true),
+		CONFLICTS("conflicts", false, true),
+		BREAKS("breaks", false, false);
+
+		private static final Map<String, Kind> map = createMap();
+		private final String key;
+		private final boolean positive;
+		private final boolean soft;
+
+		Kind(String key, boolean positive, boolean soft) {
+			this.key = key;
+			this.positive = positive;
+			this.soft = soft;
+		}
+
+		/**
+		 * Get the key for the dependency as used by fabric.mod.json (v1+) and dependency overrides.
+		 */
+		public String getKey() {
+			return key;
+		}
+
+		/**
+		 * Get whether the dependency is positive, encouraging the inclusion of a mod instead of negative/discouraging.
+		 */
+		public boolean isPositive() {
+			return positive;
+		}
+
+		/**
+		 * Get whether it is a soft dependency, allowing the mod to still load if the dependency is unmet.
+		 */
+		public boolean isSoft() {
+			return soft;
+		}
+
+		/**
+		 * Parse a dependency kind from its key as provided by {@link #getKey}.
+		 */
+		public static Kind parse(String key) {
+			return map.get(key);
+		}
+
+		private static Map<String, Kind> createMap() {
+			Kind[] values = values();
+			Map<String, Kind> ret = new HashMap<>(values.length);
+
+			for (Kind kind : values) {
+				ret.put(kind.key, kind);
+			}
+
+			return ret;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/metadata/ModEnvironment.java b/src/main/java/net/fabricmc/loader/api/metadata/ModEnvironment.java
new file mode 100644
index 0000000000000000000000000000000000000000..44f7052dd80064353fb4963455449aaaf949095a
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/metadata/ModEnvironment.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.metadata;
+
+import net.fabricmc.api.EnvType;
+
+public enum ModEnvironment {
+	CLIENT,
+	SERVER,
+	UNIVERSAL;
+
+	public boolean matches(EnvType type) {
+		switch (this) {
+		case CLIENT:
+			return type == EnvType.CLIENT;
+		case SERVER:
+			return type == EnvType.SERVER;
+		case UNIVERSAL:
+			return true;
+		default:
+			return false;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/metadata/ModMetadata.java b/src/main/java/net/fabricmc/loader/api/metadata/ModMetadata.java
new file mode 100644
index 0000000000000000000000000000000000000000..4b0ba2ceda27a5fb0d58fba7c3b3e64d06347c6f
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/metadata/ModMetadata.java
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.metadata;
+
+import net.fabricmc.loader.api.Version;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+/**
+ * The metadata of a mod.
+ */
+public interface ModMetadata {
+	/**
+	 * Returns the type of the mod.
+	 *
+	 * <p>The types may be {@code fabric} or {@code builtin} by default.</p>
+	 *
+	 * @return the type of the mod
+	 */
+	String getType();
+
+	// When adding getters, follow the order as presented on the wiki.
+	// No defaults.
+
+	/**
+	 * Returns the mod's ID.
+	 *
+	 * <p>A mod's id must have only lowercase letters, digits, {@code -}, or {@code _}.</p>
+	 *
+	 * @return the mod's ID.
+	 */
+	String getId();
+
+	/**
+	 * Returns the mod's ID provides.
+	 *
+	 * <p>The aliases follow the same rules as ID</p>
+	 *
+	 * @return the mod's ID provides
+	 */
+	Collection<String> getProvides();
+
+	/**
+	 * Returns the mod's version.
+	 */
+	Version getVersion();
+
+	/**
+	 * Returns the mod's environment.
+	 */
+	ModEnvironment getEnvironment();
+
+	/**
+	 * Returns all of the mod's dependencies.
+	 */
+	Collection<ModDependency> getDependencies();
+
+	/**
+	 * Returns the mod's required dependencies, without which the Loader will terminate loading.
+	 *
+	 * @deprecated Use {@link #getDependencies()} and filter for {@link ModDependency.Kind#DEPENDS} instead
+	 */
+	@Deprecated
+	default Collection<ModDependency> getDepends() {
+		return getDependencies().stream().filter(d -> d.getKind() == ModDependency.Kind.DEPENDS).collect(Collectors.toList());
+	}
+
+	/**
+	 * Returns the mod's recommended dependencies, without which the Loader will emit a warning.
+	 *
+	 * @deprecated Use {@link #getDependencies()} and filter for {@link ModDependency.Kind#RECOMMENDS} instead
+	 */
+	@Deprecated
+	default Collection<ModDependency> getRecommends() {
+		return getDependencies().stream().filter(d -> d.getKind() == ModDependency.Kind.RECOMMENDS).collect(Collectors.toList());
+	}
+
+	/**
+	 * Returns the mod's suggested dependencies.
+	 *
+	 * @deprecated Use {@link #getDependencies()} and filter for {@link ModDependency.Kind#SUGGESTS} instead
+	 */
+	@Deprecated
+	default Collection<ModDependency> getSuggests() {
+		return getDependencies().stream().filter(d -> d.getKind() == ModDependency.Kind.SUGGESTS).collect(Collectors.toList());
+	}
+
+	/**
+	 * Returns the mod's conflicts, with which the Loader will emit a warning.
+	 *
+	 * @deprecated Use {@link #getDependencies()} and filter for {@link ModDependency.Kind#CONFLICTS} instead
+	 */
+	@Deprecated
+	default Collection<ModDependency> getConflicts() {
+		return getDependencies().stream().filter(d -> d.getKind() == ModDependency.Kind.CONFLICTS).collect(Collectors.toList());
+	}
+
+	/**
+	 * Returns the mod's conflicts, with which the Loader will terminate loading.
+	 *
+	 * @deprecated Use {@link #getDependencies()} and filter for {@link ModDependency.Kind#BREAKS} instead
+	 */
+	@Deprecated
+	default Collection<ModDependency> getBreaks() {
+		return getDependencies().stream().filter(d -> d.getKind() == ModDependency.Kind.BREAKS).collect(Collectors.toList());
+	}
+
+	/**
+	 * Returns the mod's display name.
+	 */
+	String getName();
+
+	/**
+	 * Returns the mod's description.
+	 */
+	String getDescription();
+
+	/**
+	 * Returns the mod's authors.
+	 */
+	Collection<Person> getAuthors();
+
+	/**
+	 * Returns the mod's contributors.
+	 */
+	Collection<Person> getContributors();
+
+	/**
+	 * Returns the mod's contact information.
+	 */
+	ContactInformation getContact();
+
+	/**
+	 * Returns the mod's licenses.
+	 */
+	Collection<String> getLicense();
+
+	/**
+	 * Gets the path to an icon.
+	 *
+	 * <p>The standard defines icons as square .PNG files, however their
+	 * dimensions are not defined - in particular, they are not
+	 * guaranteed to be a power of two.</p>
+	 *
+	 * <p>The preferred size is used in the following manner:
+	 * <ul><li>the smallest image larger than or equal to the size
+	 * is returned, if one is present;</li>
+	 * <li>failing that, the largest image is returned.</li></ul></p>
+	 *
+	 * @param size the preferred size
+	 * @return the icon path, if any
+	 */
+	Optional<String> getIconPath(int size);
+
+	/**
+	 * Returns if the mod's {@code fabric.mod.json} declares a custom value under {@code key}.
+	 *
+	 * @param key the key
+	 * @return whether a custom value is present
+	 */
+	boolean containsCustomValue(String key);
+
+	/**
+	 * Returns the mod's {@code fabric.mod.json} declared custom value under {@code key}.
+	 *
+	 * @param key the key
+	 * @return the custom value, or {@code null} if no such value is present
+	 */
+	/* @Nullable */
+	CustomValue getCustomValue(String key);
+
+	/**
+	 * Gets all custom values defined by this mod.
+	 *
+	 * <p>Note this map is unmodifiable.
+	 *
+	 * @return a map containing the custom values this mod defines.
+	 */
+	Map<String, CustomValue> getCustomValues();
+
+	/**
+	 * @deprecated Use {@link #containsCustomValue} instead, this will be removed (can't expose GSON types)!
+	 */
+	@Deprecated
+	boolean containsCustomElement(String key);
+}
diff --git a/src/main/java/net/fabricmc/loader/api/metadata/ModOrigin.java b/src/main/java/net/fabricmc/loader/api/metadata/ModOrigin.java
new file mode 100644
index 0000000000000000000000000000000000000000..bb1540069315f7ed6fe1a6d9985929bac27fc760
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/metadata/ModOrigin.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.metadata;
+
+import java.nio.file.Path;
+import java.util.List;
+
+/**
+ * Representation of the various locations a mod was loaded from originally.
+ *
+ * <p>This location is not necessarily identical to the code source used at runtime, a mod may get copied or otherwise
+ * transformed before being put on the class path. It thus mostly represents the installation and initial loading, not
+ * what is being directly accessed at runtime.
+ */
+public interface ModOrigin {
+	/**
+	 * Get the kind of this origin, determines the available methods.
+	 *
+	 * @return mod origin kind
+	 */
+	Kind getKind();
+
+	/**
+	 * Get the jar or folder paths for a {@link Kind#PATH} origin.
+	 *
+	 * @return jar or folder paths
+	 * @throws UnsupportedOperationException for incompatible kinds
+	 */
+	List<Path> getPaths();
+
+	/**
+	 * Get the parent mod for a {@link Kind#NESTED} origin.
+	 *
+	 * @return parent mod
+	 * @throws UnsupportedOperationException for incompatible kinds
+	 */
+	String getParentModId();
+
+	/**
+	 * Get the sub-location within the parent mod for a {@link Kind#NESTED} origin.
+	 *
+	 * @return sub-location
+	 * @throws UnsupportedOperationException for incompatible kinds
+	 */
+	String getParentSubLocation();
+
+	/**
+	 * Non-exhaustive list of possible {@link ModOrigin} kinds.
+	 *
+	 * <p>New kinds may be added in the future, use a default switch case!
+	 */
+	enum Kind {
+		PATH, NESTED, UNKNOWN
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/metadata/Person.java b/src/main/java/net/fabricmc/loader/api/metadata/Person.java
new file mode 100644
index 0000000000000000000000000000000000000000..9de4cf99594131ab04645b7598bc2942268351f1
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/metadata/Person.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.metadata;
+
+/**
+ * Represents a person.
+ */
+public interface Person {
+	/**
+	 * Returns the display name of the person.
+	 */
+	String getName();
+
+	/**
+	 * Returns the contact information of the person.
+	 */
+	ContactInformation getContact();
+}
diff --git a/src/main/java/net/fabricmc/loader/api/metadata/version/VersionComparisonOperator.java b/src/main/java/net/fabricmc/loader/api/metadata/version/VersionComparisonOperator.java
new file mode 100644
index 0000000000000000000000000000000000000000..ea20e4e123e408697941f53d2a98fee7efab937e
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/metadata/version/VersionComparisonOperator.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.metadata.version;
+
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.impl.util.version.SemanticVersionImpl;
+
+public enum VersionComparisonOperator {
+	// order is important to match the longest substring (e.g. try >= before >)
+	GREATER_EQUAL(">=", true, false) {
+		@Override
+		public boolean test(SemanticVersion a, SemanticVersion b) {
+			return a.compareTo((Version) b) >= 0;
+		}
+
+		@Override
+		public SemanticVersion minVersion(SemanticVersion version) {
+			return version;
+		}
+	},
+	LESS_EQUAL("<=", false, true) {
+		@Override
+		public boolean test(SemanticVersion a, SemanticVersion b) {
+			return a.compareTo((Version) b) <= 0;
+		}
+
+		@Override
+		public SemanticVersion maxVersion(SemanticVersion version) {
+			return version;
+		}
+	},
+	GREATER(">", false, false) {
+		@Override
+		public boolean test(SemanticVersion a, SemanticVersion b) {
+			return a.compareTo((Version) b) > 0;
+		}
+
+		@Override
+		public SemanticVersion minVersion(SemanticVersion version) {
+			return version;
+		}
+	},
+	LESS("<", false, false) {
+		@Override
+		public boolean test(SemanticVersion a, SemanticVersion b) {
+			return a.compareTo((Version) b) < 0;
+		}
+
+		@Override
+		public SemanticVersion maxVersion(SemanticVersion version) {
+			return version;
+		}
+	},
+	EQUAL("=", true, true) {
+		@Override
+		public boolean test(SemanticVersion a, SemanticVersion b) {
+			return a.compareTo((Version) b) == 0;
+		}
+
+		@Override
+		public SemanticVersion minVersion(SemanticVersion version) {
+			return version;
+		}
+
+		@Override
+		public SemanticVersion maxVersion(SemanticVersion version) {
+			return version;
+		}
+	},
+	SAME_TO_NEXT_MINOR("~", true, false) {
+		@Override
+		public boolean test(SemanticVersion a, SemanticVersion b) {
+			return a.compareTo((Version) b) >= 0
+					&& a.getVersionComponent(0) == b.getVersionComponent(0)
+					&& a.getVersionComponent(1) == b.getVersionComponent(1);
+		}
+
+		@Override
+		public SemanticVersion minVersion(SemanticVersion version) {
+			return version;
+		}
+
+		@Override
+		public SemanticVersion maxVersion(SemanticVersion version) {
+			return new SemanticVersionImpl(new int[] { version.getVersionComponent(0), version.getVersionComponent(1) + 1 }, "", null);
+		}
+	},
+	SAME_TO_NEXT_MAJOR("^", true, false) {
+		@Override
+		public boolean test(SemanticVersion a, SemanticVersion b) {
+			return a.compareTo((Version) b) >= 0
+					&& a.getVersionComponent(0) == b.getVersionComponent(0);
+		}
+
+		@Override
+		public SemanticVersion minVersion(SemanticVersion version) {
+			return version;
+		}
+
+		@Override
+		public SemanticVersion maxVersion(SemanticVersion version) {
+			return new SemanticVersionImpl(new int[] { version.getVersionComponent(0) + 1 }, "", null);
+		}
+	};
+
+	private final String serialized;
+	private final boolean minInclusive;
+	private final boolean maxInclusive;
+
+	VersionComparisonOperator(String serialized, boolean minInclusive, boolean maxInclusive) {
+		this.serialized = serialized;
+		this.minInclusive = minInclusive;
+		this.maxInclusive = maxInclusive;
+	}
+
+	public final String getSerialized() {
+		return serialized;
+	}
+
+	public final boolean isMinInclusive() {
+		return minInclusive;
+	}
+
+	public final boolean isMaxInclusive() {
+		return maxInclusive;
+	}
+
+	public final boolean test(Version a, Version b) {
+		if (a instanceof SemanticVersion && b instanceof SemanticVersion) {
+			return test((SemanticVersion) a, (SemanticVersion) b);
+		} else if (minInclusive || maxInclusive) {
+			return a.getFriendlyString().equals(b.getFriendlyString());
+		} else {
+			return false;
+		}
+	}
+
+	public abstract boolean test(SemanticVersion a, SemanticVersion b);
+
+	public SemanticVersion minVersion(SemanticVersion version) {
+		return null;
+	}
+
+	public SemanticVersion maxVersion(SemanticVersion version) {
+		return null;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/metadata/version/VersionInterval.java b/src/main/java/net/fabricmc/loader/api/metadata/version/VersionInterval.java
new file mode 100644
index 0000000000000000000000000000000000000000..18f82a972edc63a930292d38f6e944e37a9f2f83
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/metadata/version/VersionInterval.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.metadata.version;
+
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.impl.util.version.VersionIntervalImpl;
+
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * Representation of a version interval, closed or open.
+ *
+ * <p>The represented version interval is contiguous between its lower and upper limit, disjoint intervals are built
+ * using collections of {@link VersionInterval}. Empty intervals may be represented by {@code null} or any interval
+ * @code (x,x)} with x being a non-{@code null} version and both endpoints being exclusive.
+ */
+public interface VersionInterval {
+	VersionInterval INFINITE = new VersionIntervalImpl(null, false, null, false);
+
+	/**
+	 * Get whether the interval uses {@link SemanticVersion} compatible bounds.
+	 *
+	 * @return True if both bounds are open (null), {@link SemanticVersion} instances or a combination of both, false otherwise.
+	 */
+	boolean isSemantic();
+
+	/**
+	 * Get the lower limit of the version interval.
+	 *
+	 * @return Version's lower limit or null if none, inclusive depending on {@link #isMinInclusive()}
+	 */
+	Version getMin();
+
+	/**
+	 * Get whether the lower limit of the version interval is inclusive.
+	 *
+	 * @return True if inclusive, false otherwise
+	 */
+	boolean isMinInclusive();
+
+	/**
+	 * Get the upper limit of the version interval.
+	 *
+	 * @return Version's upper limit or null if none, inclusive depending on {@link #isMaxInclusive()}
+	 */
+	Version getMax();
+
+	/**
+	 * Get whether the upper limit of the version interval is inclusive.
+	 *
+	 * @return True if inclusive, false otherwise
+	 */
+	boolean isMaxInclusive();
+
+	default VersionInterval and(VersionInterval o) {
+		return and(this, o);
+	}
+
+	default List<VersionInterval> or(Collection<VersionInterval> o) {
+		return or(o, this);
+	}
+
+	default List<VersionInterval> not() {
+		return not(this);
+	}
+
+	/**
+	 * Compute the intersection between two version intervals.
+	 */
+	static VersionInterval and(VersionInterval a, VersionInterval b) {
+		return VersionIntervalImpl.and(a, b);
+	}
+
+	/**
+	 * Compute the intersection between two potentially disjoint of version intervals.
+	 */
+	static List<VersionInterval> and(Collection<VersionInterval> a, Collection<VersionInterval> b) {
+		return VersionIntervalImpl.and(a, b);
+	}
+
+	/**
+	 * Compute the union between multiple version intervals.
+	 */
+	static List<VersionInterval> or(Collection<VersionInterval> a, VersionInterval b) {
+		return VersionIntervalImpl.or(a, b);
+	}
+
+	static List<VersionInterval> not(VersionInterval interval) {
+		return VersionIntervalImpl.not(interval);
+	}
+
+	static List<VersionInterval> not(Collection<VersionInterval> intervals) {
+		return VersionIntervalImpl.not(intervals);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/api/metadata/version/VersionPredicate.java b/src/main/java/net/fabricmc/loader/api/metadata/version/VersionPredicate.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e9e2638056ee9fb0539cfb0f38537ae5b534ab0
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/api/metadata/version/VersionPredicate.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.api.metadata.version;
+
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.impl.util.version.VersionPredicateParser;
+
+import java.util.Collection;
+import java.util.function.Predicate;
+
+public interface VersionPredicate extends Predicate<Version> {
+	/**
+	 * Get all terms that have to be satisfied for this predicate to match.
+	 *
+	 * @return Required predicate terms, empty if anything matches
+	 */
+	Collection<? extends PredicateTerm> getTerms();
+
+	/**
+	 * Get the version interval representing the matched versions.
+	 *
+	 * @return Covered version interval or null if nothing
+	 */
+	VersionInterval getInterval();
+
+	interface PredicateTerm {
+		VersionComparisonOperator getOperator();
+		Version getReferenceVersion();
+	}
+
+	static VersionPredicate parse(String predicate) throws Exception {
+		return VersionPredicateParser.parse(predicate);
+	}
+
+	static Collection<VersionPredicate> parse(Collection<String> predicates) throws Exception {
+		return VersionPredicateParser.parse(predicates);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/FabricLoaderImpl.java b/src/main/java/net/fabricmc/loader/impl/FabricLoaderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..9d9b9d887401a8f6681abd9661cd6b5e9447e925
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/FabricLoaderImpl.java
@@ -0,0 +1,525 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl;
+
+import net.fabricmc.accesswidener.AccessWidener;
+import net.fabricmc.accesswidener.AccessWidenerReader;
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.LanguageAdapter;
+import net.fabricmc.loader.api.MappingResolver;
+import net.fabricmc.loader.api.ModContainer;
+import net.fabricmc.loader.api.ObjectShare;
+import net.fabricmc.loader.api.entrypoint.EntrypointContainer;
+import net.fabricmc.loader.impl.discovery.*;
+import net.fabricmc.loader.impl.entrypoint.EntrypointStorage;
+import net.fabricmc.loader.impl.game.GameProvider;
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import net.fabricmc.loader.impl.launch.knot.Knot;
+import net.fabricmc.loader.impl.metadata.DependencyOverrides;
+import net.fabricmc.loader.impl.metadata.EntrypointMetadata;
+import net.fabricmc.loader.impl.metadata.LoaderModMetadata;
+import net.fabricmc.loader.impl.metadata.VersionOverrides;
+import net.fabricmc.loader.impl.util.DefaultLanguageAdapter;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import org.objectweb.asm.Opcodes;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+
+@SuppressWarnings("deprecation")
+public final class FabricLoaderImpl extends net.fabricmc.loader.FabricLoader {
+	public static final FabricLoaderImpl INSTANCE = InitHelper.get();
+
+	public static final int ASM_VERSION = Opcodes.ASM9;
+
+	public static final String VERSION = "0.14.6";
+	public static final String MOD_ID = "fabricloader";
+
+	public static final String CACHE_DIR_NAME = ".fabric"; // relative to game dir
+	private static final String PROCESSED_MODS_DIR_NAME = "processedMods"; // relative to cache dir
+	public static final String REMAPPED_JARS_DIR_NAME = "remappedJars"; // relative to cache dir
+	private static final String TMP_DIR_NAME = "tmp"; // relative to cache dir
+
+	protected final Map<String, ModContainerImpl> modMap = new HashMap<>();
+	private List<ModCandidate> modCandidates;
+	protected List<ModContainerImpl> mods = new ArrayList<>();
+
+	private final Map<String, LanguageAdapter> adapterMap = new HashMap<>();
+	private final EntrypointStorage entrypointStorage = new EntrypointStorage();
+	private final AccessWidener accessWidener = new AccessWidener();
+
+	private final ObjectShare objectShare = new ObjectShareImpl();
+
+	private boolean frozen = false;
+
+	private Object gameInstance;
+
+	private MappingResolver mappingResolver;
+	private GameProvider provider;
+	private Path gameDir;
+	private Path configDir;
+
+	private FabricLoaderImpl() { }
+
+	/**
+	 * Freeze the FabricLoader, preventing additional mods from being loaded.
+	 */
+	public void freeze() {
+		if (frozen) {
+			throw new IllegalStateException("Already frozen!");
+		}
+
+		frozen = true;
+		finishModLoading();
+	}
+
+	public GameProvider getGameProvider() {
+		if (provider == null) throw new IllegalStateException("game provider not set (yet)");
+
+		return provider;
+	}
+
+	public GameProvider tryGetGameProvider() {
+		return provider;
+	}
+
+	public void setGameProvider(GameProvider provider) {
+		this.provider = provider;
+
+		setGameDir(provider.getLaunchDirectory());
+	}
+
+	private void setGameDir(Path gameDir) {
+		this.gameDir = gameDir;
+		this.configDir = gameDir.resolve("config");
+	}
+
+	@Override
+	public Object getGameInstance() {
+		return gameInstance;
+	}
+
+	@Override
+	public EnvType getEnvironmentType() {
+		return FabricLauncherBase.getLauncher().getEnvironmentType();
+	}
+
+	/**
+	 * @return The game instance's root directory.
+	 */
+	@Override
+	public Path getGameDir() {
+		if (gameDir == null) throw new IllegalStateException("invoked too early?");
+
+		return gameDir;
+	}
+
+	@Override
+	@Deprecated
+	public File getGameDirectory() {
+		return getGameDir().toFile();
+	}
+
+	/**
+	 * @return The game instance's configuration directory.
+	 */
+	@Override
+	public Path getConfigDir() {
+		if (!Files.exists(configDir)) {
+			try {
+				Files.createDirectories(configDir);
+			} catch (IOException e) {
+				throw new RuntimeException("Creating config directory", e);
+			}
+		}
+
+		return configDir;
+	}
+
+	@Override
+	@Deprecated
+	public File getConfigDirectory() {
+		return getConfigDir().toFile();
+	}
+
+	public void load() {
+		if (provider == null) throw new IllegalStateException("game provider not set");
+		if (frozen) throw new IllegalStateException("Frozen - cannot load additional mods!");
+
+		try {
+			setup();
+		} catch (ModResolutionException exception) {
+			if (exception.getCause() == null) {
+				throw new FormattedException("Incompatible mod set!", exception.getMessage());
+			} else {
+				throw new FormattedException("Incompatible mod set!", exception);
+			}
+		}
+	}
+
+	private void setup() throws ModResolutionException {
+		boolean remapRegularMods = isDevelopmentEnvironment();
+		VersionOverrides versionOverrides = new VersionOverrides();
+		DependencyOverrides depOverrides = new DependencyOverrides(configDir);
+
+		// discover mods
+
+		ModDiscoverer discoverer = new ModDiscoverer(versionOverrides, depOverrides);
+		discoverer.addCandidateFinder(new ClasspathModCandidateFinder());
+		discoverer.addCandidateFinder(new DirectoryModCandidateFinder(gameDir.resolve("mods"), remapRegularMods));
+		discoverer.addCandidateFinder(new ArgumentModCandidateFinder(remapRegularMods));
+
+		Map<String, Set<ModCandidate>> envDisabledMods = new HashMap<>();
+		modCandidates = discoverer.discoverMods(this, envDisabledMods);
+
+		// dump version and dependency overrides info
+
+		if (!versionOverrides.getAffectedModIds().isEmpty()) {
+			Log.info(LogCategory.GENERAL, "Versions overridden for %s", String.join(", ", versionOverrides.getAffectedModIds()));
+		}
+
+		if (!depOverrides.getAffectedModIds().isEmpty()) {
+			Log.info(LogCategory.GENERAL, "Dependencies overridden for %s", String.join(", ", depOverrides.getAffectedModIds()));
+		}
+
+		// resolve mods
+
+		modCandidates = ModResolver.resolve(modCandidates, getEnvironmentType(), envDisabledMods);
+
+		// dump mod list
+
+		StringBuilder modListText = new StringBuilder();
+
+		for (ModCandidate mod : modCandidates) {
+			if (modListText.length() > 0) modListText.append('\n');
+
+			modListText.append("\t- ");
+			modListText.append(mod.getId());
+			modListText.append(' ');
+			modListText.append(mod.getVersion().getFriendlyString());
+
+			if (!mod.getParentMods().isEmpty()) {
+				modListText.append(" via ");
+				modListText.append(mod.getParentMods().iterator().next().getId());
+			}
+		}
+
+		int count = modCandidates.size();
+		Log.info(LogCategory.GENERAL, "Loading %d mod%s:%n%s", count, count != 1 ? "s" : "", modListText);
+
+		Path cacheDir = gameDir.resolve(CACHE_DIR_NAME);
+		Path outputdir = cacheDir.resolve(PROCESSED_MODS_DIR_NAME);
+
+		// runtime mod remapping
+
+		if (remapRegularMods) {
+			if (System.getProperty(SystemProperties.REMAP_CLASSPATH_FILE) == null) {
+				Log.warn(LogCategory.MOD_REMAP, "Runtime mod remapping disabled due to no fabric.remapClasspathFile being specified. You may need to update loom.");
+			} else {
+				RuntimeModRemapper.remap(modCandidates, cacheDir.resolve(TMP_DIR_NAME), outputdir);
+			}
+		}
+
+		// shuffle mods in-dev to reduce the risk of false order reliance, apply late load requests
+
+		if (isDevelopmentEnvironment() && System.getProperty(SystemProperties.DEBUG_DISABLE_MOD_SHUFFLE) == null) {
+			Collections.shuffle(modCandidates);
+		}
+
+		String modsToLoadLate = System.getProperty(SystemProperties.DEBUG_LOAD_LATE);
+
+		if (modsToLoadLate != null) {
+			for (String modId : modsToLoadLate.split(",")) {
+				for (Iterator<ModCandidate> it = modCandidates.iterator(); it.hasNext(); ) {
+					ModCandidate mod = it.next();
+
+					if (mod.getId().equals(modId)) {
+						it.remove();
+						modCandidates.add(mod);
+						break;
+					}
+				}
+			}
+		}
+
+		// add mods
+
+		for (ModCandidate mod : modCandidates) {
+			if (!mod.hasPath() && !mod.isBuiltin()) {
+				try {
+					mod.setPaths(Collections.singletonList(mod.copyToDir(outputdir, false)));
+				} catch (IOException e) {
+					throw new RuntimeException("Error extracting mod "+mod, e);
+				}
+			}
+
+			addMod(mod);
+		}
+
+		modCandidates = null;
+	}
+
+	private void finishModLoading() {
+		// add mods to classpath
+		// TODO: This can probably be made safer, but that's a long-term goal
+		for (ModContainerImpl mod : mods) {
+			if (!mod.getMetadata().getId().equals(MOD_ID) && !mod.getMetadata().getType().equals("builtin")) {
+				for (Path path : mod.getCodeSourcePaths()) {
+					FabricLauncherBase.getLauncher().addToClassPath(path);
+				}
+			}
+		}
+
+		setupLanguageAdapters();
+		setupMods();
+	}
+
+	public boolean hasEntrypoints(String key) {
+		return entrypointStorage.hasEntrypoints(key);
+	}
+
+	@Override
+	public <T> List<T> getEntrypoints(String key, Class<T> type) {
+		return entrypointStorage.getEntrypoints(key, type);
+	}
+
+	@Override
+	public <T> List<EntrypointContainer<T>> getEntrypointContainers(String key, Class<T> type) {
+		return entrypointStorage.getEntrypointContainers(key, type);
+	}
+
+	@Override
+	public MappingResolver getMappingResolver() {
+		if (mappingResolver == null) {
+			mappingResolver = new MappingResolverImpl(
+					FabricLauncherBase.getLauncher().getMappingConfiguration()::getMappings,
+					FabricLauncherBase.getLauncher().getTargetNamespace()
+					);
+		}
+
+		return mappingResolver;
+	}
+
+	@Override
+	public ObjectShare getObjectShare() {
+		return objectShare;
+	}
+
+	public ModCandidate getModCandidate(String id) {
+		if (modCandidates == null) return null;
+
+		for (ModCandidate mod : modCandidates) {
+			if (mod.getId().equals(id)) return mod;
+		}
+
+		return null;
+	}
+
+	@Override
+	public Optional<net.fabricmc.loader.api.ModContainer> getModContainer(String id) {
+		return Optional.ofNullable(modMap.get(id));
+	}
+
+	@Override
+	public Collection<ModContainer> getAllMods() {
+		return Collections.unmodifiableList(mods);
+	}
+
+	public List<ModContainerImpl> getModsInternal() {
+		return mods;
+	}
+
+	@Override
+	public boolean isModLoaded(String id) {
+		return modMap.containsKey(id);
+	}
+
+	@Override
+	public boolean isDevelopmentEnvironment() {
+		return FabricLauncherBase.getLauncher().isDevelopment();
+	}
+
+	private void addMod(ModCandidate candidate) throws ModResolutionException {
+		ModContainerImpl container = new ModContainerImpl(candidate);
+		mods.add(container);
+		modMap.put(candidate.getId(), container);
+
+		for (String provides : candidate.getProvides()) {
+			modMap.put(provides, container);
+		}
+	}
+
+	private void setupLanguageAdapters() {
+		adapterMap.put("default", DefaultLanguageAdapter.INSTANCE);
+
+		for (ModContainerImpl mod : mods) {
+			// add language adapters
+			for (Map.Entry<String, String> laEntry : mod.getInfo().getLanguageAdapterDefinitions().entrySet()) {
+				if (adapterMap.containsKey(laEntry.getKey())) {
+					throw new RuntimeException("Duplicate language adapter key: " + laEntry.getKey() + "! (" + laEntry.getValue() + ", " + adapterMap.get(laEntry.getKey()).getClass().getName() + ")");
+				}
+
+				try {
+					adapterMap.put(laEntry.getKey(), (LanguageAdapter) Class.forName(laEntry.getValue(), true, FabricLauncherBase.getLauncher().getTargetClassLoader()).getDeclaredConstructor().newInstance());
+				} catch (Exception e) {
+					throw new RuntimeException("Failed to instantiate language adapter: " + laEntry.getKey(), e);
+				}
+			}
+		}
+	}
+
+	private void setupMods() {
+		for (ModContainerImpl mod : mods) {
+			try {
+				for (String in : mod.getInfo().getOldInitializers()) {
+					String adapter = mod.getInfo().getOldStyleLanguageAdapter();
+					entrypointStorage.addDeprecated(mod, adapter, in);
+				}
+
+				for (String key : mod.getInfo().getEntrypointKeys()) {
+					for (EntrypointMetadata in : mod.getInfo().getEntrypoints(key)) {
+						entrypointStorage.add(mod, key, in, adapterMap);
+					}
+				}
+			} catch (Exception e) {
+				throw new RuntimeException(String.format("Failed to setup mod %s (%s)", mod.getInfo().getName(), mod.getOrigin()), e);
+			}
+		}
+	}
+
+	public void loadAccessWideners() {
+		AccessWidenerReader accessWidenerReader = new AccessWidenerReader(accessWidener);
+
+		for (net.fabricmc.loader.api.ModContainer modContainer : getAllMods()) {
+			LoaderModMetadata modMetadata = (LoaderModMetadata) modContainer.getMetadata();
+			String accessWidener = modMetadata.getAccessWidener();
+			if (accessWidener == null) continue;
+
+			Path path = modContainer.findPath(accessWidener).orElse(null);
+			if (path == null) throw new RuntimeException(String.format("Missing accessWidener file %s from mod %s", accessWidener, modContainer.getMetadata().getId()));
+
+			try (BufferedReader reader = Files.newBufferedReader(path)) {
+				accessWidenerReader.read(reader, getMappingResolver().getCurrentRuntimeNamespace());
+			} catch (Exception e) {
+				throw new RuntimeException("Failed to read accessWidener file from mod " + modMetadata.getId(), e);
+			}
+		}
+	}
+
+	public void prepareModInit(Path newRunDir, Object gameInstance) {
+		if (!frozen) {
+			throw new RuntimeException("Cannot instantiate mods when not frozen!");
+		}
+
+		if (gameInstance != null && FabricLauncherBase.getLauncher() instanceof Knot) {
+			ClassLoader gameClassLoader = gameInstance.getClass().getClassLoader();
+			ClassLoader targetClassLoader = FabricLauncherBase.getLauncher().getTargetClassLoader();
+			boolean matchesKnot = (gameClassLoader == targetClassLoader);
+			boolean containsKnot = false;
+
+			if (matchesKnot) {
+				containsKnot = true;
+			} else {
+				gameClassLoader = gameClassLoader.getParent();
+
+				while (gameClassLoader != null && gameClassLoader.getParent() != gameClassLoader) {
+					if (gameClassLoader == targetClassLoader) {
+						containsKnot = true;
+					}
+
+					gameClassLoader = gameClassLoader.getParent();
+				}
+			}
+
+			if (!matchesKnot) {
+				if (containsKnot) {
+					Log.info(LogCategory.KNOT, "Environment: Target class loader is parent of game class loader.");
+				} else {
+					Log.warn(LogCategory.KNOT, "\n\n* CLASS LOADER MISMATCH! THIS IS VERY BAD AND WILL PROBABLY CAUSE WEIRD ISSUES! *\n"
+							+ " - Expected game class loader: %s\n"
+							+ " - Actual game class loader: %s\n"
+							+ "Could not find the expected class loader in game class loader parents!\n",
+							FabricLauncherBase.getLauncher().getTargetClassLoader(), gameClassLoader);
+				}
+			}
+		}
+
+		this.gameInstance = gameInstance;
+
+		if (gameDir != null) {
+			try {
+				if (!gameDir.toRealPath().equals(newRunDir.toRealPath())) {
+					Log.warn(LogCategory.GENERAL, "Inconsistent game execution directories: engine says %s, while initializer says %s...",
+							newRunDir.toRealPath(), gameDir.toRealPath());
+					setGameDir(newRunDir);
+				}
+			} catch (IOException e) {
+				Log.warn(LogCategory.GENERAL, "Exception while checking game execution directory consistency!", e);
+			}
+		} else {
+			setGameDir(newRunDir);
+		}
+	}
+
+	public AccessWidener getAccessWidener() {
+		return accessWidener;
+	}
+
+	/**
+	 * Sets the game instance. This is only used in 20w22a+ by the dedicated server and should not be called by anything else.
+	 */
+	public void setGameInstance(Object gameInstance) {
+		if (getEnvironmentType() != EnvType.SERVER) {
+			throw new UnsupportedOperationException("Cannot set game instance on a client!");
+		}
+
+		if (this.gameInstance != null) {
+			throw new UnsupportedOperationException("Cannot overwrite current game instance!");
+		}
+
+		this.gameInstance = gameInstance;
+	}
+
+	@Override
+	public String[] getLaunchArguments(boolean sanitize) {
+		return getGameProvider().getLaunchArguments(sanitize);
+	}
+
+	/**
+	 * Provides singleton for static init assignment regardless of load order.
+	 */
+	public static class InitHelper {
+		private static FabricLoaderImpl instance;
+
+		public static FabricLoaderImpl get() {
+			if (instance == null) instance = new FabricLoaderImpl();
+
+			return instance;
+		}
+	}
+
+	static {
+		LoaderUtil.verifyNotInTargetCl(FabricLoaderImpl.class);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/FormattedException.java b/src/main/java/net/fabricmc/loader/impl/FormattedException.java
new file mode 100644
index 0000000000000000000000000000000000000000..4912b9fd6600fccd804d41cce7bd4110d804b196
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/FormattedException.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl;
+
+@SuppressWarnings("serial")
+public final class FormattedException extends RuntimeException {
+	private final String mainText;
+
+	public FormattedException(String mainText, String message) {
+		super(message);
+
+		this.mainText = mainText;
+	}
+
+	public FormattedException(String mainText, String format, Object... args) {
+		super(String.format(format, args));
+
+		this.mainText = mainText;
+	}
+
+	public FormattedException(String mainText, String message, Throwable cause) {
+		super(message, cause);
+
+		this.mainText = mainText;
+	}
+
+	public FormattedException(String mainText, Throwable cause) {
+		super(cause);
+
+		this.mainText = mainText;
+	}
+
+	public String getMainText() {
+		return mainText;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/MappingResolverImpl.java b/src/main/java/net/fabricmc/loader/impl/MappingResolverImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..f0b5f57beb3dceef08a639e890fa8244ee559e11
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/MappingResolverImpl.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl;
+
+import net.fabricmc.loader.api.MappingResolver;
+import net.fabricmc.mapping.tree.ClassDef;
+import net.fabricmc.mapping.tree.Descriptored;
+import net.fabricmc.mapping.tree.TinyTree;
+import net.fabricmc.mappings.EntryTriple;
+
+import java.util.*;
+import java.util.function.Supplier;
+
+class MappingResolverImpl implements MappingResolver {
+	private final Supplier<TinyTree> mappingsSupplier;
+	private final Set<String> namespaces;
+	private final Map<String, NamespaceData> namespaceDataMap = new HashMap<>();
+	private final String targetNamespace;
+
+	private static class NamespaceData {
+		private final Map<String, String> classNames = new HashMap<>();
+		private final Map<String, String> classNamesInverse = new HashMap<>();
+		private final Map<EntryTriple, String> fieldNames = new HashMap<>();
+		private final Map<EntryTriple, String> methodNames = new HashMap<>();
+	}
+
+	MappingResolverImpl(Supplier<TinyTree> mappingsSupplier, String targetNamespace) {
+		this.mappingsSupplier = mappingsSupplier;
+		this.targetNamespace = targetNamespace;
+		namespaces = Collections.unmodifiableSet(new HashSet<>(mappingsSupplier.get().getMetadata().getNamespaces()));
+	}
+
+	protected final NamespaceData getNamespaceData(String namespace) {
+		return namespaceDataMap.computeIfAbsent(namespace, (fromNamespace) -> {
+			if (!namespaces.contains(namespace)) {
+				throw new IllegalArgumentException("Unknown namespace: " + namespace);
+			}
+
+			NamespaceData data = new NamespaceData();
+			TinyTree mappings = mappingsSupplier.get();
+			Map<String, String> classNameMap = new HashMap<>();
+
+			for (ClassDef classEntry : mappings.getClasses()) {
+				String fromClass = mapClassName(classNameMap, classEntry.getName(fromNamespace));
+				String toClass = mapClassName(classNameMap, classEntry.getName(targetNamespace));
+
+				data.classNames.put(fromClass, toClass);
+				data.classNamesInverse.put(toClass, fromClass);
+
+				String mappedClassName = mapClassName(classNameMap, fromClass);
+
+				recordMember(fromNamespace, classEntry.getFields(), data.fieldNames, mappedClassName);
+				recordMember(fromNamespace, classEntry.getMethods(), data.methodNames, mappedClassName);
+			}
+
+			return data;
+		});
+	}
+
+	private static String replaceSlashesWithDots(String cname) {
+		return cname.replace('/', '.');
+	}
+
+	private String mapClassName(Map<String, String> classNameMap, String s) {
+		return classNameMap.computeIfAbsent(s, MappingResolverImpl::replaceSlashesWithDots);
+	}
+
+	private <T extends Descriptored> void recordMember(String fromNamespace, Collection<T> descriptoredList, Map<EntryTriple, String> putInto, String fromClass) {
+		for (T descriptored : descriptoredList) {
+			EntryTriple fromEntry = new EntryTriple(fromClass, descriptored.getName(fromNamespace), descriptored.getDescriptor(fromNamespace));
+			putInto.put(fromEntry, descriptored.getName(targetNamespace));
+		}
+	}
+
+	@Override
+	public Collection<String> getNamespaces() {
+		return namespaces;
+	}
+
+	@Override
+	public String getCurrentRuntimeNamespace() {
+		return targetNamespace;
+	}
+
+	@Override
+	public String mapClassName(String namespace, String className) {
+		if (className.indexOf('/') >= 0) {
+			throw new IllegalArgumentException("Class names must be provided in dot format: " + className);
+		}
+
+		return getNamespaceData(namespace).classNames.getOrDefault(className, className);
+	}
+
+	@Override
+	public String unmapClassName(String namespace, String className) {
+		if (className.indexOf('/') >= 0) {
+			throw new IllegalArgumentException("Class names must be provided in dot format: " + className);
+		}
+
+		return getNamespaceData(namespace).classNamesInverse.getOrDefault(className, className);
+	}
+
+	@Override
+	public String mapFieldName(String namespace, String owner, String name, String descriptor) {
+		if (owner.indexOf('/') >= 0) {
+			throw new IllegalArgumentException("Class names must be provided in dot format: " + owner);
+		}
+
+		return getNamespaceData(namespace).fieldNames.getOrDefault(new EntryTriple(owner, name, descriptor), name);
+	}
+
+	@Override
+	public String mapMethodName(String namespace, String owner, String name, String descriptor) {
+		if (owner.indexOf('/') >= 0) {
+			throw new IllegalArgumentException("Class names must be provided in dot format: " + owner);
+		}
+
+		return getNamespaceData(namespace).methodNames.getOrDefault(new EntryTriple(owner, name, descriptor), name);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/ModContainerImpl.java b/src/main/java/net/fabricmc/loader/impl/ModContainerImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..79ade28ca2e0c01ea042f247822662df03a3ca28
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/ModContainerImpl.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl;
+
+import net.fabricmc.loader.api.ModContainer;
+import net.fabricmc.loader.api.metadata.ModOrigin;
+import net.fabricmc.loader.impl.discovery.ModCandidate;
+import net.fabricmc.loader.impl.metadata.LoaderModMetadata;
+import net.fabricmc.loader.impl.metadata.ModOriginImpl;
+import net.fabricmc.loader.impl.util.FileSystemUtil;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.FileSystem;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+
+@SuppressWarnings("deprecation")
+public class ModContainerImpl extends net.fabricmc.loader.ModContainer {
+	private final LoaderModMetadata info;
+	private final ModOrigin origin;
+	private final List<Path> codeSourcePaths;
+	private final String parentModId;
+	private final Collection<String> childModIds;
+
+	private volatile List<Path> roots;
+
+	public ModContainerImpl(ModCandidate candidate) {
+		this.info = candidate.getMetadata();
+		this.codeSourcePaths = candidate.getPaths();
+		this.parentModId = candidate.getParentMods().isEmpty() ? null : candidate.getParentMods().iterator().next().getId();
+		this.childModIds = candidate.getNestedMods().isEmpty() ? Collections.emptyList() : new ArrayList<>(candidate.getNestedMods().size());
+
+		for (ModCandidate c : candidate.getNestedMods()) {
+			if (c.getParentMods().size() <= 1 || c.getParentMods().iterator().next() == candidate) {
+				childModIds.add(c.getId());
+			}
+		}
+
+		List<Path> paths = candidate.getOriginPaths();
+		this.origin = paths != null ? new ModOriginImpl(paths) : new ModOriginImpl(parentModId, candidate.getLocalPath());
+	}
+
+	@Override
+	public LoaderModMetadata getMetadata() {
+		return info;
+	}
+
+	@Override
+	public ModOrigin getOrigin() {
+		return origin;
+	}
+
+	@Override
+	public List<Path> getCodeSourcePaths() {
+		return codeSourcePaths;
+	}
+
+	@Override
+	public Path getRootPath() {
+		List<Path> paths = getRootPaths();
+
+		if (paths.size() != 1 && !warnedMultiPath) {
+			if (!FabricLoaderImpl.INSTANCE.isDevelopmentEnvironment()) warnedMultiPath = true;
+			Log.warn(LogCategory.GENERAL, "getRootPath access for %s with multiple paths, returning only one which may incur unexpected behavior!", this);
+		}
+
+		return paths.get(0);
+	}
+
+	private static boolean warnedMultiPath = false;
+
+	@Override
+	public List<Path> getRootPaths() {
+		List<Path> ret = roots;
+
+		if (ret == null || !checkFsOpen(ret)) {
+			roots = ret = obtainRootPaths(); // obtainRootPaths is thread safe, but we need to avoid plain or repeated reads to root
+		}
+
+		return ret;
+	}
+
+	private boolean checkFsOpen(List<Path> paths) {
+		for (Path path : paths) {
+			if (path.getFileSystem().isOpen()) continue;
+
+			if (!warnedClose) {
+				if (!FabricLoaderImpl.INSTANCE.isDevelopmentEnvironment()) warnedClose = true;
+				Log.warn(LogCategory.GENERAL, "FileSystem for %s has been closed unexpectedly, existing root path references may break!", this);
+			}
+
+			return false;
+		}
+
+		return true;
+	}
+
+	private boolean warnedClose = false;
+
+	private List<Path> obtainRootPaths() {
+		boolean allDirs = true;
+
+		for (Path path : codeSourcePaths) {
+			if (!Files.isDirectory(path)) {
+				allDirs = false;
+				break;
+			}
+		}
+
+		if (allDirs) return codeSourcePaths;
+
+		try {
+			if (codeSourcePaths.size() == 1) {
+				return Collections.singletonList(obtainRootPath(codeSourcePaths.get(0)));
+			} else {
+				List<Path> ret = new ArrayList<>(codeSourcePaths.size());
+
+				for (Path path : codeSourcePaths) {
+					ret.add(obtainRootPath(path));
+				}
+
+				return Collections.unmodifiableList(ret);
+			}
+		} catch (IOException e) {
+			throw new RuntimeException("Failed to obtain root directory for mod '" + info.getId() + "'!", e);
+		}
+	}
+
+	private static Path obtainRootPath(Path path) throws IOException {
+		if (Files.isDirectory(path)) {
+			return path;
+		} else /* JAR */ {
+			FileSystemUtil.FileSystemDelegate delegate = FileSystemUtil.getJarFileSystem(path, false);
+			FileSystem fs = delegate.get();
+
+			if (fs == null) {
+				throw new RuntimeException("Could not open JAR file " + path + " for NIO reading!");
+			}
+
+			return fs.getRootDirectories().iterator().next();
+
+			// We never close here. It's fine. getJarFileSystem() will handle it gracefully, and so should mods
+		}
+	}
+
+	@Override
+	public Path getPath(String file) {
+		Optional<Path> res = findPath(file);
+		if (res.isPresent()) return res.get();
+
+		List<Path> roots = this.roots;
+
+		if (!roots.isEmpty()) {
+			Path root = roots.get(0);
+
+			return root.resolve(file.replace("/", root.getFileSystem().getSeparator()));
+		} else {
+			return Paths.get(".").resolve("missing_ae236f4970ce").resolve(file.replace('/', File.separatorChar)); // missing dummy path
+		}
+	}
+
+	@Override
+	public Optional<ModContainer> getContainingMod() {
+		return parentModId != null ? FabricLoaderImpl.INSTANCE.getModContainer(parentModId) : Optional.empty();
+	}
+
+	@Override
+	public Collection<ModContainer> getContainedMods() {
+		if (childModIds.isEmpty()) return Collections.emptyList();
+
+		List<ModContainer> ret = new ArrayList<>(childModIds.size());
+
+		for (String id : childModIds) {
+			ModContainer mod = FabricLoaderImpl.INSTANCE.getModContainer(id).orElse(null);
+			if (mod != null) ret.add(mod);
+		}
+
+		return ret;
+	}
+
+	@Deprecated
+	@Override
+	public LoaderModMetadata getInfo() {
+		return info;
+	}
+
+	@Override
+	public String toString() {
+		return String.format("%s %s", info.getId(), info.getVersion());
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/ObjectShareImpl.java b/src/main/java/net/fabricmc/loader/impl/ObjectShareImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..1cde71b1c8545d4916f1d5206a4c825558b9ba5a
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/ObjectShareImpl.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl;
+
+import net.fabricmc.loader.api.ObjectShare;
+
+import java.util.*;
+import java.util.function.BiConsumer;
+
+final class ObjectShareImpl implements ObjectShare {
+	private final Map<String, Object> values = new HashMap<>();
+	private final Map<String, List<BiConsumer<String, Object>>> pendingMap = new HashMap<>();
+
+	@Override
+	public synchronized Object get(String key) {
+		validateKey(key);
+
+		return values.get(key);
+	}
+
+	@Override
+	public Object put(String key, Object value) {
+		validateKey(key);
+		Objects.requireNonNull(value, "null value");
+
+		List<BiConsumer<String, Object>> pending;
+
+		synchronized (this) {
+			Object prev = values.put(key, value);
+			if (prev != null) return prev; // no new entry -> can't have pending entries for it
+
+			pending = pendingMap.remove(key);
+		}
+
+		if (pending != null) invokePending(key, value, pending);
+
+		return null;
+	}
+
+	@Override
+	public Object putIfAbsent(String key, Object value) {
+		validateKey(key);
+		Objects.requireNonNull(value, "null value");
+
+		List<BiConsumer<String, Object>> pending;
+
+		synchronized (this) {
+			Object prev = values.putIfAbsent(key, value);
+			if (prev != null) return prev; // no new entry -> can't have pending entries for it
+
+			pending = pendingMap.remove(key);
+		}
+
+		if (pending != null) invokePending(key, value, pending);
+
+		return null;
+	}
+
+	@Override
+	public synchronized Object remove(String key) {
+		validateKey(key);
+
+		return values.remove(key);
+	}
+
+	@Override
+	public void whenAvailable(String key, BiConsumer<String, Object> consumer) {
+		validateKey(key);
+
+		Object value;
+
+		synchronized (this) {
+			value = values.get(key);
+
+			if (value == null) { // value doesn't exist yet, queue invocation for when it gets added
+				pendingMap.computeIfAbsent(key, ignore -> new ArrayList<>()).add(consumer);
+				return;
+			}
+		}
+
+		// value exists already, invoke directly
+		consumer.accept(key, value);
+	}
+
+	private static void validateKey(String key) {
+		Objects.requireNonNull(key, "null key");
+
+		int pos = key.indexOf(':');
+		if (pos <= 0 || pos >= key.length() - 1) throw new IllegalArgumentException("invalid key, must be modid:subkey");
+	}
+
+	private static void invokePending(String key, Object value, List<BiConsumer<String, Object>> pending) {
+		for (BiConsumer<String, Object> consumer : pending) {
+			consumer.accept(key, value);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/ArgumentModCandidateFinder.java b/src/main/java/net/fabricmc/loader/impl/discovery/ArgumentModCandidateFinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..196496e9254faf91af148b35ff9329a55ba4dbbd
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/ArgumentModCandidateFinder.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.util.Arguments;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.*;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.ArrayList;
+import java.util.List;
+
+public class ArgumentModCandidateFinder implements ModCandidateFinder {
+	private final boolean requiresRemap;
+
+	public ArgumentModCandidateFinder(boolean requiresRemap) {
+		this.requiresRemap = requiresRemap;
+	}
+
+	@Override
+	public void findCandidates(ModCandidateConsumer out) {
+		String list = System.getProperty(SystemProperties.ADD_MODS);
+		if (list != null) addMods(list, "system property", out);
+
+		list = FabricLoaderImpl.INSTANCE.getGameProvider().getArguments().remove(Arguments.ADD_MODS);
+		if (list != null) addMods(list, "argument", out);
+	}
+
+	private void addMods(String list, String source, ModCandidateConsumer out) {
+		for (String pathStr : list.split(File.pathSeparator)) {
+			if (pathStr.isEmpty()) continue;
+
+			if (pathStr.startsWith("@")) {
+				Path path = Paths.get(pathStr.substring(1));
+
+				if (!Files.isRegularFile(path)) {
+					Log.warn(LogCategory.DISCOVERY, "Skipping missing/invalid %s provided mod list file %s", source, path);
+					continue;
+				}
+
+				try (BufferedReader reader = Files.newBufferedReader(path)) {
+					String fileSource = String.format("%s file %s", source, path);
+					String line;
+
+					while ((line = reader.readLine()) != null) {
+						line = line.trim();
+						if (line.isEmpty()) continue;
+
+						addMod(line, fileSource, out);
+					}
+				} catch (IOException e) {
+					throw new RuntimeException(String.format("Error reading %s provided mod list file %s", source, path), e);
+				}
+			} else {
+				addMod(pathStr, source, out);
+			}
+		}
+	}
+
+	private void addMod(String pathStr, String source, ModCandidateConsumer out) {
+		Path path = LoaderUtil.normalizePath(Paths.get(pathStr));
+
+		if (!Files.exists(path)) { // missing
+			Log.warn(LogCategory.DISCOVERY, "Skipping missing %s provided mod path %s", source, path);
+		} else if (Files.isDirectory(path)) { // directory for extracted mod (in-dev usually) or jars (like mods, but recursive)
+			if (isHidden(path)) {
+				Log.warn(LogCategory.DISCOVERY, "Ignoring hidden %s provided mod path %s", source, path);
+				return;
+			}
+
+			if (Files.exists(path.resolve("fabric.mod.json"))) { // extracted mod
+				out.accept(path, requiresRemap);
+			} else { // dir containing jars
+				try {
+					List<String> skipped = new ArrayList<>();
+
+					Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
+						@Override
+						public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
+							if (DirectoryModCandidateFinder.isValidFile(file)) {
+								out.accept(file, requiresRemap);
+							} else {
+								skipped.add(path.relativize(file).toString());
+							}
+
+							return FileVisitResult.CONTINUE;
+						}
+
+						@Override
+						public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
+							if (isHidden(dir)) {
+								return FileVisitResult.SKIP_SUBTREE;
+							} else {
+								return FileVisitResult.CONTINUE;
+							}
+						}
+					});
+
+					if (!skipped.isEmpty()) {
+						Log.warn(LogCategory.DISCOVERY, "Incompatible files in %s provided mod directory %s (non-jar or hidden): %s", source, path, String.join(", ", skipped));
+					}
+				} catch (IOException e) {
+					Log.warn(LogCategory.DISCOVERY, "Error processing %s provided mod path %s: %s", source, path, e);
+				}
+			}
+		} else { // single file
+			if (!DirectoryModCandidateFinder.isValidFile(path)) {
+				Log.warn(LogCategory.DISCOVERY, "Incompatible file in %s provided mod path %s (non-jar or hidden)", source, path);
+			} else {
+				out.accept(path, requiresRemap);
+			}
+		}
+	}
+
+	private static boolean isHidden(Path path) {
+		try {
+			return path.getFileName().toString().startsWith(".") || Files.isHidden(path);
+		} catch (IOException e) {
+			Log.warn(LogCategory.DISCOVERY, "Error determining whether %s is hidden: %s", path, e);
+			return true;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/BuiltinMetadataWrapper.java b/src/main/java/net/fabricmc/loader/impl/discovery/BuiltinMetadataWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..d41e8a96d50353209b78bc9991fb3c9ffba87757
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/BuiltinMetadataWrapper.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.metadata.*;
+import net.fabricmc.loader.impl.metadata.AbstractModMetadata;
+import net.fabricmc.loader.impl.metadata.EntrypointMetadata;
+import net.fabricmc.loader.impl.metadata.LoaderModMetadata;
+import net.fabricmc.loader.impl.metadata.NestedJarEntry;
+
+import java.util.*;
+
+class BuiltinMetadataWrapper extends AbstractModMetadata implements LoaderModMetadata {
+	private final ModMetadata parent;
+	private Version version;
+	private Collection<ModDependency> dependencies;
+
+	BuiltinMetadataWrapper(ModMetadata parent) {
+		this.parent = parent;
+
+		version = parent.getVersion();
+		dependencies = parent.getDependencies();
+	}
+
+	@Override
+	public String getType() {
+		return parent.getType();
+	}
+
+	@Override
+	public String getId() {
+		return parent.getId();
+	}
+
+	@Override
+	public Collection<String> getProvides() {
+		return parent.getProvides();
+	}
+
+	@Override
+	public Version getVersion() {
+		return version;
+	}
+
+	@Override
+	public void setVersion(Version version) {
+		this.version = version;
+	}
+
+	@Override
+	public ModEnvironment getEnvironment() {
+		return parent.getEnvironment();
+	}
+
+	@Override
+	public Collection<ModDependency> getDependencies() {
+		return dependencies;
+	}
+
+	@Override
+	public void setDependencies(Collection<ModDependency> dependencies) {
+		this.dependencies = Collections.unmodifiableCollection(dependencies);
+	}
+
+	@Override
+	public String getName() {
+		return parent.getName();
+	}
+
+	@Override
+	public String getDescription() {
+		return parent.getDescription();
+	}
+
+	@Override
+	public Collection<Person> getAuthors() {
+		return parent.getAuthors();
+	}
+
+	@Override
+	public Collection<Person> getContributors() {
+		return parent.getContributors();
+	}
+
+	@Override
+	public ContactInformation getContact() {
+		return parent.getContact();
+	}
+
+	@Override
+	public Collection<String> getLicense() {
+		return parent.getLicense();
+	}
+
+	@Override
+	public Optional<String> getIconPath(int size) {
+		return parent.getIconPath(size);
+	}
+
+	@Override
+	public boolean containsCustomValue(String key) {
+		return parent.containsCustomValue(key);
+	}
+
+	@Override
+	public CustomValue getCustomValue(String key) {
+		return parent.getCustomValue(key);
+	}
+
+	@Override
+	public Map<String, CustomValue> getCustomValues() {
+		return parent.getCustomValues();
+	}
+
+	@Override
+	public int getSchemaVersion() {
+		return Integer.MAX_VALUE;
+	}
+
+	@Override
+	public Map<String, String> getLanguageAdapterDefinitions() {
+		return Collections.emptyMap();
+	}
+
+	@Override
+	public Collection<NestedJarEntry> getJars() {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public Collection<String> getMixinConfigs(EnvType type) {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public String getAccessWidener() {
+		return null;
+	}
+
+	@Override
+	public boolean loadsInEnvironment(EnvType type) {
+		return true;
+	}
+
+	@Override
+	public Collection<String> getOldInitializers() {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public List<EntrypointMetadata> getEntrypoints(String type) {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public Collection<String> getEntrypointKeys() {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public void emitFormatWarnings() { }
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/ClasspathModCandidateFinder.java b/src/main/java/net/fabricmc/loader/impl/discovery/ClasspathModCandidateFinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e06d84e0688a5ea0641794f321cbbd4fa02fec4
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/ClasspathModCandidateFinder.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.UrlConversionException;
+import net.fabricmc.loader.impl.util.UrlUtil;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+
+public class ClasspathModCandidateFinder implements ModCandidateFinder {
+	@Override
+	public void findCandidates(ModCandidateConsumer out) {
+		if (FabricLauncherBase.getLauncher().isDevelopment()) {
+			Map<Path, List<Path>> pathGroups = getPathGroups();
+
+			// Search for URLs which point to 'fabric.mod.json' entries, to be considered as mods.
+			try {
+				Enumeration<URL> mods = FabricLauncherBase.getLauncher().getTargetClassLoader().getResources("fabric.mod.json");
+
+				while (mods.hasMoreElements()) {
+					URL url = mods.nextElement();
+
+					try {
+						Path path = LoaderUtil.normalizeExistingPath(UrlUtil.getCodeSource(url, "fabric.mod.json"));
+						List<Path> paths = pathGroups.get(path);
+
+						if (paths == null) {
+							out.accept(path, false);
+						} else {
+							out.accept(paths, false);
+						}
+					} catch (UrlConversionException e) {
+						Log.debug(LogCategory.DISCOVERY, "Error determining location for fabric.mod.json from %s", url, e);
+					}
+				}
+			} catch (IOException e) {
+				throw new RuntimeException(e);
+			}
+		} else { // production, add loader as a mod
+			try {
+				out.accept(UrlUtil.LOADER_CODE_SOURCE, false);
+			} catch (Throwable t) {
+				Log.debug(LogCategory.DISCOVERY, "Could not retrieve launcher code source!", t);
+			}
+		}
+	}
+
+	/**
+	 * Parse fabric.classPathGroups system property into a path group lookup map.
+	 *
+	 * <p>This transforms {@code a:b::c:d:e} into {@code a=[a,b],b=[a,b],c=[c,d,e],d=[c,d,e],e=[c,d,e]}
+	 */
+	private static Map<Path, List<Path>> getPathGroups() {
+		String prop = System.getProperty(SystemProperties.PATH_GROUPS);
+		if (prop == null) return Collections.emptyMap();
+
+		Set<Path> cp = new HashSet<>(FabricLauncherBase.getLauncher().getClassPath());
+		Map<Path, List<Path>> ret = new HashMap<>();
+
+		for (String group : prop.split(File.pathSeparator+File.pathSeparator)) {
+			Set<Path> paths = new LinkedHashSet<>();
+
+			for (String path : group.split(File.pathSeparator)) {
+				if (path.isEmpty()) continue;
+
+				Path resolvedPath = Paths.get(path);
+
+				if (!Files.exists(resolvedPath)) {
+					Log.debug(LogCategory.DISCOVERY, "Skipping missing class path group entry %s", path);
+					continue;
+				}
+
+				resolvedPath = LoaderUtil.normalizeExistingPath(resolvedPath);
+
+				if (cp.contains(resolvedPath)) {
+					paths.add(resolvedPath);
+				}
+			}
+
+			if (paths.size() < 2) {
+				Log.debug(LogCategory.DISCOVERY, "Skipping class path group with no effect: %s", group);
+				continue;
+			}
+
+			List<Path> pathList = new ArrayList<>(paths);
+
+			for (Path path : pathList) {
+				ret.put(path, pathList);
+			}
+		}
+
+		return ret;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/DirectoryModCandidateFinder.java b/src/main/java/net/fabricmc/loader/impl/discovery/DirectoryModCandidateFinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f0dfde82d8bc90482ddc20eedc475729dbcf65d
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/DirectoryModCandidateFinder.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.io.IOException;
+import java.nio.file.*;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.EnumSet;
+
+public class DirectoryModCandidateFinder implements ModCandidateFinder {
+	private final Path path;
+	private final boolean requiresRemap;
+
+	public DirectoryModCandidateFinder(Path path, boolean requiresRemap) {
+		this.path = path;
+		this.requiresRemap = requiresRemap;
+	}
+
+	@Override
+	public void findCandidates(ModCandidateConsumer out) {
+		if (!Files.exists(path)) {
+			try {
+				Files.createDirectory(path);
+			} catch (IOException e) {
+				throw new RuntimeException("Could not create directory " + path, e);
+			}
+		}
+
+		if (!Files.isDirectory(path)) {
+			throw new RuntimeException(path + " is not a directory!");
+		}
+
+		try {
+			Files.walkFileTree(this.path, EnumSet.of(FileVisitOption.FOLLOW_LINKS), 1, new SimpleFileVisitor<Path>() {
+				@Override
+				public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
+					if (isValidFile(file)) {
+						out.accept(file, requiresRemap);
+					}
+
+					return FileVisitResult.CONTINUE;
+				}
+			});
+		} catch (IOException e) {
+			throw new RuntimeException("Exception while searching for mods in '" + path + "'!", e);
+		}
+	}
+
+	static boolean isValidFile(Path path) {
+		/*
+		 * We only propose a file as a possible mod in the following scenarios:
+		 * General: Must be a jar file
+		 *
+		 * Some OSes Generate metadata so consider the following because of OSes:
+		 * UNIX: Exclude if file is hidden; this occurs when starting a file name with `.`
+		 * MacOS: Exclude hidden + startsWith "." since Mac OS names their metadata files in the form of `.mod.jar`
+		 */
+
+		if (!Files.isRegularFile(path)) return false;
+
+		try {
+			if (Files.isHidden(path)) return false;
+		} catch (IOException e) {
+			Log.warn(LogCategory.DISCOVERY, "Error checking if file %s is hidden", path, e);
+			return false;
+		}
+
+		String fileName = path.getFileName().toString();
+
+		return fileName.endsWith(".jar") && !fileName.startsWith(".");
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/DomainObject.java b/src/main/java/net/fabricmc/loader/impl/discovery/DomainObject.java
new file mode 100644
index 0000000000000000000000000000000000000000..f795e50ae01cc4489e1691cf2992d9e3150c91ee
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/DomainObject.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.loader.api.Version;
+
+interface DomainObject {
+	String getId();
+
+	interface Mod extends DomainObject {
+		Version getVersion();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/Explanation.java b/src/main/java/net/fabricmc/loader/impl/discovery/Explanation.java
new file mode 100644
index 0000000000000000000000000000000000000000..43470b47f50cf911eb1c4218938319c4ca4ae4e4
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/Explanation.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.loader.api.metadata.ModDependency;
+
+class Explanation implements Comparable<Explanation> {
+	private static int nextCmpId;
+
+	final ErrorKind error;
+	final ModCandidate mod;
+	final ModDependency dep;
+	final String data;
+	private final int cmpId;
+
+	Explanation(ErrorKind error, ModCandidate mod) {
+		this(error, mod, null, null);
+	}
+
+	Explanation(ErrorKind error, ModCandidate mod, ModDependency dep) {
+		this(error, mod, dep, null);
+	}
+
+	Explanation(ErrorKind error, String data) {
+		this(error, null, data);
+	}
+
+	Explanation(ErrorKind error, ModCandidate mod, String data) {
+		this(error, mod, null, data);
+	}
+
+	private Explanation(ErrorKind error, ModCandidate mod, ModDependency dep, String data) {
+		this.error = error;
+		this.mod = mod;
+		this.dep = dep;
+		this.data = data;
+		this.cmpId = nextCmpId++;
+	}
+
+	@Override
+	public int compareTo(Explanation o) {
+		return Integer.compare(cmpId, o.cmpId);
+	}
+
+	@Override
+	public String toString() {
+		if (mod == null) {
+			return String.format("%s %s", error, data);
+		} else if (dep == null) {
+			return String.format("%s %s", error, mod);
+		} else {
+			return String.format("%s %s %s", error, mod, dep);
+		}
+	}
+
+	enum ErrorKind {
+		/**
+		 * Positive hard dependency (depends) from a preselected mod.
+		 */
+		PRESELECT_HARD_DEP(true),
+		/**
+		 * Positive soft dependency (recommends) from a preselected mod.
+		 */
+		PRESELECT_SOFT_DEP(true),
+		/**
+		 * Negative hard dependency (breaks) from a preselected mod.
+		 */
+		PRESELECT_NEG_HARD_DEP(true),
+		/**
+		 * Force loaded due to being preselected.
+		 */
+		PRESELECT_FORCELOAD(false),
+		/**
+		 * Positive hard dependency (depends) from a mod with incompatible preselected candidate.
+		 */
+		HARD_DEP_INCOMPATIBLE_PRESELECTED(true),
+		/**
+		 * Positive hard dependency (depends) from a mod with no matching candidate.
+		 */
+		HARD_DEP_NO_CANDIDATE(true),
+		/**
+		 * Positive hard dependency (depends) from a mod.
+		 */
+		HARD_DEP(true),
+		/**
+		 * Positive soft dependency (recommends) from a mod.
+		 */
+		SOFT_DEP(true),
+		/**
+		 * Negative hard dependency (breaks) from a mod.
+		 */
+		NEG_HARD_DEP(true),
+		/**
+		 * Force loaded if the parent is loaded due to LoadType ALWAYS.
+		 */
+		NESTED_FORCELOAD(false),
+		/**
+		 * Dependency of a nested mod on its parent mods.
+		 */
+		NESTED_REQ_PARENT(false),
+		/**
+		 * Force loaded due to LoadType ALWAYS as a singular root mod.
+		 */
+		ROOT_FORCELOAD_SINGLE(false),
+		/**
+		 * Force loaded due to LoadType ALWAYS and containing root mods.
+		 */
+		ROOT_FORCELOAD(false),
+		/**
+		 * Requirement to load at most one mod per id (including provides).
+		 */
+		UNIQUE_ID(false);
+
+		final boolean isDependencyError;
+
+		ErrorKind(boolean isDependencyError) {
+			this.isDependencyError = isDependencyError;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/ModCandidate.java b/src/main/java/net/fabricmc/loader/impl/discovery/ModCandidate.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c787e1925123b7ef2f1004294433ea9bc6f7b05
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/ModCandidate.java
@@ -0,0 +1,393 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.metadata.ModDependency;
+import net.fabricmc.loader.impl.game.GameProvider.BuiltinMod;
+import net.fabricmc.loader.impl.metadata.AbstractModMetadata;
+import net.fabricmc.loader.impl.metadata.DependencyOverrides;
+import net.fabricmc.loader.impl.metadata.LoaderModMetadata;
+import net.fabricmc.loader.impl.metadata.VersionOverrides;
+
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.lang.ref.SoftReference;
+import java.nio.ByteBuffer;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
+import java.util.*;
+import java.util.regex.Pattern;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipInputStream;
+
+public final class ModCandidate implements DomainObject.Mod {
+	static final Comparator<ModCandidate> ID_VERSION_COMPARATOR = new Comparator<ModCandidate>() {
+		@Override
+		public int compare(ModCandidate a, ModCandidate b) {
+			int cmp = a.getId().compareTo(b.getId());
+
+			return cmp != 0 ? cmp : a.getVersion().compareTo(b.getVersion());
+		}
+	};
+
+	private final List<Path> originPaths;
+	private List<Path> paths;
+	private final String localPath;
+	private final long hash;
+	private final LoaderModMetadata metadata;
+	private final boolean requiresRemap;
+	private final Collection<ModCandidate> nestedMods;
+	private final Collection<ModCandidate> parentMods;
+	private int minNestLevel;
+	private SoftReference<ByteBuffer> dataRef;
+
+	static ModCandidate createBuiltin(BuiltinMod mod, VersionOverrides versionOverrides, DependencyOverrides depOverrides) {
+		LoaderModMetadata metadata = new BuiltinMetadataWrapper(mod.metadata);
+		versionOverrides.apply(metadata);
+		depOverrides.apply(metadata);
+
+		return new ModCandidate(mod.paths, null, -1, metadata, false, Collections.emptyList());
+	}
+
+	static ModCandidate createPlain(List<Path> paths, LoaderModMetadata metadata, boolean requiresRemap, Collection<ModCandidate> nestedMods) {
+		return new ModCandidate(paths, null, -1, metadata, requiresRemap, nestedMods);
+	}
+
+	static ModCandidate createNested(String localPath, long hash, LoaderModMetadata metadata, boolean requiresRemap, Collection<ModCandidate> nestedMods) {
+		return new ModCandidate(null, localPath, hash, metadata, requiresRemap, nestedMods);
+	}
+
+	static long hash(ZipEntry entry) {
+		if (entry.getSize() < 0 || entry.getCrc() < 0) throw new IllegalArgumentException("uninitialized entry: "+entry);
+
+		return entry.getCrc() << 32 | entry.getSize();
+	}
+
+	private static long getSize(long hash) {
+		return hash & 0xffffffffL;
+	}
+
+	private ModCandidate(List<Path> paths, String localPath, long hash, LoaderModMetadata metadata, boolean requiresRemap, Collection<ModCandidate> nestedMods) {
+		this.originPaths = paths;
+		this.paths = paths;
+		this.localPath = localPath;
+		this.metadata = metadata;
+		this.hash = hash;
+		this.requiresRemap = requiresRemap;
+		this.nestedMods = nestedMods;
+		this.parentMods = paths == null ? new ArrayList<>() : Collections.emptyList();
+		this.minNestLevel = paths != null ? 0 : Integer.MAX_VALUE;
+	}
+
+	public List<Path> getOriginPaths() {
+		return originPaths;
+	}
+
+	public boolean hasPath() {
+		return paths != null;
+	}
+
+	public List<Path> getPaths() {
+		if (paths == null) throw new IllegalStateException("no path set");
+
+		return paths;
+	}
+
+	public void setPaths(List<Path> paths) {
+		if (paths == null) throw new NullPointerException("null paths");
+
+		this.paths = paths;
+		clearCachedData();
+	}
+
+	public String getLocalPath() {
+		if (localPath != null) {
+			return localPath;
+		} else if (paths.size() == 1) {
+			return paths.get(0).toString();
+		} else {
+			return paths.toString();
+		}
+	}
+
+	public LoaderModMetadata getMetadata() {
+		return metadata;
+	}
+
+	@Override
+	public String getId() {
+		return metadata.getId();
+	}
+
+	@Override
+	public Version getVersion() {
+		return metadata.getVersion();
+	}
+
+	public Collection<String> getProvides() {
+		return metadata.getProvides();
+	}
+
+	public boolean isBuiltin() {
+		return metadata.getType().equals(AbstractModMetadata.TYPE_BUILTIN);
+	}
+
+	public ModLoadCondition getLoadCondition() {
+		return minNestLevel == 0 ? ModLoadCondition.ALWAYS : ModLoadCondition.IF_POSSIBLE;
+	}
+
+	public Collection<ModDependency> getDependencies() {
+		return metadata.getDependencies();
+	}
+
+	public boolean getRequiresRemap() {
+		return requiresRemap;
+	}
+
+	public Collection<ModCandidate> getNestedMods() {
+		return nestedMods;
+	}
+
+	public Collection<ModCandidate> getParentMods() {
+		return parentMods;
+	}
+
+	boolean addParent(ModCandidate parent) {
+		if (minNestLevel == 0) return false;
+		if (parentMods.contains(parent)) return false;
+
+		parentMods.add(parent);
+		updateMinNestLevel(parent);
+
+		return true;
+	}
+
+	public int getMinNestLevel() {
+		return minNestLevel;
+	}
+
+	boolean resetMinNestLevel() {
+		if (minNestLevel > 0) {
+			minNestLevel = Integer.MAX_VALUE;
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	boolean updateMinNestLevel(ModCandidate parent) {
+		if (minNestLevel <= parent.minNestLevel) return false;
+
+		this.minNestLevel = parent.minNestLevel + 1;
+
+		return true;
+	}
+
+	public boolean isRoot() {
+		return minNestLevel == 0;
+	}
+
+	void setData(ByteBuffer data) {
+		this.dataRef = new SoftReference<>(data);
+	}
+
+	void clearCachedData() {
+		this.dataRef = null;
+	}
+
+	public Path copyToDir(Path outputDir, boolean temp) throws IOException {
+		Files.createDirectories(outputDir);
+		Path ret = null;
+
+		try {
+			if (temp) {
+				ret = Files.createTempFile(outputDir, getId(), ".jar");
+			} else {
+				ret = outputDir.resolve(getDefaultFileName());
+
+				if (Files.exists(ret)) {
+					if (Files.size(ret) == getSize(hash)) {
+						return ret;
+					} else {
+						Files.deleteIfExists(ret);
+					}
+				}
+			}
+
+			copyToFile(ret);
+		} catch (Throwable t) {
+			if (ret != null) Files.deleteIfExists(ret);
+
+			throw t;
+		}
+
+		return ret;
+	}
+
+	String getDefaultFileName() {
+		String ret = String.format("%s-%s-%s.jar",
+				getId(),
+				FILE_NAME_SANITIZING_PATTERN.matcher(getVersion().getFriendlyString()).replaceAll("_"),
+				Long.toHexString(mixHash(hash)));
+
+		if (ret.length() > 64) {
+			ret = ret.substring(0, 32).concat(ret.substring(ret.length() - 32));
+		}
+
+		return ret;
+	}
+
+	private static long mixHash(long hash) {
+		hash ^= (hash >>> 33);
+		hash *= 0xff51afd7ed558ccdL;
+		hash ^= (hash >>> 33);
+		hash *= 0xc4ceb9fe1a85ec53L;
+		hash ^= (hash >>> 33);
+
+		return hash;
+	}
+
+	private static final Pattern FILE_NAME_SANITIZING_PATTERN = Pattern.compile("[^\\w\\.\\-\\+]+");
+
+	private void copyToFile(Path out) throws IOException {
+		SoftReference<ByteBuffer> dataRef = this.dataRef;
+
+		if (dataRef != null) {
+			ByteBuffer data = dataRef.get();
+
+			if (data != null) {
+				Files.copy(new ByteArrayInputStream(data.array(), data.arrayOffset() + data.position(), data.arrayOffset() + data.limit()), out, StandardCopyOption.REPLACE_EXISTING);
+				return;
+			}
+		}
+
+		if (paths != null) {
+			if (paths.size() != 1) throw new UnsupportedOperationException("multiple paths for "+this);
+
+			Files.copy(paths.get(0), out);
+
+			return;
+		}
+
+		ModCandidate parent = getBestSourcingParent();
+
+		if (parent.paths != null) {
+			if (parent.paths.size() != 1) throw new UnsupportedOperationException("multiple parent paths for "+this);
+
+			try (ZipFile zf = new ZipFile(parent.paths.get(0).toFile())) {
+				ZipEntry entry = zf.getEntry(localPath);
+				if (entry == null) throw new IOException(String.format("can't find nested mod %s in its parent mod %s", this, parent));
+
+				Files.copy(zf.getInputStream(entry), out);
+			}
+		} else {
+			ByteBuffer data = parent.getData();
+
+			try (ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(data.array(), data.arrayOffset() + data.position(), data.arrayOffset() + data.limit()))) {
+				ZipEntry entry = null;
+
+				while ((entry = zis.getNextEntry()) != null) {
+					if (entry.getName().equals(localPath)) {
+						Files.copy(zis, out);
+						return;
+					}
+				}
+			}
+
+			throw new IOException(String.format("can't find nested mod %s in its parent mod %s", this, parent));
+		}
+	}
+
+	private ByteBuffer getData() throws IOException {
+		SoftReference<ByteBuffer> dataRef = this.dataRef;
+
+		if (dataRef != null) {
+			ByteBuffer ret = dataRef.get();
+			if (ret != null) return ret;
+		}
+
+		ByteBuffer ret;
+
+		if (paths != null) {
+			if (paths.size() != 1) throw new UnsupportedOperationException("multiple paths for "+this);
+
+			ret = ByteBuffer.wrap(Files.readAllBytes(paths.get(0)));
+		} else {
+			ModCandidate parent = getBestSourcingParent();
+
+			if (parent.paths != null) {
+				if (parent.paths.size() != 1) throw new UnsupportedOperationException("multiple parent paths for "+this);
+
+				try (ZipFile zf = new ZipFile(parent.paths.get(0).toFile())) {
+					ZipEntry entry = zf.getEntry(localPath);
+					if (entry == null) throw new IOException(String.format("can't find nested mod %s in its parent mod %s", this, parent));
+
+					ret = ModDiscoverer.readMod(zf.getInputStream(entry));
+				}
+			} else {
+				ByteBuffer data = parent.getData();
+				ret = null;
+
+				try (ZipInputStream zis = new ZipInputStream(new ByteArrayInputStream(data.array(), data.arrayOffset() + data.position(), data.arrayOffset() + data.limit()))) {
+					ZipEntry entry = null;
+
+					while ((entry = zis.getNextEntry()) != null) {
+						if (entry.getName().equals(localPath)) {
+							ret = ModDiscoverer.readMod(zis);
+							break;
+						}
+					}
+				}
+
+				if (ret == null) throw new IOException(String.format("can't find nested mod %s in its parent mods %s", this, parent));
+			}
+		}
+
+		this.dataRef = new SoftReference<>(ret);
+
+		return ret;
+	}
+
+	private ModCandidate getBestSourcingParent() {
+		if (parentMods.isEmpty()) return null;
+
+		ModCandidate ret = null;
+
+		for (ModCandidate parent : parentMods) {
+			if (parent.minNestLevel >= minNestLevel) continue;
+
+			if (parent.paths != null && parent.paths.size() == 1
+					|| parent.dataRef != null && parent.dataRef.get() != null) {
+				return parent;
+			}
+
+			if (ret == null) ret = parent;
+		}
+
+		if (ret == null) throw new IllegalStateException("invalid nesting?");
+
+		return ret;
+	}
+
+	@Override
+	public String toString() {
+		return String.format("%s %s", getId(), getVersion());
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/ModCandidateFinder.java b/src/main/java/net/fabricmc/loader/impl/discovery/ModCandidateFinder.java
new file mode 100644
index 0000000000000000000000000000000000000000..504d4f5f6250b42cfa5573710931c250707a85b3
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/ModCandidateFinder.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import java.nio.file.Path;
+import java.util.Collections;
+import java.util.List;
+
+@FunctionalInterface
+interface ModCandidateFinder {
+	void findCandidates(ModCandidateConsumer out);
+
+	interface ModCandidateConsumer {
+		default void accept(Path path, boolean requiresRemap) {
+			accept(Collections.singletonList(path), requiresRemap);
+		}
+
+		void accept(List<Path> paths, boolean requiresRemap);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/ModDiscoverer.java b/src/main/java/net/fabricmc/loader/impl/discovery/ModDiscoverer.java
new file mode 100644
index 0000000000000000000000000000000000000000..737d847bbcded344a80afdbeee4d52d039bc4dc3
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/ModDiscoverer.java
@@ -0,0 +1,533 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.metadata.ModMetadata;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.FormattedException;
+import net.fabricmc.loader.impl.discovery.ModCandidateFinder.ModCandidateConsumer;
+import net.fabricmc.loader.impl.game.GameProvider.BuiltinMod;
+import net.fabricmc.loader.impl.metadata.*;
+import net.fabricmc.loader.impl.util.ExceptionUtil;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipInputStream;
+
+public final class ModDiscoverer {
+	private final VersionOverrides versionOverrides;
+	private final DependencyOverrides depOverrides;
+	private final List<ModCandidateFinder> candidateFinders = new ArrayList<>();
+	private final EnvType envType = FabricLoaderImpl.INSTANCE.getEnvironmentType();
+	private final Map<Long, ModScanTask> jijDedupMap = new ConcurrentHashMap<>(); // avoids reading the same jar twice
+	private final List<NestedModInitData> nestedModInitDatas = Collections.synchronizedList(new ArrayList<>()); // breaks potential cycles from deduplication
+
+	public ModDiscoverer(VersionOverrides versionOverrides, DependencyOverrides depOverrides) {
+		this.versionOverrides = versionOverrides;
+		this.depOverrides = depOverrides;
+	}
+
+	public void addCandidateFinder(ModCandidateFinder f) {
+		candidateFinders.add(f);
+	}
+
+	public List<ModCandidate> discoverMods(FabricLoaderImpl loader, Map<String, Set<ModCandidate>> envDisabledModsOut) throws ModResolutionException {
+		long startTime = System.nanoTime();
+		ForkJoinPool pool = new ForkJoinPool();
+		Set<Path> processedPaths = new HashSet<>(); // suppresses duplicate paths
+		List<Future<ModCandidate>> futures = new ArrayList<>();
+
+		ModCandidateConsumer taskSubmitter = (paths, requiresRemap) -> {
+			if (paths.size() == 1) {
+				Path path = LoaderUtil.normalizeExistingPath(paths.get(0));
+
+				if (processedPaths.add(path)) {
+					futures.add(pool.submit(new ModScanTask(Collections.singletonList(path), requiresRemap)));
+				}
+			} else {
+				List<Path> normalizedPaths = new ArrayList<>(paths.size());
+
+				for (Path path : paths) {
+					normalizedPaths.add(LoaderUtil.normalizeExistingPath(path));
+				}
+
+				if (!processedPaths.containsAll(normalizedPaths)) {
+					processedPaths.addAll(normalizedPaths);
+					futures.add(pool.submit(new ModScanTask(normalizedPaths, requiresRemap)));
+				}
+			}
+		};
+
+		for (ModCandidateFinder finder : candidateFinders) {
+			finder.findCandidates(taskSubmitter);
+		}
+
+		List<ModCandidate> candidates = new ArrayList<>();
+
+		// add builtin mods
+		for (BuiltinMod mod : loader.getGameProvider().getBuiltinMods()) {
+			ModCandidate candidate = ModCandidate.createBuiltin(mod, versionOverrides, depOverrides);
+			candidates.add(MetadataVerifier.verifyIndev(candidate));
+		}
+
+		// Add the current Java version
+		candidates.add(MetadataVerifier.verifyIndev(createJavaMod()));
+
+		ModResolutionException exception = null;
+
+		int timeout = Integer.getInteger(SystemProperties.DEBUG_DISCOVERY_TIMEOUT, 60);
+		if (timeout <= 0) timeout = Integer.MAX_VALUE;
+
+		try {
+			pool.shutdown();
+
+			pool.awaitTermination(timeout, TimeUnit.SECONDS);
+
+			for (Future<ModCandidate> future : futures) {
+				if (!future.isDone()) {
+					throw new TimeoutException();
+				}
+
+				try {
+					ModCandidate candidate = future.get();
+					if (candidate != null) candidates.add(candidate);
+				} catch (ExecutionException e) {
+					exception = ExceptionUtil.gatherExceptions(e, exception, exc -> new ModResolutionException("Mod discovery failed!", exc));
+				}
+			}
+
+			for (NestedModInitData data : nestedModInitDatas) {
+				for (Future<ModCandidate> future : data.futures) {
+					if (!future.isDone()) {
+						throw new TimeoutException();
+					}
+
+					try {
+						ModCandidate candidate = future.get();
+						if (candidate != null) data.target.add(candidate);
+					} catch (ExecutionException e) {
+						exception = ExceptionUtil.gatherExceptions(e, exception, exc -> new ModResolutionException("Mod discovery failed!", exc));
+					}
+				}
+			}
+		} catch (TimeoutException e) {
+			throw new FormattedException("Mod discovery took too long!",
+					"Analyzing the mod folder contents took longer than %d seconds. This may be caused by unusually slow hardware, pathological antivirus interference or other issues. The timeout can be changed with the system property %s (-D%<s=<desired timeout in seconds>).",
+					timeout, SystemProperties.DEBUG_DISCOVERY_TIMEOUT);
+		} catch (InterruptedException e) {
+			throw new FormattedException("Mod discovery interrupted!", e);
+		}
+
+		if (exception != null) {
+			throw exception;
+		}
+
+		// gather gather all mods (root+nested), initialize parent data
+
+		Set<ModCandidate> ret = Collections.newSetFromMap(new IdentityHashMap<>(candidates.size() * 2));
+		Queue<ModCandidate> queue = new ArrayDeque<>(candidates);
+		ModCandidate mod;
+
+		while ((mod = queue.poll()) != null) {
+			if (mod.getMetadata().loadsInEnvironment(envType)) {
+				if (!ret.add(mod)) continue;
+
+				for (ModCandidate child : mod.getNestedMods()) {
+					if (child.addParent(mod)) {
+						queue.add(child);
+					}
+				}
+			} else {
+				envDisabledModsOut.computeIfAbsent(mod.getId(), ignore -> Collections.newSetFromMap(new IdentityHashMap<>())).add(mod);
+			}
+		}
+
+		long endTime = System.nanoTime();
+
+		Log.debug(LogCategory.DISCOVERY, "Mod discovery time: %.1f ms", (endTime - startTime) * 1e-6);
+
+		return new ArrayList<>(ret);
+	}
+
+	private ModCandidate createJavaMod() {
+		ModMetadata metadata = new BuiltinModMetadata.Builder("java", System.getProperty("java.specification.version").replaceFirst("^1\\.", ""))
+				.setName(System.getProperty("java.vm.name"))
+				.build();
+		BuiltinMod builtinMod = new BuiltinMod(Collections.singletonList(Paths.get(System.getProperty("java.home"))), metadata);
+
+		return ModCandidate.createBuiltin(builtinMod, versionOverrides, depOverrides);
+	}
+
+	@SuppressWarnings("serial")
+	final class ModScanTask extends RecursiveTask<ModCandidate> {
+		private final List<Path> paths;
+		private final String localPath;
+		private final RewindableInputStream is;
+		private final long hash;
+		private final boolean requiresRemap;
+		private final List<String> parentPaths;
+
+		ModScanTask(List<Path> paths, boolean requiresRemap) {
+			this(paths, null, null, -1, requiresRemap, Collections.emptyList());
+		}
+
+		private ModScanTask(List<Path> paths, String localPath, RewindableInputStream is, long hash,
+				boolean requiresRemap, List<String> parentPaths) {
+			this.paths = paths;
+			this.localPath = localPath != null ? localPath : paths.get(0).toString();
+			this.is = is;
+			this.hash = hash;
+			this.requiresRemap = requiresRemap;
+			this.parentPaths = parentPaths;
+		}
+
+		@Override
+		protected ModCandidate compute() {
+			if (is != null) { // nested jar
+				try {
+					return computeJarStream();
+				} catch (ParseMetadataException e) { // already contains all context
+					throw ExceptionUtil.wrap(e);
+				} catch (Throwable t) {
+					throw new RuntimeException(String.format("Error analyzing nested jar %s from %s: %s", localPath, parentPaths, t), t);
+				}
+			} else { // regular classes-dir or jar
+				try {
+					if (paths.size() != 1 || Files.isDirectory(paths.get(0))) {
+						return computeDir();
+					} else {
+						return computeJarFile();
+					}
+				} catch (ParseMetadataException e) { // already contains all context
+					throw ExceptionUtil.wrap(e);
+				} catch (Throwable t) {
+					throw new RuntimeException(String.format("Error analyzing %s: %s", paths, t), t);
+				}
+			}
+		}
+
+		private ModCandidate computeDir() throws IOException, ParseMetadataException {
+			for (Path path : paths) {
+				Path modJson = path.resolve("fabric.mod.json");
+				if (!Files.exists(modJson)) continue;
+
+				LoaderModMetadata metadata;
+
+				try (InputStream is = Files.newInputStream(modJson)) {
+					metadata = parseMetadata(is, path.toString());
+				}
+
+				return ModCandidate.createPlain(paths, metadata, requiresRemap, Collections.emptyList());
+			}
+
+			return null;
+		}
+
+		private ModCandidate computeJarFile() throws IOException, ParseMetadataException {
+			assert paths.size() == 1;
+
+			try (ZipFile zf = new ZipFile(paths.get(0).toFile())) {
+				ZipEntry entry = zf.getEntry("fabric.mod.json");
+				if (entry == null) return null;
+
+				LoaderModMetadata metadata;
+
+				try (InputStream is = zf.getInputStream(entry)) {
+					metadata = parseMetadata(is, localPath);
+				}
+
+				if (!metadata.loadsInEnvironment(envType)) {
+					return ModCandidate.createPlain(paths, metadata, requiresRemap, Collections.emptyList());
+				}
+
+				List<ModScanTask> nestedModTasks;
+
+				if (metadata.getJars().isEmpty()) {
+					nestedModTasks = Collections.emptyList();
+				} else {
+					Set<NestedJarEntry> nestedJarPaths = new HashSet<>(metadata.getJars());
+
+					nestedModTasks = computeNestedMods(new ZipEntrySource() {
+						@Override
+						public ZipEntry getNextEntry() throws IOException {
+							while (jarIt.hasNext()) {
+								NestedJarEntry jar = jarIt.next();
+								ZipEntry ret = zf.getEntry(jar.getFile());
+
+								if (isValidNestedJarEntry(ret)) {
+									currentEntry = ret;
+									jarIt.remove();
+									return ret;
+								}
+							}
+
+							currentEntry = null;
+							return null;
+						}
+
+						@Override
+						public RewindableInputStream getInputStream() throws IOException {
+							try (InputStream is = zf.getInputStream(currentEntry)) {
+								return new RewindableInputStream(is);
+							}
+						}
+
+						private final Iterator<NestedJarEntry> jarIt = nestedJarPaths.iterator();
+						private ZipEntry currentEntry;
+					});
+
+					if (!nestedJarPaths.isEmpty() && FabricLoaderImpl.INSTANCE.isDevelopmentEnvironment()) {
+						Log.warn(LogCategory.METADATA, "Mod %s %s references missing nested jars: %s", metadata.getId(), metadata.getVersion(), nestedJarPaths);
+					}
+				}
+
+				List<ModCandidate> nestedMods;
+
+				if (nestedModTasks.isEmpty()) {
+					nestedMods = Collections.emptyList();
+				} else {
+					nestedMods = new ArrayList<>();
+					nestedModInitDatas.add(new NestedModInitData(nestedModTasks, nestedMods));
+				}
+
+				return ModCandidate.createPlain(paths, metadata, requiresRemap, nestedMods);
+			}
+		}
+
+		private ModCandidate computeJarStream() throws IOException, ParseMetadataException {
+			LoaderModMetadata metadata = null;
+			ZipEntry entry;
+
+			try (ZipInputStream zis = new ZipInputStream(is)) {
+				while ((entry = zis.getNextEntry()) != null) {
+					if (entry.getName().equals("fabric.mod.json")) {
+						metadata = parseMetadata(zis, localPath);
+						break;
+					}
+				}
+			}
+
+			if (metadata == null) return null;
+
+			if (!metadata.loadsInEnvironment(envType)) {
+				return ModCandidate.createNested(localPath, hash, metadata, requiresRemap, Collections.emptyList());
+			}
+
+			Collection<NestedJarEntry> nestedJars = metadata.getJars();
+			List<ModScanTask> nestedModTasks;
+
+			if (nestedJars.isEmpty()) {
+				nestedModTasks = Collections.emptyList();
+			} else {
+				Set<String> nestedJarPaths = new HashSet<>(nestedJars.size());
+
+				for (NestedJarEntry nestedJar : nestedJars) {
+					nestedJarPaths.add(nestedJar.getFile());
+				}
+
+				is.rewind();
+
+				try (ZipInputStream zis = new ZipInputStream(is)) {
+					nestedModTasks = computeNestedMods(new ZipEntrySource() {
+						@Override
+						public ZipEntry getNextEntry() throws IOException {
+							if (nestedJarPaths.isEmpty()) return null;
+
+							ZipEntry ret;
+
+							while ((ret = zis.getNextEntry()) != null) {
+								if (isValidNestedJarEntry(ret) && nestedJarPaths.remove(ret.getName())) {
+									is = new RewindableInputStream(zis); // reads the entry, which completes the ZipEntry with any trailing header data
+									return ret;
+								}
+							}
+
+							return null;
+						}
+
+						@Override
+						public RewindableInputStream getInputStream() throws IOException {
+							return is;
+						}
+
+						private RewindableInputStream is;
+					});
+				}
+
+				if (!nestedJarPaths.isEmpty() && FabricLoaderImpl.INSTANCE.isDevelopmentEnvironment()) {
+					Log.warn(LogCategory.METADATA, "Mod %s %s references missing nested jars: %s", metadata.getId(), metadata.getVersion(), nestedJarPaths);
+				}
+			}
+
+			List<ModCandidate> nestedMods;
+
+			if (nestedModTasks.isEmpty()) {
+				nestedMods = Collections.emptyList();
+			} else {
+				nestedMods = new ArrayList<>();
+				nestedModInitDatas.add(new NestedModInitData(nestedModTasks, nestedMods));
+			}
+
+			ModCandidate ret = ModCandidate.createNested(localPath, hash, metadata, requiresRemap, nestedMods);
+			ret.setData(is.getBuffer());
+
+			return ret;
+		}
+
+		private List<ModScanTask> computeNestedMods(ZipEntrySource entrySource) throws IOException {
+			List<String> parentPaths = new ArrayList<>(this.parentPaths.size() + 1);
+			parentPaths.addAll(this.parentPaths);
+			parentPaths.add(localPath);
+
+			List<ModScanTask> tasks = new ArrayList<>(5);
+			ModScanTask localTask = null;
+			ZipEntry entry;
+
+			while ((entry = entrySource.getNextEntry()) != null) {
+				long hash = ModCandidate.hash(entry);
+				ModScanTask task = jijDedupMap.get(hash);
+
+				if (task == null) {
+					task = new ModScanTask(null, entry.getName(), entrySource.getInputStream(), hash, requiresRemap, parentPaths);
+					ModScanTask prev = jijDedupMap.putIfAbsent(hash, task);
+
+					if (prev != null) {
+						task = prev;
+					} else if (localTask == null) { // don't fork first task, leave it for this thread
+						localTask = task;
+					} else {
+						task.fork();
+					}
+				}
+
+				tasks.add(task);
+			}
+
+			if (tasks.isEmpty()) return Collections.emptyList();
+
+			if (localTask != null) localTask.invoke();
+
+			return tasks;
+		}
+
+		private LoaderModMetadata parseMetadata(InputStream is, String localPath) throws ParseMetadataException {
+			return ModMetadataParser.parseMetadata(is, localPath, parentPaths, versionOverrides, depOverrides);
+		}
+	}
+
+	private static boolean isValidNestedJarEntry(ZipEntry entry) {
+		return entry != null && !entry.isDirectory() && entry.getName().endsWith(".jar");
+	}
+
+	private interface ZipEntrySource {
+		ZipEntry getNextEntry() throws IOException;
+		RewindableInputStream getInputStream() throws IOException;
+	}
+
+	private static final class RewindableInputStream extends InputStream {
+		private final ByteBuffer buffer;
+		private int pos;
+
+		RewindableInputStream(InputStream parent) throws IOException { // no parent.close()
+			buffer = readMod(parent);
+
+			assert buffer.hasArray() && buffer.arrayOffset() == 0 && buffer.position() == 0;
+		}
+
+		public ByteBuffer getBuffer() {
+			return buffer;
+		}
+
+		public void rewind() {
+			pos = 0;
+		}
+
+		@Override
+		public int read() throws IOException {
+			if (pos >= buffer.limit()) {
+				return -1;
+			} else {
+				return buffer.get(pos++) & 0xff;
+			}
+		}
+
+		@Override
+		public int read(byte[] b, int off, int len) throws IOException {
+			int rem = buffer.limit() - pos;
+
+			if (rem <= 0) {
+				return -1;
+			} else {
+				len = Math.min(len, rem);
+				System.arraycopy(buffer.array(), pos, b, off, len);
+				pos += len;
+
+				return len;
+			}
+		}
+	}
+
+	static ByteBuffer readMod(InputStream is) throws IOException {
+		int available = is.available();
+		boolean availableGood = available > 1;
+		byte[] buffer = new byte[availableGood ? available : 30_000];
+		int offset = 0;
+		int len;
+
+		while ((len = is.read(buffer, offset, buffer.length - offset)) >= 0) {
+			offset += len;
+
+			if (offset == buffer.length) {
+				if (availableGood) {
+					int val = is.read();
+					if (val < 0) break;
+
+					availableGood = false;
+					buffer = Arrays.copyOf(buffer, Math.max(buffer.length * 2, 30_000));
+					buffer[offset++] = (byte) val;
+				} else {
+					buffer = Arrays.copyOf(buffer, buffer.length * 2);
+				}
+			}
+		}
+
+		return ByteBuffer.wrap(buffer, 0, offset);
+	}
+
+	private static class NestedModInitData {
+		final List<? extends Future<ModCandidate>> futures;
+		final List<ModCandidate> target;
+
+		NestedModInitData(List<? extends Future<ModCandidate>> futures, List<ModCandidate> target) {
+			this.futures = futures;
+			this.target = target;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/ModLoadCondition.java b/src/main/java/net/fabricmc/loader/impl/discovery/ModLoadCondition.java
new file mode 100644
index 0000000000000000000000000000000000000000..126edcb823668f96120dde135006f510a9eb0931
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/ModLoadCondition.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+/**
+ * Conditions for whether to load a mod.
+ *
+ * <p>These apply only after the unique ID and nesting requirements are met. If a mod ID is shared by multiple mod
+ * candidates only one of them will load. Mods nested within another mod only load if the encompassing mod loads.
+ *
+ * <p>Each condition encompasses all conditions after it in enum declaration order. For example {@link #IF_POSSIBLE}
+ * also loads if the conditions for {@link #IF_RECOMMENDED} or {@link #IF_NEEDED} are met.
+ */
+public enum ModLoadCondition {
+	/**
+	 * Load always, triggering an error if that is not possible.
+	 *
+	 * <p>This is the default for root mods (typically those in the mods folder).
+	 */
+	ALWAYS,
+	/**
+	 * Load whenever there is nothing contradicting.
+	 *
+	 * <p>This is the default for nested mods.
+	 */
+	IF_POSSIBLE,
+	/**
+	 * Load if the mod is recommended by another loading mod.
+	 */
+	IF_RECOMMENDED,
+	/**
+	 * Load if another loading mod requires the mod.
+	 */
+	IF_NEEDED;
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/ModResolutionException.java b/src/main/java/net/fabricmc/loader/impl/discovery/ModResolutionException.java
new file mode 100644
index 0000000000000000000000000000000000000000..3d5b6dad4ba88e660cb8b85a9a70b14fa6f2f051
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/ModResolutionException.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+@SuppressWarnings("serial")
+public class ModResolutionException extends Exception {
+	public ModResolutionException(String s) {
+		super(s);
+	}
+
+	public ModResolutionException(String format, Object... args) {
+		super(String.format(format, args));
+	}
+
+	public ModResolutionException(String s, Throwable t) {
+		super(s, t);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/ModResolver.java b/src/main/java/net/fabricmc/loader/impl/discovery/ModResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..6867ede1ca1b815b0d8296d41be0940a131d2d9a
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/ModResolver.java
@@ -0,0 +1,267 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.metadata.ModDependency;
+import net.fabricmc.loader.api.metadata.ModDependency.Kind;
+import net.fabricmc.loader.impl.discovery.ModSolver.InactiveReason;
+import net.fabricmc.loader.impl.metadata.ModDependencyImpl;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import org.sat4j.specs.ContradictionException;
+import org.sat4j.specs.TimeoutException;
+
+import java.util.*;
+import java.util.stream.Collectors;
+
+public class ModResolver {
+	public static List<ModCandidate> resolve(Collection<ModCandidate> candidates, EnvType envType, Map<String, Set<ModCandidate>> envDisabledMods) throws ModResolutionException {
+		long startTime = System.nanoTime();
+		List<ModCandidate> result = findCompatibleSet(candidates, envType, envDisabledMods);
+
+		long endTime = System.nanoTime();
+		Log.debug(LogCategory.RESOLUTION, "Mod resolution time: %.1f ms", (endTime - startTime) * 1e-6);
+
+		return result;
+	}
+
+	private static List<ModCandidate> findCompatibleSet(Collection<ModCandidate> candidates, EnvType envType, Map<String, Set<ModCandidate>> envDisabledMods) throws ModResolutionException {
+		// sort all mods by priority
+
+		List<ModCandidate> allModsSorted = new ArrayList<>(candidates);
+
+		allModsSorted.sort(modPrioComparator);
+
+		// group/index all mods by id
+
+		Map<String, List<ModCandidate>> modsById = new LinkedHashMap<>(); // linked to ensure consistent execution
+
+		for (ModCandidate mod : allModsSorted) {
+			modsById.computeIfAbsent(mod.getId(), ignore -> new ArrayList<>()).add(mod);
+
+			for (String provided : mod.getProvides()) {
+				modsById.computeIfAbsent(provided, ignore -> new ArrayList<>()).add(mod);
+			}
+		}
+
+		// soften positive deps from schema 0 or 1 mods on mods that are present but disabled for the current env
+		// this is a workaround necessary due to many mods declaring deps that are unsatisfiable in some envs and loader before 0.12x not verifying them properly
+
+		for (ModCandidate mod : allModsSorted) {
+			if (mod.getMetadata().getSchemaVersion() >= 2) continue;
+
+			for (ModDependency dep : mod.getMetadata().getDependencies()) {
+				if (!dep.getKind().isPositive() || dep.getKind() == Kind.SUGGESTS) continue; // no positive dep or already suggests
+				if (!(dep instanceof ModDependencyImpl)) continue; // can't modify dep kind
+				if (modsById.containsKey(dep.getModId())) continue; // non-disabled match available
+
+				Collection<ModCandidate> disabledMatches = envDisabledMods.get(dep.getModId());
+				if (disabledMatches == null) continue; // no disabled id matches
+
+				for (ModCandidate m : disabledMatches) {
+					if (dep.matches(m.getVersion())) { // disabled version match -> remove dep
+						((ModDependencyImpl) dep).setKind(Kind.SUGGESTS);
+						break;
+					}
+				}
+			}
+		}
+
+		// preselect mods, check for builtin mod collisions
+
+		List<ModCandidate> preselectedMods = new ArrayList<>();
+
+		for (List<ModCandidate> mods : modsById.values()) {
+			ModCandidate builtinMod = null;
+
+			for (ModCandidate mod : mods) {
+				if (mod.isBuiltin()) {
+					builtinMod = mod;
+					break;
+				}
+			}
+
+			if (builtinMod == null) continue;
+
+			if (mods.size() > 1) {
+				mods.remove(builtinMod);
+				throw new ModResolutionException("Mods share ID with builtin mod %s: %s", builtinMod, mods);
+			}
+
+			preselectedMods.add(builtinMod);
+		}
+
+		Map<String, ModCandidate> selectedMods = new HashMap<>(allModsSorted.size());
+		List<ModCandidate> uniqueSelectedMods = new ArrayList<>(allModsSorted.size());
+
+		for (ModCandidate mod : preselectedMods) {
+			preselectMod(mod, allModsSorted, modsById, selectedMods, uniqueSelectedMods);
+		}
+
+		// solve
+
+		ModSolver.Result result;
+
+		try {
+			result = ModSolver.solve(allModsSorted, modsById,
+					selectedMods, uniqueSelectedMods);
+		} catch (ContradictionException | TimeoutException e) {
+			throw new ModResolutionException("Solving failed", e);
+		}
+
+		if (!result.success) {
+			Log.warn(LogCategory.RESOLUTION, "Mod resolution failed");
+			Log.info(LogCategory.RESOLUTION, "Immediate reason: %s%n", result.immediateReason);
+			Log.info(LogCategory.RESOLUTION, "Reason: %s%n", result.reason);
+			if (!envDisabledMods.isEmpty()) Log.info(LogCategory.RESOLUTION, "%s environment disabled: %s%n", envType.name(), envDisabledMods.keySet());
+
+			if (result.fix == null) {
+				Log.info(LogCategory.RESOLUTION, "No fix?");
+			} else {
+				Log.info(LogCategory.RESOLUTION, "Fix: add %s, remove %s, replace [%s]%n",
+						result.fix.modsToAdd,
+						result.fix.modsToRemove,
+						result.fix.modReplacements.entrySet().stream().map(e -> String.format("%s -> %s", e.getValue(), e.getKey())).collect(Collectors.joining(", ")));
+
+				for (Collection<ModCandidate> mods : envDisabledMods.values()) {
+					for (ModCandidate m : mods) {
+						result.fix.inactiveMods.put(m, InactiveReason.WRONG_ENVIRONMENT);
+					}
+				}
+			}
+
+			throw new ModResolutionException("Mod resolution encountered an incompatible mod set!%s",
+					ResultAnalyzer.gatherErrors(result, selectedMods, modsById, envDisabledMods, envType));
+		}
+
+		uniqueSelectedMods.sort(Comparator.comparing(ModCandidate::getId));
+
+		// clear cached data and inbound refs for unused mods, set minNestLevel for used non-root mods to max, queue root mods
+
+		Queue<ModCandidate> queue = new ArrayDeque<>();
+
+		for (ModCandidate mod : allModsSorted) {
+			if (selectedMods.get(mod.getId()) == mod) { // mod is selected
+				if (!mod.resetMinNestLevel()) { // -> is root
+					queue.add(mod);
+				}
+			} else {
+				mod.clearCachedData();
+
+				for (ModCandidate m : mod.getNestedMods()) {
+					m.getParentMods().remove(mod);
+				}
+
+				for (ModCandidate m : mod.getParentMods()) {
+					m.getNestedMods().remove(mod);
+				}
+			}
+		}
+
+		// recompute minNestLevel (may have changed due to parent associations having been dropped by the above step)
+
+		{
+			ModCandidate mod;
+
+			while ((mod = queue.poll()) != null) {
+				for (ModCandidate child : mod.getNestedMods()) {
+					if (child.updateMinNestLevel(mod)) {
+						queue.add(child);
+					}
+				}
+			}
+		}
+
+		String warnings = ResultAnalyzer.gatherWarnings(uniqueSelectedMods, selectedMods,
+				envDisabledMods, envType);
+
+		if (warnings != null) {
+			Log.warn(LogCategory.RESOLUTION, "Warnings were found!%s", warnings);
+		}
+
+		return uniqueSelectedMods;
+	}
+
+	private static final Comparator<ModCandidate> modPrioComparator = new Comparator<ModCandidate>() {
+		@Override
+		public int compare(ModCandidate a, ModCandidate b) {
+			// descending sort prio (less/earlier is higher prio):
+			// root mods first, lower id first, higher version first, less nesting first, parent cmp
+
+			if (a.isRoot()) {
+				if (!b.isRoot()) {
+					return -1; // only a is root
+				}
+			} else if (b.isRoot()) {
+				return 1; // only b is root
+			}
+
+			// sort id desc
+			int idCmp = a.getId().compareTo(b.getId());
+			if (idCmp != 0) return idCmp;
+
+			// sort version desc (lower version later)
+			int versionCmp = b.getVersion().compareTo(a.getVersion());
+			if (versionCmp != 0) return versionCmp;
+
+			// sort nestLevel asc
+			int nestCmp = a.getMinNestLevel() - b.getMinNestLevel(); // >0 if nest(a) > nest(b)
+			if (nestCmp != 0) return nestCmp;
+
+			if (a.isRoot()) return 0; // both root
+
+			List<ModCandidate> parents = new ArrayList<>(a.getParentMods().size() + b.getParentMods().size());
+			parents.addAll(a.getParentMods());
+			parents.addAll(b.getParentMods());
+			parents.sort(this);
+
+			if (a.getParentMods().contains(parents.get(0))) {
+				if (b.getParentMods().contains(parents.get(0))) {
+					return 0;
+				} else {
+					return -1;
+				}
+			} else {
+				return 1;
+			}
+		}
+	};
+
+	static void preselectMod(ModCandidate mod, List<ModCandidate> allModsSorted, Map<String, List<ModCandidate>> modsById,
+			Map<String, ModCandidate> selectedMods, List<ModCandidate> uniqueSelectedMods) throws ModResolutionException {
+		selectMod(mod, selectedMods, uniqueSelectedMods);
+
+		allModsSorted.removeAll(modsById.remove(mod.getId()));
+
+		for (String provided : mod.getProvides()) {
+			allModsSorted.removeAll(modsById.remove(provided));
+		}
+	}
+
+	static void selectMod(ModCandidate mod, Map<String, ModCandidate> selectedMods, List<ModCandidate> uniqueSelectedMods) throws ModResolutionException {
+		ModCandidate prev = selectedMods.put(mod.getId(), mod);
+		if (prev != null) throw new ModResolutionException("duplicate mod %s", mod.getId());
+
+		for (String provided : mod.getProvides()) {
+			prev = selectedMods.put(provided, mod);
+			if (prev != null) throw new ModResolutionException("duplicate mod %s", provided);
+		}
+
+		uniqueSelectedMods.add(mod);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/ModSolver.java b/src/main/java/net/fabricmc/loader/impl/discovery/ModSolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0d7110a1b856197fd7635bd34dbd36056391d80
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/ModSolver.java
@@ -0,0 +1,1095 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.metadata.ModDependency;
+import net.fabricmc.loader.api.metadata.version.VersionInterval;
+import net.fabricmc.loader.api.metadata.version.VersionPredicate;
+import net.fabricmc.loader.impl.discovery.Explanation.ErrorKind;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import net.fabricmc.loader.impl.util.version.SemanticVersionImpl;
+import net.fabricmc.loader.impl.util.version.VersionPredicateParser;
+import org.sat4j.pb.IPBSolver;
+import org.sat4j.pb.SolverFactory;
+import org.sat4j.pb.tools.DependencyHelper;
+import org.sat4j.pb.tools.INegator;
+import org.sat4j.pb.tools.WeightedObject;
+import org.sat4j.specs.ContradictionException;
+import org.sat4j.specs.TimeoutException;
+
+import java.math.BigInteger;
+import java.util.*;
+import java.util.function.Function;
+
+final class ModSolver {
+	static Result solve(List<ModCandidate> allModsSorted, Map<String, List<ModCandidate>> modsById,
+			Map<String, ModCandidate> selectedMods, List<ModCandidate> uniqueSelectedMods) throws ContradictionException, TimeoutException, ModResolutionException {
+		// build priority index
+
+		Map<ModCandidate, Integer> priorities = new IdentityHashMap<>(allModsSorted.size());
+
+		for (int i = 0; i < allModsSorted.size(); i++) {
+			priorities.put(allModsSorted.get(i), i);
+		}
+
+		// create and configure solver
+
+		solverPrepTime = System.nanoTime();
+
+		IPBSolver solver = SolverFactory.newDefaultOptimizer();
+
+		int timeout = Integer.getInteger(SystemProperties.DEBUG_RESOLUTION_TIMEOUT, 60);
+		if (timeout > 0) solver.setTimeout(timeout); // in seconds
+
+		DependencyHelper<DomainObject, Explanation> dependencyHelper = createDepHelper(solver);
+
+		setupSolver(allModsSorted, modsById,
+				priorities, selectedMods, uniqueSelectedMods,
+				false, null, false,
+				dependencyHelper);
+
+		// solve
+
+		solveTime = System.nanoTime();
+
+		boolean hasSolution = dependencyHelper.hasASolution();
+
+		// check solution
+
+		solutionFetchTime = System.nanoTime();
+
+		if (hasSolution) {
+			Collection<DomainObject> solution = dependencyHelper.getASolution();
+
+			solutionAnalyzeTime = System.nanoTime();
+
+			for (DomainObject obj : solution) {
+				if (obj instanceof ModCandidate) {
+					ModResolver.selectMod((ModCandidate) obj, selectedMods, uniqueSelectedMods);
+				} else {
+					assert obj instanceof OptionalDepVar;
+				}
+			}
+
+			dependencyHelper.reset();
+
+			return Result.createSuccess();
+		} else { // no solution
+			Set<Explanation> reason = dependencyHelper.why();
+
+			// gather all failed deps
+
+			Set<ModDependency> failedDeps = Collections.newSetFromMap(new IdentityHashMap<>());
+			List<Explanation> failedExplanations = new ArrayList<>();
+
+			computeFailureCausesOptional(allModsSorted, modsById,
+					priorities, selectedMods, uniqueSelectedMods,
+					reason, dependencyHelper,
+					failedDeps, failedExplanations);
+
+			// find best solution with mod addition/removal
+
+			fixSetupTime = System.nanoTime();
+
+			Fix fix = computeFix(uniqueSelectedMods, allModsSorted, modsById,
+					priorities, selectedMods,
+					failedDeps, dependencyHelper);
+
+			dependencyHelper.reset();
+
+			return Result.createFailure(reason, failedExplanations, fix);
+		}
+	}
+
+	static long solverPrepTime;
+	static long solveTime;
+	static long solutionFetchTime;
+	static long solutionAnalyzeTime;
+	static long fixSetupTime;
+
+	static class Result {
+		final boolean success;
+		final Collection<Explanation> immediateReason;
+		final Collection<Explanation> reason;
+		final Fix fix; // may be null
+
+		static Result createSuccess() {
+			return new Result(true, null, null, null);
+		}
+
+		static Result createFailure(Collection<Explanation> immediateReason, Collection<Explanation> reason, Fix fix) {
+			return new Result(false, immediateReason, reason, fix);
+		}
+
+		private Result(boolean success, Collection<Explanation> immediateReason, Collection<Explanation> reason, Fix fix) {
+			this.success = success;
+			this.immediateReason = immediateReason;
+			this.reason = reason;
+			this.fix = fix;
+		}
+	}
+
+	private static void computeFailureCausesOptional(List<ModCandidate> allModsSorted, Map<String, List<ModCandidate>> modsById,
+			Map<ModCandidate, Integer> priorities, Map<String, ModCandidate> selectedMods, List<ModCandidate> uniqueSelectedMods,
+			Set<Explanation> reason, DependencyHelper<DomainObject, Explanation> dependencyHelper,
+			Set<ModDependency> failedDeps, List<Explanation> failedExplanations) throws ContradictionException, TimeoutException {
+		dependencyHelper.reset();
+		dependencyHelper = createDepHelper(dependencyHelper.getSolver()); // dependencyHelper.reset doesn't fully reset the dep helper
+
+		setupSolver(allModsSorted, modsById,
+				priorities, selectedMods, uniqueSelectedMods,
+				true, null, false,
+				dependencyHelper);
+
+		if (dependencyHelper.hasASolution()) {
+			Collection<DomainObject> solution = dependencyHelper.getASolution();
+			Set<ModDependency> disabledDeps = new HashSet<>(); // DisableDepVar uses equality semantics, not identity
+
+			for (DomainObject obj : solution) {
+				if (obj instanceof DisableDepVar) {
+					disabledDeps.add(((DisableDepVar) obj).dep);
+				} else {
+					assert obj instanceof ModCandidate;
+				}
+			}
+
+			// populate failedDeps with disabledDeps entries that are actually in use (referenced through non-optional mods)
+			// record explanation for failed deps that capture the depending mod
+
+			for (DomainObject obj : solution) {
+				if (!(obj instanceof ModCandidate)) continue;
+
+				ModCandidate mod = (ModCandidate) obj;
+
+				for (ModDependency dep : mod.getDependencies()) {
+					if (disabledDeps.contains(dep)) {
+						assert dep.getKind() == ModDependency.Kind.DEPENDS || dep.getKind() == ModDependency.Kind.BREAKS;
+
+						failedDeps.add(dep);
+						failedExplanations.add(new Explanation(dep.getKind() == ModDependency.Kind.DEPENDS ? ErrorKind.HARD_DEP : ErrorKind.NEG_HARD_DEP, mod, dep));
+					}
+				}
+			}
+		}
+	}
+
+	private static Fix computeFix(List<ModCandidate> uniqueSelectedMods, List<ModCandidate> allModsSorted, Map<String, List<ModCandidate>> modsById,
+			Map<ModCandidate, Integer> priorities, Map<String, ModCandidate> selectedMods,
+			Set<ModDependency> failedDeps, DependencyHelper<DomainObject, Explanation> dependencyHelper) throws ContradictionException, TimeoutException {
+		// group positive deps by mod id
+		Map<String, Set<Collection<VersionPredicate>>> depsById = new HashMap<>();
+
+		for (ModDependency dep : failedDeps) {
+			if (dep.getKind() == ModDependency.Kind.DEPENDS) {
+				depsById.computeIfAbsent(dep.getModId(), ignore -> new HashSet<>()).add(dep.getVersionRequirements());
+			}
+		}
+
+		// add mods with unsatisfied deps as well so they can be replaced (remove+add)
+
+		Set<String> modsWithOnlyOutboundDepFailures = new HashSet<>();
+
+		for (ModCandidate mod : allModsSorted) {
+			if (!mod.getDependencies().isEmpty()
+					&& !depsById.containsKey(mod.getId())
+					&& !Collections.disjoint(mod.getDependencies(), failedDeps)) { // mod has unsatisfied deps
+				depsById.computeIfAbsent(mod.getId(), ignore -> new HashSet<>()).add(Collections.singleton(VersionPredicateParser.getAny()));
+				modsWithOnlyOutboundDepFailures.add(mod.getId());
+			}
+		}
+
+		// add deps that didn't fail to find all relevant boundary versions to test
+
+		for (ModCandidate mod : allModsSorted) {
+			for (ModDependency dep : mod.getDependencies()) {
+				if (dep.getKind() != ModDependency.Kind.DEPENDS) continue;
+
+				Set<Collection<VersionPredicate>> predicates = depsById.get(dep.getModId());
+
+				if (predicates != null) {
+					predicates.add(dep.getVersionRequirements());
+				}
+			}
+		}
+
+		// determine mod versions to try to add
+
+		Map<String, List<AddModVar>> installableMods = new HashMap<>();
+
+		for (Map.Entry<String, Set<Collection<VersionPredicate>>> entry : depsById.entrySet()) {
+			String id = entry.getKey();
+			boolean hadOnlyOutboundDepFailures = modsWithOnlyOutboundDepFailures.contains(id);
+
+			// extract all version bounds (resulting version needs to be part of one of them)
+
+			Set<VersionInterval> allIntervals = new HashSet<>();
+
+			for (Collection<VersionPredicate> versionPredicates : entry.getValue()) {
+				List<VersionInterval> intervals = Collections.emptyList();
+
+				for (VersionPredicate v : versionPredicates) {
+					intervals = VersionInterval.or(intervals, v.getInterval());
+				}
+
+				allIntervals.addAll(intervals);
+			}
+
+			if (allIntervals.isEmpty()) continue;
+
+			// try to determine common version bounds, alternatively approximate (imprecise due to not knowing the real versions or which deps are really essential)
+
+			VersionInterval commonInterval = null;
+			boolean commonVersionInitialized = false;
+			Set<Version> versions = new HashSet<>();
+
+			for (VersionInterval interval : allIntervals) {
+				if (commonInterval == null) {
+					if (!commonVersionInitialized) { // initialize to first range, otherwise leave as empty range
+						commonInterval = interval;
+						commonVersionInitialized = true;
+					}
+				} else {
+					commonInterval = interval.and(commonInterval);
+				}
+
+				versions.add(deriveVersion(interval));
+			}
+
+			List<AddModVar> out = installableMods.computeIfAbsent(id, ignore -> new ArrayList<>());
+
+			if (commonInterval != null) {
+				out.add(new AddModVar(id, deriveVersion(commonInterval), hadOnlyOutboundDepFailures));
+			} else {
+				for (Version version : versions) {
+					out.add(new AddModVar(id, version, hadOnlyOutboundDepFailures));
+				}
+			}
+
+			out.sort(Comparator.<AddModVar, Version>comparing(AddModVar::getVersion).reversed());
+		}
+
+		// check the determined solution
+
+		fixSolveTime = System.nanoTime();
+
+		dependencyHelper.reset();
+		dependencyHelper = createDepHelper(dependencyHelper.getSolver()); // dependencyHelper.reset doesn't fully reset the dep helper
+
+		setupSolver(allModsSorted, modsById,
+				priorities, selectedMods, uniqueSelectedMods,
+				false, installableMods, true,
+				dependencyHelper);
+
+		if (!dependencyHelper.hasASolution()) {
+			Log.warn(LogCategory.RESOLUTION, "Unable to find a solution to fix the mod set, reason: %s", dependencyHelper.why());
+			return null;
+		}
+
+		Map<String, ModCandidate> activeMods = new HashMap<>();
+		Map<ModCandidate, InactiveReason> inactiveMods = new IdentityHashMap<>(allModsSorted.size());
+		List<AddModVar> modsToAdd = new ArrayList<>();
+		List<ModCandidate> modsToRemove = new ArrayList<>();
+		Map<AddModVar, List<ModCandidate>> modReplacements = new HashMap<>();
+
+		for (ModCandidate mod : allModsSorted) {
+			inactiveMods.put(mod, InactiveReason.UNKNOWN);
+		}
+
+		for (DomainObject obj : dependencyHelper.getASolution()) {
+			if (obj instanceof ModCandidate) {
+				ModCandidate mod = (ModCandidate) obj;
+
+				activeMods.put(mod.getId(), mod);
+				inactiveMods.remove(mod);
+			} else if (obj instanceof AddModVar) {
+				AddModVar mod = (AddModVar) obj;
+				List<ModCandidate> replaced = new ArrayList<>();
+
+				ModCandidate selectedMod = selectedMods.get(obj.getId());
+				if (selectedMod != null) replaced.add(selectedMod);
+
+				List<ModCandidate> mods = modsById.get(obj.getId());
+				if (mods != null) replaced.addAll(mods);
+
+				if (replaced.isEmpty()) {
+					modsToAdd.add(mod);
+				} else { // same id as mods picked previously -> replacement
+					modReplacements.put(mod, replaced);
+
+					for (ModCandidate m : replaced) {
+						inactiveMods.put(m, InactiveReason.TO_REPLACE);
+					}
+				}
+			} else if (obj instanceof RemoveModVar) {
+				boolean found = false;
+
+				ModCandidate mod = selectedMods.get(obj.getId());
+
+				if (mod != null) {
+					modsToRemove.add(mod);
+					inactiveMods.put(mod, InactiveReason.TO_REMOVE);
+					found = true;
+				}
+
+				List<ModCandidate> mods = modsById.get(obj.getId());
+
+				if (mods != null) {
+					for (ModCandidate m : mods) {
+						if (m.isRoot()) {
+							modsToRemove.add(m);
+							inactiveMods.put(m, InactiveReason.TO_REMOVE);
+							found = true;
+						}
+					}
+				}
+
+				assert found;
+			} else { // unexpected domainobj kind
+				assert false : obj;
+			}
+		}
+
+		// compute version intervals compatible with the active mod set for all mods to add
+
+		for (Collection<AddModVar> mods : Arrays.asList(modsToAdd, modReplacements.keySet())) {
+			for (AddModVar mod : mods) {
+				List<VersionInterval> intervals = Collections.singletonList(VersionInterval.INFINITE);
+
+				for (ModCandidate m : activeMods.values()) {
+					for (ModDependency dep : m.getDependencies()) {
+						if (!dep.getModId().equals(mod.getId()) || dep.getKind().isSoft()) continue;
+
+						if (dep.getKind().isPositive()) {
+							intervals = VersionInterval.and(intervals, dep.getVersionIntervals());
+						} else {
+							intervals = VersionInterval.and(intervals, VersionInterval.not(dep.getVersionIntervals()));
+						}
+					}
+				}
+
+				mod.setVersionIntervals(intervals);
+			}
+		}
+
+		// compute reasons for mods to be inactive
+
+		inactiveModLoop: for (Map.Entry<ModCandidate, InactiveReason> entry : inactiveMods.entrySet()) {
+			if (entry.getValue() != InactiveReason.UNKNOWN) continue;
+
+			ModCandidate mod = entry.getKey();
+			ModCandidate active = activeMods.get(mod.getId());
+
+			if (active != null) {
+				if (allModsSorted.indexOf(mod) > allModsSorted.indexOf(active)) { // entry has lower prio (=higher index) than active
+					if (mod.getVersion().equals(active.getVersion())) {
+						entry.setValue(InactiveReason.SAME_ACTIVE);
+					} else {
+						assert mod.getVersion().compareTo(active.getVersion()) < 0;
+						entry.setValue(InactiveReason.NEWER_ACTIVE);
+					}
+				} else {
+					entry.setValue(InactiveReason.INCOMPATIBLE);
+				}
+
+				continue inactiveModLoop;
+			}
+
+			if (!mod.getParentMods().isEmpty()) {
+				boolean found = false;
+
+				for (ModCandidate m : mod.getParentMods()) {
+					if (activeMods.get(m.getId()) == m) {
+						found = true;
+						break;
+					}
+				}
+
+				if (!found) {
+					entry.setValue(InactiveReason.INACTIVE_PARENT);
+					continue inactiveModLoop;
+				}
+			}
+		}
+
+		// TODO: test if the solution is actually valid?
+
+		return new Fix(modsToAdd, modsToRemove, modReplacements, activeMods, inactiveMods);
+	}
+
+	static long fixSolveTime;
+
+	private static Version deriveVersion(VersionInterval interval) {
+		if (!interval.isSemantic()) {
+			return interval.getMin() != null ? interval.getMin() : interval.getMax();
+		}
+
+		SemanticVersion v = (SemanticVersion) interval.getMin();
+
+		if (v != null) { // min bound present
+			if (!interval.isMinInclusive()) { // not inclusive, increment slightly
+				String pr = v.getPrereleaseKey().orElse(null);
+				int[] comps = ((SemanticVersionImpl) v).getVersionComponents();
+
+				if (pr != null) { // has prerelease, add to increase
+					pr = pr.isEmpty() ? "0" : pr.concat(".0");
+				} else { // regular version only, increment patch and make least prerelease
+					if (comps.length < 3) {
+						comps = Arrays.copyOf(comps, comps.length + 1);
+					}
+
+					comps[comps.length - 1]++;
+					pr = "";
+				}
+
+				v = new SemanticVersionImpl(comps, pr, null);
+			}
+		} else if ((v = (SemanticVersion) interval.getMax()) != null) { // max bound only
+			if (!interval.isMaxInclusive()) { // not inclusive, decrement slightly
+				String pr = v.getPrereleaseKey().orElse(null);
+				int[] comps = ((SemanticVersionImpl) v).getVersionComponents();
+
+				if (pr == null) { // no prerelease, use large pr segment
+					pr = "zzzzzzzz";
+				} else if (!pr.isEmpty()) { // non-empty prerelease present, decrement slightly or truncate
+					int pos = pr.lastIndexOf('.') + 1;
+					String suffix = pr.substring(pos);
+					int val;
+					char c;
+
+					if (suffix.matches("\\d+") && (val = Integer.parseInt(suffix)) > 0) {
+						pr = pr.substring(0, pos)+(val - 1);
+					} else if (suffix.length() > 0 && ((c = suffix.charAt(suffix.length() - 1)) != '0' || suffix.length() >= 2)) {
+						pr = pr.substring(0, pr.length() - 1);
+
+						if (c == 'a') {
+							pr += 'Z';
+						} else if (c == 'A') {
+							pr += '9';
+						} else if (c != '0') {
+							pr += c - 1;
+						}
+					} else {
+						pr = pos > 0 ? pr.substring(0, pos - 1) : "";
+					}
+				} else { // empty prerelease, decrement version and strip prerelease
+					pr = null;
+
+					if (comps.length < 3) {
+						comps = Arrays.copyOf(comps, 3);
+					}
+
+					for (int i = 2; i >= 0; i--) {
+						if (comps[i] > 0) {
+							comps[i]--;
+							break;
+						} else {
+							comps[i] = 9999;
+						}
+					}
+				}
+
+				v = new SemanticVersionImpl(comps, pr, null);
+			}
+		} else { // unbounded
+			v = new SemanticVersionImpl(new int[] { 1 }, null, null);
+		}
+
+		return v;
+	}
+
+	static class Fix {
+		final Collection<AddModVar> modsToAdd;
+		final Collection<ModCandidate> modsToRemove;
+		final Map<AddModVar, List<ModCandidate>> modReplacements;
+		final Map<String, ModCandidate> activeMods;
+		final Map<ModCandidate, InactiveReason> inactiveMods;
+
+		Fix(Collection<AddModVar> modsToAdd, Collection<ModCandidate> modsToRemove, Map<AddModVar, List<ModCandidate>> modReplacements,
+				Map<String, ModCandidate> activeMods, Map<ModCandidate, InactiveReason> inactiveMods) {
+			this.modsToAdd = modsToAdd;
+			this.modsToRemove = modsToRemove;
+			this.modReplacements = modReplacements;
+			this.activeMods = activeMods;
+			this.inactiveMods = inactiveMods;
+		}
+	}
+
+	enum InactiveReason {
+		INACTIVE_PARENT("inactive_parent"),
+		INCOMPATIBLE("incompatible"),
+		NEWER_ACTIVE("newer_active"),
+		SAME_ACTIVE("same_active"),
+		TO_REMOVE("to_remove"),
+		TO_REPLACE("to_replace"),
+		UNKNOWN("unknown"),
+		WRONG_ENVIRONMENT("wrong_environment");
+
+		final String id;
+
+		InactiveReason(String id) {
+			this.id = id;
+		}
+	}
+
+	private static void setupSolver(List<ModCandidate> allModsSorted, Map<String, List<ModCandidate>> modsById,
+			Map<ModCandidate, Integer> priorities, Map<String, ModCandidate> selectedMods, List<ModCandidate> uniqueSelectedMods,
+			boolean depDisableSim, Map<String, List<AddModVar>> installableMods, boolean removalSim,
+			DependencyHelper<DomainObject, Explanation> dependencyHelper) throws ContradictionException {
+		Map<String, DomainObject> dummies = new HashMap<>();
+		Map<ModDependency, Map.Entry<DomainObject, Integer>> disabledDeps = depDisableSim ? new HashMap<>() : null;
+		List<WeightedObject<DomainObject>> weightedObjects = new ArrayList<>();
+
+		generatePreselectConstraints(uniqueSelectedMods, modsById,
+				priorities, selectedMods,
+				depDisableSim, installableMods, removalSim,
+				dummies, disabledDeps,
+				dependencyHelper, weightedObjects);
+
+		generateMainConstraints(allModsSorted, modsById,
+				priorities, selectedMods,
+				depDisableSim, installableMods, removalSim,
+				dummies, disabledDeps,
+				dependencyHelper, weightedObjects);
+
+		if (depDisableSim) {
+			applyDisableDepVarWeights(disabledDeps, priorities.size(), weightedObjects);
+		}
+
+		@SuppressWarnings("unchecked")
+		WeightedObject<DomainObject>[] weights = weightedObjects.toArray(new WeightedObject[0]);
+		dependencyHelper.setObjectiveFunction(weights);
+		//dependencyHelper.addWeightedCriterion(weightedObjects);
+	}
+
+	private static void generatePreselectConstraints(List<ModCandidate> uniqueSelectedMods, Map<String, List<ModCandidate>> modsById,
+			Map<ModCandidate, Integer> priorities, Map<String, ModCandidate> selectedMods,
+			boolean depDisableSim, Map<String, List<AddModVar>> installableMods, boolean removalSim,
+			Map<String, DomainObject> dummyMods, Map<ModDependency, Map.Entry<DomainObject, Integer>> disabledDeps,
+			DependencyHelper<DomainObject, Explanation> dependencyHelper, List<WeightedObject<DomainObject>> weightedObjects) throws ContradictionException {
+		boolean enableOptional = !depDisableSim && installableMods == null && !removalSim; // whether to enable optional mods (regular solve only, not for failure handling)
+		List<DomainObject> suitableMods = new ArrayList<>();
+
+		for (ModCandidate mod : uniqueSelectedMods) {
+			// add constraints for dependencies (skips deps that are already preselected outside depDisableSim)
+
+			for (ModDependency dep : mod.getDependencies()) {
+				if (!enableOptional && dep.getKind().isSoft()) continue;
+				if (selectedMods.containsKey(dep.getModId())) continue;
+
+				List<? extends DomainObject.Mod> availableMods = modsById.get(dep.getModId());
+
+				if (availableMods != null) {
+					for (DomainObject.Mod m : availableMods) {
+						if (dep.matches(m.getVersion())) suitableMods.add(m);
+					}
+				}
+
+				if (installableMods != null) {
+					availableMods = installableMods.get(dep.getModId());
+
+					if (availableMods != null) {
+						for (DomainObject.Mod m : availableMods) {
+							if (dep.matches(m.getVersion())) suitableMods.add(m);
+						}
+					}
+				}
+
+				if (suitableMods.isEmpty() && !depDisableSim) continue;
+
+				switch (dep.getKind()) {
+				case DEPENDS:
+					if (depDisableSim) {
+						suitableMods.add(getCreateDisableDepVar(dep, disabledDeps));
+					}
+
+					dependencyHelper.clause(new Explanation(ErrorKind.PRESELECT_HARD_DEP, mod, dep), suitableMods.toArray(new DomainObject[0]));
+					break;
+				case RECOMMENDS:
+					// this will prioritize greedy over non-greedy loaded mods, regardless of modPrioComparator due to the objective weights
+
+					// only pull IF_RECOMMENDED or encompassing in
+					suitableMods.removeIf(m -> ((ModCandidate) m).getLoadCondition().ordinal() > ModLoadCondition.IF_RECOMMENDED.ordinal());
+
+					if (!suitableMods.isEmpty()) {
+						suitableMods.add(getCreateDummy(dep.getModId(), OptionalDepVar::new, dummyMods, priorities.size(), weightedObjects));
+						dependencyHelper.clause(new Explanation(ErrorKind.PRESELECT_SOFT_DEP, mod, dep), suitableMods.toArray(new DomainObject[0]));
+					}
+
+					break;
+				case BREAKS:
+					if (depDisableSim) {
+						dependencyHelper.setTrue(getCreateDisableDepVar(dep, disabledDeps), new Explanation(ErrorKind.PRESELECT_NEG_HARD_DEP, mod, dep));
+					} else {
+						for (DomainObject match : suitableMods) {
+							dependencyHelper.setFalse(match, new Explanation(ErrorKind.PRESELECT_NEG_HARD_DEP, mod, dep));
+						}
+					}
+
+					break;
+				case CONFLICTS:
+					// TODO: soft negative dep?
+					break;
+				default:
+					// ignore
+				}
+
+				suitableMods.clear();
+			}
+
+			if (removalSim) {
+				int prio = priorities.size() + 10;
+
+				if (installableMods != null) {
+					prio += installableMods.getOrDefault(mod.getId(), Collections.emptyList()).size();
+
+					List<AddModVar> installable = installableMods.get(mod.getId());
+					if (installable != null) suitableMods.addAll(installable);
+				}
+
+				suitableMods.add(getCreateDummy(mod.getId(), RemoveModVar::new, dummyMods, prio, weightedObjects));
+				suitableMods.add(mod);
+
+				dependencyHelper.clause(new Explanation(ErrorKind.PRESELECT_FORCELOAD, mod.getId()), suitableMods.toArray(new DomainObject[0]));
+				suitableMods.clear();
+			}
+		}
+	}
+
+	private static void generateMainConstraints(List<ModCandidate> allModsSorted, Map<String, List<ModCandidate>> modsById,
+			Map<ModCandidate, Integer> priorities, Map<String, ModCandidate> selectedMods,
+			boolean depDisableSim, Map<String, List<AddModVar>> installableMods, boolean removalSim,
+			Map<String, DomainObject> dummyMods, Map<ModDependency, Map.Entry<DomainObject, Integer>> disabledDeps,
+			DependencyHelper<DomainObject, Explanation> dependencyHelper, List<WeightedObject<DomainObject>> weightedObjects) throws ContradictionException {
+		boolean enableOptional = !depDisableSim && installableMods == null && !removalSim; // whether to enable optional mods (regular solve only, not for failure handling)
+		List<DomainObject> suitableMods = new ArrayList<>();
+
+		for (ModCandidate mod : allModsSorted) {
+			// add constraints for dependencies
+
+			for (ModDependency dep : mod.getDependencies()) {
+				if (!enableOptional && dep.getKind().isSoft()) continue;
+
+				ModCandidate selectedMod = selectedMods.get(dep.getModId());
+
+				if (selectedMod != null) { // dep is already selected = present
+					if (!removalSim) {
+						if (!dep.getKind().isSoft() // .. and is a hard dep
+								&& dep.matches(selectedMod.getVersion()) != dep.getKind().isPositive()) { // ..but isn't suitable (DEPENDS without match or BREAKS with match)
+							if (depDisableSim) {
+								dependencyHelper.setTrue(getCreateDisableDepVar(dep, disabledDeps), new Explanation(ErrorKind.HARD_DEP, mod, dep));
+							} else {
+								dependencyHelper.setFalse(mod, new Explanation(ErrorKind.HARD_DEP_INCOMPATIBLE_PRESELECTED, mod, dep));
+							}
+						}
+
+						continue;
+					} else if (dep.matches(selectedMod.getVersion())) {
+						suitableMods.add(selectedMod);
+					}
+				}
+
+				List<? extends DomainObject.Mod> availableMods = modsById.get(dep.getModId());
+
+				if (availableMods != null) {
+					for (DomainObject.Mod m : availableMods) {
+						if (dep.matches(m.getVersion())) suitableMods.add(m);
+					}
+				}
+
+				if (installableMods != null) {
+					availableMods = installableMods.get(dep.getModId());
+
+					if (availableMods != null) {
+						for (DomainObject.Mod m : availableMods) {
+							if (dep.matches(m.getVersion())) suitableMods.add(m);
+						}
+					}
+				}
+
+				switch (dep.getKind()) {
+				case DEPENDS: // strong dep
+					if (depDisableSim) {
+						suitableMods.add(getCreateDisableDepVar(dep, disabledDeps));
+					}
+
+					if (suitableMods.isEmpty()) {
+						dependencyHelper.setFalse(mod, new Explanation(ErrorKind.HARD_DEP_NO_CANDIDATE, mod, dep));
+					} else {
+						dependencyHelper.implication(mod).implies(suitableMods.toArray(new DomainObject[0])).named(new Explanation(ErrorKind.HARD_DEP, mod, dep));
+					}
+
+					break;
+				case RECOMMENDS: // soft dep
+					// this will prioritize greedy over non-greedy loaded mods, regardless of modPrioComparator due to the objective weights
+
+					// only pull IF_RECOMMENDED or encompassing in
+					suitableMods.removeIf(m -> ((ModCandidate) m).getLoadCondition().ordinal() > ModLoadCondition.IF_RECOMMENDED.ordinal());
+
+					if (!suitableMods.isEmpty()) {
+						suitableMods.add(getCreateDummy(dep.getModId(), OptionalDepVar::new, dummyMods, priorities.size(), weightedObjects));
+						dependencyHelper.implication(mod).implies(suitableMods.toArray(new DomainObject[0])).named(new Explanation(ErrorKind.SOFT_DEP, mod, dep));
+					}
+
+					break;
+				case BREAKS: // strong negative dep
+					if (!suitableMods.isEmpty()) {
+						if (depDisableSim) {
+							DomainObject var = getCreateDisableDepVar(dep, disabledDeps);
+
+							for (DomainObject match : suitableMods) {
+								dependencyHelper.implication(mod).implies(new NegatedDomainObject(match), var).named(new Explanation(ErrorKind.NEG_HARD_DEP, mod, dep));
+							}
+						} else {
+							for (DomainObject match : suitableMods) {
+								dependencyHelper.implication(mod).impliesNot(match).named(new Explanation(ErrorKind.NEG_HARD_DEP, mod, dep));
+							}
+						}
+					}
+
+					break;
+				case CONFLICTS:
+					// TODO: soft negative dep?
+					break;
+				default:
+					// ignore
+				}
+
+				suitableMods.clear();
+			}
+
+			// add constraints to select greedy nested mods (ALWAYS or IF_POSSIBLE)
+			// add constraints to restrict nested mods to selected parents
+
+			if (!mod.isRoot()) { // nested mod
+				ModLoadCondition loadCondition = mod.getLoadCondition();
+
+				if (loadCondition == ModLoadCondition.ALWAYS) { // required with parent
+					Explanation explanation = new Explanation(ErrorKind.NESTED_FORCELOAD, mod.getParentMods().iterator().next(), mod.getId()); // FIXME: this applies to all parents
+					DomainObject[] siblings = modsById.get(mod.getId()).toArray(new DomainObject[0]);
+
+					if (isAnyParentSelected(mod, selectedMods)) {
+						dependencyHelper.clause(explanation, siblings);
+					} else {
+						for (ModCandidate parent : mod.getParentMods()) {
+							dependencyHelper.implication(parent).implies(siblings).named(explanation);
+						}
+					}
+				}
+
+				// require parent to be selected with the nested mod
+
+				if (!isAnyParentSelected(mod, selectedMods)) {
+					dependencyHelper.implication(mod).implies(mod.getParentMods().toArray(new DomainObject[0])).named(new Explanation(ErrorKind.NESTED_REQ_PARENT, mod));
+				}
+			}
+
+			// add weights if potentially needed (choice between multiple mods or dummies)
+
+			if (!mod.isRoot() || mod.getLoadCondition() != ModLoadCondition.ALWAYS || modsById.get(mod.getId()).size() > 1) {
+				int prio = priorities.get(mod);
+				BigInteger weight;
+
+				if (mod.getLoadCondition().ordinal() >= ModLoadCondition.IF_RECOMMENDED.ordinal()) { // non-greedy (optional)
+					weight = TWO.pow(prio + 1);
+				} else { // greedy
+					weight = TWO.pow(allModsSorted.size() - prio).negate();
+				}
+
+				weightedObjects.add(WeightedObject.newWO(mod, weight));
+			}
+		}
+
+		// add constraints to force-load root mods (ALWAYS only, IF_POSSIBLE is being handled through negative weight later)
+		// add single mod per id constraints
+
+		for (List<ModCandidate> variants : modsById.values()) {
+			ModCandidate firstMod = variants.get(0);
+			String id = firstMod.getId();
+
+			// force-load root mod
+
+			if (variants.size() == 1 && !removalSim) { // trivial case, others are handled by multi-variant impl
+				if (firstMod.isRoot() && firstMod.getLoadCondition() == ModLoadCondition.ALWAYS) {
+					dependencyHelper.setTrue(firstMod, new Explanation(ErrorKind.ROOT_FORCELOAD_SINGLE, firstMod));
+				}
+			} else { // complex case, potentially multiple variants
+				boolean isRequired = false;
+
+				for (ModCandidate mod : variants) {
+					if (mod.isRoot() && mod.getLoadCondition() == ModLoadCondition.ALWAYS) {
+						isRequired = true;
+						break;
+					}
+				}
+
+				if (isRequired) {
+					if (removalSim) {
+						int prio = priorities.size() + 10;
+						if (installableMods != null) prio += installableMods.getOrDefault(id, Collections.emptyList()).size();
+
+						suitableMods.add(getCreateDummy(id, RemoveModVar::new, dummyMods, prio, weightedObjects));
+					}
+
+					if (installableMods != null) {
+						List<AddModVar> installable = installableMods.get(id);
+						if (installable != null) suitableMods.addAll(installable);
+					}
+
+					suitableMods.addAll(variants);
+
+					dependencyHelper.clause(new Explanation(ErrorKind.ROOT_FORCELOAD, id), suitableMods.toArray(new DomainObject[0]));
+					suitableMods.clear();
+				}
+			}
+
+			// single mod per id constraint
+
+			suitableMods.addAll(variants);
+
+			if (installableMods != null) {
+				List<AddModVar> installable = installableMods.get(id);
+
+				if (installable != null && !installable.isEmpty()) {
+					suitableMods.addAll(installable);
+
+					ModCandidate mod = selectedMods.get(id);
+					if (mod != null) suitableMods.add(mod);
+				}
+			}
+
+			if (suitableMods.size() > 1 // multiple options
+					|| enableOptional && firstMod.getLoadCondition() == ModLoadCondition.IF_POSSIBLE) { // optional greedy loading
+				dependencyHelper.atMost(1, suitableMods.toArray(new DomainObject[0])).named(new Explanation(ErrorKind.UNIQUE_ID, id));
+			}
+
+			suitableMods.clear();
+		}
+
+		// add weights and missing unique id constraints for installable mods
+
+		if (installableMods != null) {
+			for (List<AddModVar> variants : installableMods.values()) {
+				String id = variants.get(0).getId();
+				boolean isReplacement = modsById.containsKey(id);
+
+				if (!isReplacement) { // no single mod per id constraint created yet
+					suitableMods.addAll(variants);
+
+					ModCandidate selectedMod = selectedMods.get(id);
+					if (selectedMod != null) suitableMods.add(selectedMod);
+
+					if (suitableMods.size() > 1) {
+						dependencyHelper.atMost(1, suitableMods.toArray(new DomainObject[0])).named(new Explanation(ErrorKind.UNIQUE_ID, id));
+					}
+
+					suitableMods.clear();
+				}
+
+				for (int i = 0; i < variants.size(); i++) {
+					AddModVar mod = variants.get(i);
+					int weight = priorities.size() + 4 + i;
+					if (isReplacement) weight += 3;
+					if (mod.hadOnlyOutboundDepFailures) weight++;
+
+					weightedObjects.add(WeightedObject.newWO(mod, TWO.pow(weight)));
+				}
+			}
+		}
+	}
+
+	private static final BigInteger TWO = BigInteger.valueOf(2);
+
+	private static DependencyHelper<DomainObject, Explanation> createDepHelper(IPBSolver solver) {
+		DependencyHelper<DomainObject, Explanation> ret = new DependencyHelper<>(solver); // new LexicoHelper<>(solver)
+		ret.setNegator(negator);
+
+		return ret;
+	}
+
+	private static DomainObject getCreateDummy(String id, Function<String, DomainObject> supplier, Map<String, DomainObject> duplicateMap, int modCount, List<WeightedObject<DomainObject>> weightedObjects) {
+		DomainObject ret = duplicateMap.get(id);
+		if (ret != null) return ret;
+
+		ret = supplier.apply(id);
+		int weight = modCount + 2;
+		weightedObjects.add(WeightedObject.newWO(ret, TWO.pow(weight)));
+
+		return ret;
+	}
+
+	private static DomainObject getCreateDisableDepVar(ModDependency dep, Map<ModDependency, Map.Entry<DomainObject, Integer>> duplicateMap) {
+		Map.Entry<DomainObject, Integer> entry = duplicateMap.computeIfAbsent(dep, d -> new AbstractMap.SimpleEntry<>(new DisableDepVar(d), 0));
+		entry.setValue(entry.getValue() + 1);
+
+		return entry.getKey();
+	}
+
+	private static void applyDisableDepVarWeights(Map<ModDependency, Map.Entry<DomainObject, Integer>> map, int modCount, List<WeightedObject<DomainObject>> weightedObjects) {
+		BigInteger baseWeight = TWO.pow(modCount + 3);
+
+		for (Map.Entry<DomainObject, Integer> entry : map.values()) {
+			int count = entry.getValue();
+			weightedObjects.add(WeightedObject.newWO(entry.getKey(), count > 1 ? baseWeight.multiply(BigInteger.valueOf(count)) : baseWeight));
+		}
+	}
+
+	private static final class OptionalDepVar implements DomainObject {
+		private final String id;
+
+		OptionalDepVar(String id) {
+			this.id = id;
+		}
+
+		@Override
+		public String getId() {
+			return id;
+		}
+
+		@Override
+		public String toString() {
+			return "optionalDep:"+getId();
+		}
+	}
+
+	private static final class DisableDepVar implements DomainObject {
+		final ModDependency dep;
+
+		DisableDepVar(ModDependency dep) {
+			this.dep = dep;
+		}
+
+		@Override
+		public String getId() {
+			return dep.getModId();
+		}
+
+		@Override
+		public String toString() {
+			return "disableDep:"+dep;
+		}
+	}
+
+	static final class AddModVar implements DomainObject.Mod {
+		private final String id;
+		private final Version version;
+		final boolean hadOnlyOutboundDepFailures;
+		private List<VersionInterval> versionIntervals;
+
+		AddModVar(String id, Version version, boolean hadOnlyOutboundDepFailures) {
+			this.id = id;
+			this.version = version;
+			this.hadOnlyOutboundDepFailures = hadOnlyOutboundDepFailures;
+		}
+
+		@Override
+		public String getId() {
+			return id;
+		}
+
+		@Override
+		public Version getVersion() {
+			return version;
+		}
+
+		public List<VersionInterval> getVersionIntervals() {
+			return versionIntervals;
+		}
+
+		void setVersionIntervals(List<VersionInterval> versionIntervals) {
+			this.versionIntervals = versionIntervals;
+		}
+
+		@Override
+		public String toString() {
+			return String.format("add:%s %s (%s)", id, version, versionIntervals);
+		}
+	}
+
+	private static final class RemoveModVar implements DomainObject {
+		private final String id;
+
+		RemoveModVar(String id) {
+			this.id = id;
+		}
+
+		@Override
+		public String getId() {
+			return id;
+		}
+
+		@Override
+		public String toString() {
+			return "remove:"+getId();
+		}
+	}
+
+	private static final class NegatedDomainObject implements DomainObject {
+		private final DomainObject obj;
+
+		NegatedDomainObject(DomainObject obj) {
+			this.obj = obj;
+		}
+
+		@Override
+		public String getId() {
+			return obj.getId();
+		}
+
+		@Override
+		public String toString() {
+			return "!"+obj;
+		}
+	}
+
+	private static final INegator negator = new INegator() {
+		@Override
+		public Object unNegate(Object thing) {
+			return ((NegatedDomainObject) thing).obj;
+		}
+
+		@Override
+		public boolean isNegated(Object thing) {
+			return thing instanceof NegatedDomainObject;
+		}
+	};
+
+	static boolean isAnyParentSelected(ModCandidate mod, Map<String, ModCandidate> selectedMods) {
+		for (ModCandidate parentMod : mod.getParentMods()) {
+			if (selectedMods.get(parentMod.getId()) == parentMod) return true;
+		}
+
+		return false;
+	}
+
+	static boolean hasAllDepsSatisfied(ModCandidate mod, Map<String, ModCandidate> mods) {
+		for (ModDependency dep : mod.getDependencies()) {
+			if (dep.getKind() == ModDependency.Kind.DEPENDS) {
+				ModCandidate m = mods.get(dep.getModId());
+				if (m == null || !dep.matches(m.getVersion())) return false;
+			} else if (dep.getKind() == ModDependency.Kind.BREAKS) {
+				ModCandidate m = mods.get(dep.getModId());
+				if (m != null && dep.matches(m.getVersion())) return false;
+			}
+		}
+
+		return true;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/ResultAnalyzer.java b/src/main/java/net/fabricmc/loader/impl/discovery/ResultAnalyzer.java
new file mode 100644
index 0000000000000000000000000000000000000000..7772bb6b6c9073ab5e331247dfc972a878cb8587
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/ResultAnalyzer.java
@@ -0,0 +1,527 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.metadata.ModDependency;
+import net.fabricmc.loader.api.metadata.version.VersionInterval;
+import net.fabricmc.loader.impl.discovery.ModSolver.AddModVar;
+import net.fabricmc.loader.impl.discovery.ModSolver.InactiveReason;
+import net.fabricmc.loader.impl.metadata.AbstractModMetadata;
+import net.fabricmc.loader.impl.util.Localization;
+import net.fabricmc.loader.impl.util.StringUtil;
+import net.fabricmc.loader.impl.util.version.VersionIntervalImpl;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.*;
+import java.util.Map.Entry;
+import java.util.stream.Collectors;
+
+final class ResultAnalyzer {
+	private static final boolean SHOW_PATH_INFO = false;
+	private static final boolean SHOW_INACTIVE = false;
+
+	@SuppressWarnings("unused")
+	static String gatherErrors(ModSolver.Result result, Map<String, ModCandidate> selectedMods, Map<String, List<ModCandidate>> modsById,
+			Map<String, Set<ModCandidate>> envDisabledMods, EnvType envType) {
+		StringWriter sw = new StringWriter();
+
+		try (PrintWriter pw = new PrintWriter(sw)) {
+			String prefix = "";
+			boolean suggestFix = true;
+
+			if (result.fix != null) {
+				pw.printf("\n%s", Localization.format("resolution.solutionHeader"));
+
+				formatFix(result.fix, result, selectedMods, modsById, envDisabledMods, envType, pw);
+
+				pw.printf("\n%s", Localization.format("resolution.depListHeader"));
+				prefix = "\t";
+				suggestFix = false;
+			}
+
+			List<ModCandidate> matches = new ArrayList<>();
+
+			for (Explanation explanation : result.reason) {
+				assert explanation.error.isDependencyError;
+
+				ModDependency dep = explanation.dep;
+				ModCandidate selected = selectedMods.get(dep.getModId());
+
+				if (selected != null) {
+					matches.add(selected);
+				} else {
+					List<ModCandidate> candidates = modsById.get(dep.getModId());
+					if (candidates != null) matches.addAll(candidates);
+				}
+
+				addErrorToList(explanation.mod, explanation.dep, matches, envDisabledMods.containsKey(dep.getModId()), suggestFix, prefix, pw);
+				matches.clear();
+			}
+
+			if (SHOW_INACTIVE && result.fix != null && !result.fix.inactiveMods.isEmpty()) {
+				pw.printf("\n%s", Localization.format("resolution.inactiveMods"));
+
+				List<Entry<ModCandidate, InactiveReason>> entries = new ArrayList<>(result.fix.inactiveMods.entrySet());
+
+				// sort by root, id, version
+				entries.sort(new Comparator<Entry<ModCandidate, ?>>() {
+					@Override
+					public int compare(Entry<ModCandidate, ?> o1, Entry<ModCandidate, ?> o2) {
+						ModCandidate a = o1.getKey();
+						ModCandidate b = o2.getKey();
+
+						if (a.isRoot() != b.isRoot()) {
+							return a.isRoot() ? -1 : 1;
+						}
+
+						return ModCandidate.ID_VERSION_COMPARATOR.compare(a, b);
+					}
+				});
+
+				for (Entry<ModCandidate, InactiveReason> entry : entries) {
+					ModCandidate mod = entry.getKey();
+					InactiveReason reason = entry.getValue();
+					String reasonKey = String.format("resolution.inactive.%s", reason.id);
+
+					pw.printf("\n\t - %s", Localization.format("resolution.inactive",
+							getName(mod),
+							getVersion(mod),
+							Localization.format(reasonKey)));
+					//appendJijInfo(mod, "\t", false, pw); TODO: show this without spamming too much
+				}
+			}
+		}
+
+		return sw.toString();
+	}
+
+	private static void formatFix(ModSolver.Fix fix,
+			ModSolver.Result result, Map<String, ModCandidate> selectedMods, Map<String, List<ModCandidate>> modsById,
+			Map<String, Set<ModCandidate>> envDisabledMods, EnvType envType,
+			PrintWriter pw) {
+		for (AddModVar mod : fix.modsToAdd) {
+			Set<ModCandidate> envDisabledAlternatives = envDisabledMods.get(mod.getId());
+
+			if (envDisabledAlternatives == null) {
+				pw.printf("\n\t - %s", Localization.format("resolution.solution.addMod",
+						mod.getId(),
+						formatVersionRequirements(mod.getVersionIntervals())));
+			} else {
+				String envKey = String.format("environment.%s", envType.name().toLowerCase(Locale.ENGLISH));
+
+				pw.printf("\n\t - %s", Localization.format("resolution.solution.replaceModEnvDisabled",
+						formatOldMods(envDisabledAlternatives),
+						mod.getId(),
+						formatVersionRequirements(mod.getVersionIntervals()),
+						Localization.format(envKey)));
+			}
+		}
+
+		for (ModCandidate mod : fix.modsToRemove) {
+			pw.printf("\n\t - %s", Localization.format("resolution.solution.removeMod", getName(mod), getVersion(mod), mod.getLocalPath()));
+		}
+
+		for (Entry<AddModVar, List<ModCandidate>> entry : fix.modReplacements.entrySet()) {
+			AddModVar newMod = entry.getKey();
+			List<ModCandidate> oldMods = entry.getValue();
+			String oldModsFormatted = formatOldMods(oldMods);
+
+			if (oldMods.size() != 1 || !oldMods.get(0).getId().equals(newMod.getId())) { // replace mods with another mod (different mod id)
+				String newModName = newMod.getId();
+				ModCandidate alt = selectedMods.get(newMod.getId());
+
+				if (alt != null) {
+					newModName = getName(alt);
+				} else {
+					List<ModCandidate> alts = modsById.get(newMod.getId());
+					if (alts != null && !alts.isEmpty()) newModName = getName(alts.get(0));
+				}
+
+				pw.printf("\n\t - %s", Localization.format("resolution.solution.replaceMod",
+						oldModsFormatted,
+						newModName,
+						formatVersionRequirements(newMod.getVersionIntervals())));
+			} else { // replace mod version only
+				ModCandidate oldMod = oldMods.get(0);
+				boolean hasOverlap = !VersionInterval.and(newMod.getVersionIntervals(),
+						Collections.singletonList(new VersionIntervalImpl(oldMod.getVersion(), true, oldMod.getVersion(), true))).isEmpty();
+
+				if (!hasOverlap) { // required version range doesn't overlap installed version, recommend range as-is
+					pw.printf("\n\t - %s", Localization.format("resolution.solution.replaceModVersion",
+							oldModsFormatted,
+							formatVersionRequirements(newMod.getVersionIntervals())));
+				} else { // required version range overlaps installed version, recommend range without
+					pw.printf("\n\t - %s", Localization.format("resolution.solution.replaceModVersionDifferent",
+							oldModsFormatted,
+							formatVersionRequirements(newMod.getVersionIntervals())));
+
+					boolean foundAny = false;
+
+					// check old deps against future mod set to highlight inconsistencies
+					for (ModDependency dep : oldMod.getDependencies()) {
+						if (dep.getKind().isSoft()) continue;
+
+						ModCandidate mod = fix.activeMods.get(dep.getModId());
+
+						if (mod != null) {
+							if (dep.matches(mod.getVersion()) != dep.getKind().isPositive()) {
+								pw.printf("\n\t\t - %s", Localization.format("resolution.solution.replaceModVersionDifferent.reqSupportedModVersion",
+										mod.getId(),
+										getVersion(mod)));
+								foundAny = true;
+							}
+
+							continue;
+						}
+
+						for (AddModVar addMod : fix.modReplacements.keySet()) {
+							if (addMod.getId().equals(dep.getModId())) {
+								pw.printf("\n\t\t - %s", Localization.format("resolution.solution.replaceModVersionDifferent.reqSupportedModVersions",
+										addMod.getId(),
+										formatVersionRequirements(addMod.getVersionIntervals())));
+								foundAny = true;
+								break;
+							}
+						}
+					}
+
+					if (!foundAny) {
+						pw.printf("\n\t\t - %s", Localization.format("resolution.solution.replaceModVersionDifferent.unknown"));
+					}
+				}
+			}
+		}
+	}
+
+	static String gatherWarnings(List<ModCandidate> uniqueSelectedMods, Map<String, ModCandidate> selectedMods,
+			Map<String, Set<ModCandidate>> envDisabledMods, EnvType envType) {
+		StringWriter sw = new StringWriter();
+
+		try (PrintWriter pw = new PrintWriter(sw)) {
+			for (ModCandidate mod : uniqueSelectedMods) {
+				for (ModDependency dep : mod.getDependencies()) {
+					ModCandidate depMod;
+
+					switch (dep.getKind()) {
+					case RECOMMENDS:
+						depMod = selectedMods.get(dep.getModId());
+
+						if (depMod == null || !dep.matches(depMod.getVersion())) {
+							addErrorToList(mod, dep, toList(depMod), envDisabledMods.containsKey(dep.getModId()), true, "", pw);
+						}
+
+						break;
+					case CONFLICTS:
+						depMod = selectedMods.get(dep.getModId());
+
+						if (depMod != null && dep.matches(depMod.getVersion())) {
+							addErrorToList(mod, dep, toList(depMod), false, true, "", pw);
+						}
+
+						break;
+					default:
+						// ignore
+					}
+				}
+			}
+		}
+
+		if (sw.getBuffer().length() == 0) {
+			return null;
+		} else {
+			return sw.toString();
+		}
+	}
+
+	private static List<ModCandidate> toList(ModCandidate mod) {
+		return mod != null ? Collections.singletonList(mod) : Collections.emptyList();
+	}
+
+	private static void addErrorToList(ModCandidate mod, ModDependency dep, List<ModCandidate> matches, boolean presentForOtherEnv, boolean suggestFix, String prefix, PrintWriter pw) {
+		Object[] args = new Object[] {
+				getName(mod),
+				getVersion(mod),
+				(matches.isEmpty() ? dep.getModId() : getName(matches.get(0))),
+				formatVersionRequirements(dep.getVersionIntervals()),
+				getVersions(matches),
+				matches.size()
+		};
+
+		String reason;
+
+		if (!matches.isEmpty()) {
+			boolean present;
+
+			if (dep.getKind().isPositive()) {
+				present = false;
+
+				for (ModCandidate match : matches) {
+					if (dep.matches(match.getVersion())) { // there is a satisfying mod version, but it can't be loaded for other reasons
+						present = true;
+						break;
+					}
+				}
+			} else {
+				present = true;
+			}
+
+			reason = present ? "invalid" : "mismatch";
+		} else if (presentForOtherEnv && dep.getKind().isPositive()) {
+			reason = "envDisabled";
+		} else {
+			reason = "missing";
+		}
+
+		String key = String.format("resolution.%s.%s", dep.getKind().getKey(), reason);
+		pw.printf("\n%s - %s", prefix, StringUtil.capitalize(Localization.format(key, args)));
+
+		if (suggestFix) {
+			key = String.format("resolution.%s.suggestion", dep.getKind().getKey());
+			pw.printf("\n%s\t - %s", prefix, StringUtil.capitalize(Localization.format(key, args)));
+		}
+
+		if (SHOW_PATH_INFO) {
+			for (ModCandidate m : matches) {
+				appendJijInfo(m, prefix, true, pw);
+			}
+		}
+	}
+
+	private static void appendJijInfo(ModCandidate mod, String prefix, boolean mentionMod, PrintWriter pw) {
+		String loc;
+		String path;
+
+		if (mod.getMetadata().getType().equals(AbstractModMetadata.TYPE_BUILTIN)) {
+			loc = "builtin";
+			path = null;
+		} else if (mod.isRoot()) {
+			loc = "root";
+			path = mod.getLocalPath();
+		} else {
+			loc = "normal";
+
+			List<ModCandidate> paths = new ArrayList<>();
+			paths.add(mod);
+
+			ModCandidate cur = mod;
+
+			do {
+				ModCandidate best = null;
+				int maxDiff = 0;
+
+				for (ModCandidate parent : cur.getParentMods()) {
+					int diff = cur.getMinNestLevel() - parent.getMinNestLevel();
+
+					if (diff > maxDiff) {
+						best = parent;
+						maxDiff = diff;
+					}
+				}
+
+				if (best == null) break;
+
+				paths.add(best);
+				cur = best;
+			} while (!cur.isRoot());
+
+			StringBuilder pathSb = new StringBuilder();
+
+			for (int i = paths.size() - 1; i >= 0; i--) {
+				ModCandidate m = paths.get(i);
+
+				if (pathSb.length() > 0) pathSb.append(" -> ");
+				pathSb.append(m.getLocalPath());
+			}
+
+			path = pathSb.toString();
+		}
+
+		String key = String.format("resolution.jij.%s%s", loc, mentionMod ? "" : "NoMention");
+		String text;
+
+		if (mentionMod) {
+			if (path == null) {
+				text = Localization.format(key, getName(mod), getVersion(mod));
+			} else {
+				text = Localization.format(key, getName(mod), getVersion(mod), path);
+			}
+		} else {
+			if (path == null) {
+				text = Localization.format(key);
+			} else {
+				text = Localization.format(key, path);
+			}
+		}
+
+		pw.printf("\n%s\t - %s",
+				prefix,
+				StringUtil.capitalize(text));
+	}
+
+	@SuppressWarnings("unused")
+	private static String formatOldMods(Collection<ModCandidate> mods) {
+		List<ModCandidate> modsSorted = new ArrayList<>(mods);
+		modsSorted.sort(ModCandidate.ID_VERSION_COMPARATOR);
+		List<String> ret = new ArrayList<>(modsSorted.size());
+
+		for (ModCandidate m : modsSorted) {
+			if (SHOW_PATH_INFO && m.hasPath() && !m.isBuiltin()) {
+				ret.add(Localization.format("resolution.solution.replaceMod.oldMod", getName(m), getVersion(m), m.getLocalPath()));
+			} else {
+				ret.add(Localization.format("resolution.solution.replaceMod.oldModNoPath", getName(m), getVersion(m)));
+			}
+		}
+
+		return formatEnumeration(ret, true);
+	}
+
+	private static String getName(ModCandidate candidate) {
+		String typePrefix;
+
+		switch (candidate.getMetadata().getType()) {
+		case AbstractModMetadata.TYPE_FABRIC_MOD:
+			typePrefix = String.format("%s ", Localization.format("resolution.type.mod"));
+			break;
+		case AbstractModMetadata.TYPE_BUILTIN:
+		default:
+			typePrefix = "";
+		}
+
+		return String.format("%s'%s' (%s)", typePrefix, candidate.getMetadata().getName(), candidate.getId());
+	}
+
+	private static String getVersion(ModCandidate candidate) {
+		return candidate.getVersion().getFriendlyString();
+	}
+
+	private static String getVersions(Collection<ModCandidate> candidates) {
+		return candidates.stream().map(ResultAnalyzer::getVersion).collect(Collectors.joining("/"));
+	}
+
+	private static String formatVersionRequirements(Collection<VersionInterval> intervals) {
+		List<String> ret = new ArrayList<>();
+
+		for (VersionInterval interval : intervals) {
+			String str;
+
+			if (interval == null) {
+				// empty interval, skip
+				continue;
+			} else if (interval.getMin() == null) {
+				if (interval.getMax() == null) {
+					return Localization.format("resolution.version.any");
+				} else if (interval.isMaxInclusive()) {
+					str = Localization.format("resolution.version.lessEqual", interval.getMax());
+				} else {
+					str = Localization.format("resolution.version.less", interval.getMax());
+				}
+			} else if (interval.getMax() == null) {
+				if (interval.isMinInclusive()) {
+					str = Localization.format("resolution.version.greaterEqual", interval.getMin());
+				} else {
+					str = Localization.format("resolution.version.greater", interval.getMin());
+				}
+			} else if (interval.getMin().equals(interval.getMax())) {
+				if (interval.isMinInclusive() && interval.isMaxInclusive()) {
+					str = Localization.format("resolution.version.equal", interval.getMin());
+				} else {
+					// empty interval, skip
+					continue;
+				}
+			} else if (isWildcard(interval, 0)) { // major.x wildcard
+				SemanticVersion version = (SemanticVersion) interval.getMin();
+				str = Localization.format("resolution.version.major", version.getVersionComponent(0));
+			} else if (isWildcard(interval, 1)) { // major.minor.x wildcard
+				SemanticVersion version = (SemanticVersion) interval.getMin();
+				str = Localization.format("resolution.version.majorMinor", version.getVersionComponent(0), version.getVersionComponent(1));
+			} else {
+				String key = String.format("resolution.version.rangeMin%sMax%s",
+						(interval.isMinInclusive() ? "Inc" : "Exc"),
+						(interval.isMaxInclusive() ? "Inc" : "Exc"));
+				str = Localization.format(key, interval.getMin(), interval.getMax());
+			}
+
+			ret.add(str);
+		}
+
+		if (ret.isEmpty()) {
+			return Localization.format("resolution.version.none");
+		} else {
+			return formatEnumeration(ret, false);
+		}
+	}
+
+	/**
+	 * Determine whether an interval can be represented by a .x wildcard version string.
+	 *
+	 * <p>Example: [1.2.0-,1.3.0-) is the same as 1.2.x (incrementedComponent=1)
+	 */
+	private static boolean isWildcard(VersionInterval interval, int incrementedComponent) {
+		if (interval == null || interval.getMin() == null || interval.getMax() == null // not an interval with lower+upper bounds
+				|| !interval.isMinInclusive() || interval.isMaxInclusive() // not an [a,b) interval
+				|| !interval.isSemantic()) {
+			return false;
+		}
+
+		SemanticVersion min = (SemanticVersion) interval.getMin();
+		SemanticVersion max = (SemanticVersion) interval.getMax();
+
+		// min and max need to use the empty prerelease (a.b.c-)
+		if (!"".equals(min.getPrereleaseKey().orElse(null))
+				|| !"".equals(max.getPrereleaseKey().orElse(null))) {
+			return false;
+		}
+
+		// max needs to be min + 1 for the covered component
+		if (max.getVersionComponent(incrementedComponent) != min.getVersionComponent(incrementedComponent) + 1) {
+			return false;
+		}
+
+		for (int i = incrementedComponent + 1, m = Math.max(min.getVersionComponentCount(), max.getVersionComponentCount()); i < m; i++) {
+			// all following components need to be 0
+			if (min.getVersionComponent(i) != 0 || max.getVersionComponent(i) != 0) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	private static String formatEnumeration(Collection<?> elements, boolean isAnd) {
+		String keyPrefix = isAnd ? "enumerationAnd." : "enumerationOr.";
+		Iterator<?> it = elements.iterator();
+
+		switch (elements.size()) {
+		case 0: return "";
+		case 1: return Objects.toString(it.next());
+		case 2: return Localization.format(keyPrefix+"2", it.next(), it.next());
+		case 3: return Localization.format(keyPrefix+"3", it.next(), it.next(), it.next());
+		}
+
+		String ret = Localization.format(keyPrefix+"nPrefix", it.next());
+
+		do {
+			Object next = it.next();
+			ret = Localization.format(it.hasNext() ? keyPrefix+"n" : keyPrefix+"nSuffix", ret, next);
+		} while (it.hasNext());
+
+		return ret;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/discovery/RuntimeModRemapper.java b/src/main/java/net/fabricmc/loader/impl/discovery/RuntimeModRemapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..131856270ac247e6d45a26902307be3b44110a61
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/discovery/RuntimeModRemapper.java
@@ -0,0 +1,210 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.discovery;
+
+import net.fabricmc.accesswidener.AccessWidenerReader;
+import net.fabricmc.accesswidener.AccessWidenerRemapper;
+import net.fabricmc.accesswidener.AccessWidenerWriter;
+import net.fabricmc.loader.impl.FormattedException;
+import net.fabricmc.loader.impl.launch.FabricLauncher;
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import net.fabricmc.loader.impl.util.FileSystemUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import net.fabricmc.loader.impl.util.mappings.TinyRemapperMappingsHelper;
+import net.fabricmc.tinyremapper.InputTag;
+import net.fabricmc.tinyremapper.NonClassCopyMode;
+import net.fabricmc.tinyremapper.OutputConsumerPath;
+import net.fabricmc.tinyremapper.TinyRemapper;
+import org.objectweb.asm.commons.Remapper;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.FileSystem;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.stream.Collectors;
+
+public final class RuntimeModRemapper {
+	public static void remap(Collection<ModCandidate> modCandidates, Path tmpDir, Path outputDir) {
+		List<ModCandidate> modsToRemap = new ArrayList<>();
+
+		for (ModCandidate mod : modCandidates) {
+			if (mod.getRequiresRemap()) {
+				modsToRemap.add(mod);
+			}
+		}
+
+		if (modsToRemap.isEmpty()) return;
+
+		FabricLauncher launcher = FabricLauncherBase.getLauncher();
+
+		TinyRemapper remapper = TinyRemapper.newRemapper()
+				.withMappings(TinyRemapperMappingsHelper.create(launcher.getMappingConfiguration().getMappings(), "intermediary", launcher.getTargetNamespace()))
+				.renameInvalidLocals(false)
+				.build();
+
+		try {
+			remapper.readClassPathAsync(getRemapClasspath().toArray(new Path[0]));
+		} catch (IOException e) {
+			throw new RuntimeException("Failed to populate remap classpath", e);
+		}
+
+		Map<ModCandidate, RemapInfo> infoMap = new HashMap<>();
+
+		try {
+			for (ModCandidate mod : modsToRemap) {
+				RemapInfo info = new RemapInfo();
+				infoMap.put(mod, info);
+
+				InputTag tag = remapper.createInputTag();
+				info.tag = tag;
+
+				if (mod.hasPath()) {
+					List<Path> paths = mod.getPaths();
+					if (paths.size() != 1) throw new UnsupportedOperationException("multiple path for "+mod);
+
+					info.inputPath = paths.get(0);
+				} else {
+					info.inputPath = mod.copyToDir(tmpDir, true);
+					info.inputIsTemp = true;
+				}
+
+				info.outputPath = outputDir.resolve(mod.getDefaultFileName());
+				Files.deleteIfExists(info.outputPath);
+
+				remapper.readInputsAsync(tag, info.inputPath);
+			}
+
+			//Done in a 2nd loop as we need to make sure all the inputs are present before remapping
+			for (ModCandidate mod : modsToRemap) {
+				RemapInfo info = infoMap.get(mod);
+				OutputConsumerPath outputConsumer = new OutputConsumerPath.Builder(info.outputPath).build();
+
+				FileSystemUtil.FileSystemDelegate delegate = FileSystemUtil.getJarFileSystem(info.inputPath, false);
+
+				if (delegate.get() == null) {
+					throw new RuntimeException("Could not open JAR file " + info.inputPath.getFileName() + " for NIO reading!");
+				}
+
+				Path inputJar = delegate.get().getRootDirectories().iterator().next();
+				outputConsumer.addNonClassFiles(inputJar, NonClassCopyMode.FIX_META_INF, remapper);
+
+				info.outputConsumerPath = outputConsumer;
+
+				remapper.apply(outputConsumer, info.tag);
+			}
+
+			//Done in a 3rd loop as this can happen when the remapper is doing its thing.
+			for (ModCandidate mod : modsToRemap) {
+				RemapInfo info = infoMap.get(mod);
+
+				String accessWidener = mod.getMetadata().getAccessWidener();
+
+				if (accessWidener != null) {
+					info.accessWidenerPath = accessWidener;
+
+					try (FileSystemUtil.FileSystemDelegate jarFs = FileSystemUtil.getJarFileSystem(info.inputPath, false)) {
+						FileSystem fs = jarFs.get();
+						info.accessWidener = remapAccessWidener(Files.readAllBytes(fs.getPath(accessWidener)), remapper.getRemapper());
+					} catch (Throwable t) {
+						throw new RuntimeException("Error remapping access widener for mod '"+mod.getId()+"'!", t);
+					}
+				}
+			}
+
+			remapper.finish();
+
+			for (ModCandidate mod : modsToRemap) {
+				RemapInfo info = infoMap.get(mod);
+
+				info.outputConsumerPath.close();
+
+				if (info.accessWidenerPath != null) {
+					try (FileSystemUtil.FileSystemDelegate jarFs = FileSystemUtil.getJarFileSystem(info.outputPath, false)) {
+						FileSystem fs = jarFs.get();
+
+						Files.delete(fs.getPath(info.accessWidenerPath));
+						Files.write(fs.getPath(info.accessWidenerPath), info.accessWidener);
+					}
+				}
+
+				mod.setPaths(Collections.singletonList(info.outputPath));
+			}
+		} catch (Throwable t) {
+			remapper.finish();
+
+			for (RemapInfo info : infoMap.values()) {
+				if (info.outputPath == null) {
+					continue;
+				}
+
+				try {
+					Files.deleteIfExists(info.outputPath);
+				} catch (IOException e) {
+					Log.warn(LogCategory.MOD_REMAP, "Error deleting failed output jar %s", info.outputPath, e);
+				}
+			}
+
+			throw new FormattedException("Failed to remap mods!", t);
+		} finally {
+			for (RemapInfo info : infoMap.values()) {
+				try {
+					if (info.inputIsTemp) Files.deleteIfExists(info.inputPath);
+				} catch (IOException e) {
+					Log.warn(LogCategory.MOD_REMAP, "Error deleting temporary input jar %s", info.inputIsTemp, e);
+				}
+			}
+		}
+	}
+
+	private static byte[] remapAccessWidener(byte[] input, Remapper remapper) {
+		AccessWidenerWriter writer = new AccessWidenerWriter();
+		AccessWidenerRemapper remappingDecorator = new AccessWidenerRemapper(writer, remapper, "intermediary", "named");
+		AccessWidenerReader accessWidenerReader = new AccessWidenerReader(remappingDecorator);
+		accessWidenerReader.read(input, "intermediary");
+		return writer.write();
+	}
+
+	private static List<Path> getRemapClasspath() throws IOException {
+		String remapClasspathFile = System.getProperty(SystemProperties.REMAP_CLASSPATH_FILE);
+
+		if (remapClasspathFile == null) {
+			throw new RuntimeException("No remapClasspathFile provided");
+		}
+
+		String content = new String(Files.readAllBytes(Paths.get(remapClasspathFile)), StandardCharsets.UTF_8);
+
+		return Arrays.stream(content.split(File.pathSeparator))
+				.map(Paths::get)
+				.collect(Collectors.toList());
+	}
+
+	private static class RemapInfo {
+		InputTag tag;
+		Path inputPath;
+		Path outputPath;
+		boolean inputIsTemp;
+		OutputConsumerPath outputConsumerPath;
+		String accessWidenerPath;
+		byte[] accessWidener;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/entrypoint/EntrypointContainerImpl.java b/src/main/java/net/fabricmc/loader/impl/entrypoint/EntrypointContainerImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..fc599a652f1a67672a8a1f3f959133bfe4c326e7
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/entrypoint/EntrypointContainerImpl.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.entrypoint;
+
+import net.fabricmc.loader.api.EntrypointException;
+import net.fabricmc.loader.api.ModContainer;
+import net.fabricmc.loader.api.entrypoint.EntrypointContainer;
+
+public final class EntrypointContainerImpl<T> implements EntrypointContainer<T> {
+	private final String key;
+	private final Class<T> type;
+	private final EntrypointStorage.Entry entry;
+	private T instance;
+
+	/**
+	 * Create EntrypointContainer with lazy init.
+	 */
+	public EntrypointContainerImpl(String key, Class<T> type, EntrypointStorage.Entry entry) {
+		this.key = key;
+		this.type = type;
+		this.entry = entry;
+	}
+
+	/**
+	 * Create EntrypointContainer without lazy init.
+	 */
+	public EntrypointContainerImpl(EntrypointStorage.Entry entry, T instance) {
+		this.key = null;
+		this.type = null;
+		this.entry = entry;
+		this.instance = instance;
+	}
+
+	@SuppressWarnings("deprecation")
+	@Override
+	public synchronized T getEntrypoint() {
+		if (instance == null) {
+			try {
+				instance = entry.getOrCreate(type);
+				assert instance != null;
+			} catch (Exception ex) {
+				throw new EntrypointException(key, getProvider().getMetadata().getId(), ex);
+			}
+		}
+
+		return instance;
+	}
+
+	@Override
+	public ModContainer getProvider() {
+		return entry.getModContainer();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/entrypoint/EntrypointStorage.java b/src/main/java/net/fabricmc/loader/impl/entrypoint/EntrypointStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..9cbc7da83ecf2281743c7f0a9e0d0ccdb12405fe
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/entrypoint/EntrypointStorage.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.entrypoint;
+
+import net.fabricmc.loader.api.EntrypointException;
+import net.fabricmc.loader.api.LanguageAdapter;
+import net.fabricmc.loader.api.LanguageAdapterException;
+import net.fabricmc.loader.api.entrypoint.EntrypointContainer;
+import net.fabricmc.loader.impl.ModContainerImpl;
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import net.fabricmc.loader.impl.metadata.EntrypointMetadata;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.util.*;
+
+public final class EntrypointStorage {
+	interface Entry {
+		<T> T getOrCreate(Class<T> type) throws Exception;
+		boolean isOptional();
+
+		ModContainerImpl getModContainer();
+	}
+
+	@SuppressWarnings("deprecation")
+	private static class OldEntry implements Entry {
+		private static final net.fabricmc.loader.language.LanguageAdapter.Options options = net.fabricmc.loader.language.LanguageAdapter.Options.Builder.create()
+				.missingSuperclassBehaviour(net.fabricmc.loader.language.LanguageAdapter.MissingSuperclassBehavior.RETURN_NULL)
+				.build();
+
+		private final ModContainerImpl mod;
+		private final String languageAdapter;
+		private final String value;
+		private Object object;
+
+		private OldEntry(ModContainerImpl mod, String languageAdapter, String value) {
+			this.mod = mod;
+			this.languageAdapter = languageAdapter;
+			this.value = value;
+		}
+
+		@Override
+		public String toString() {
+			return mod.getInfo().getId() + "->" + value;
+		}
+
+		@SuppressWarnings({ "unchecked" })
+		@Override
+		public synchronized <T> T getOrCreate(Class<T> type) throws Exception {
+			if (object == null) {
+				net.fabricmc.loader.language.LanguageAdapter adapter = (net.fabricmc.loader.language.LanguageAdapter) Class.forName(languageAdapter, true, FabricLauncherBase.getLauncher().getTargetClassLoader()).getConstructor().newInstance();
+				object = adapter.createInstance(value, options);
+			}
+
+			if (object == null || !type.isAssignableFrom(object.getClass())) {
+				return null;
+			} else {
+				return (T) object;
+			}
+		}
+
+		@Override
+		public boolean isOptional() {
+			return true;
+		}
+
+		@Override
+		public ModContainerImpl getModContainer() {
+			return mod;
+		}
+	}
+
+	private static final class NewEntry implements Entry {
+		private final ModContainerImpl mod;
+		private final LanguageAdapter adapter;
+		private final String value;
+		private final Map<Class<?>, Object> instanceMap;
+
+		NewEntry(ModContainerImpl mod, LanguageAdapter adapter, String value) {
+			this.mod = mod;
+			this.adapter = adapter;
+			this.value = value;
+			this.instanceMap = new IdentityHashMap<>(1);
+		}
+
+		@Override
+		public String toString() {
+			return mod.getMetadata().getId() + "->(0.3.x)" + value;
+		}
+
+		@SuppressWarnings("unchecked")
+		@Override
+		public synchronized <T> T getOrCreate(Class<T> type) throws Exception {
+			// this impl allows reentrancy (unlike computeIfAbsent)
+			T ret = (T) instanceMap.get(type);
+
+			if (ret == null) {
+				ret = adapter.create(mod, value, type);
+				assert ret != null;
+				T prev = (T) instanceMap.putIfAbsent(type, ret);
+				if (prev != null) ret = prev;
+			}
+
+			return ret;
+		}
+
+		@Override
+		public boolean isOptional() {
+			return false;
+		}
+
+		@Override
+		public ModContainerImpl getModContainer() {
+			return mod;
+		}
+	}
+
+	private final Map<String, List<Entry>> entryMap = new HashMap<>();
+
+	private List<Entry> getOrCreateEntries(String key) {
+		return entryMap.computeIfAbsent(key, (z) -> new ArrayList<>());
+	}
+
+	public void addDeprecated(ModContainerImpl modContainer, String adapter, String value) throws ClassNotFoundException, LanguageAdapterException {
+		Log.debug(LogCategory.ENTRYPOINT, "Registering 0.3.x old-style initializer %s for mod %s", value, modContainer.getMetadata().getId());
+		OldEntry oe = new OldEntry(modContainer, adapter, value);
+		getOrCreateEntries("main").add(oe);
+		getOrCreateEntries("client").add(oe);
+		getOrCreateEntries("server").add(oe);
+	}
+
+	public void add(ModContainerImpl modContainer, String key, EntrypointMetadata metadata, Map<String, LanguageAdapter> adapterMap) throws Exception {
+		if (!adapterMap.containsKey(metadata.getAdapter())) {
+			throw new Exception("Could not find adapter '" + metadata.getAdapter() + "' (mod " + modContainer.getMetadata().getId() + "!)");
+		}
+
+		Log.debug(LogCategory.ENTRYPOINT, "Registering new-style initializer %s for mod %s (key %s)", metadata.getValue(), modContainer.getMetadata().getId(), key);
+		getOrCreateEntries(key).add(new NewEntry(
+				modContainer, adapterMap.get(metadata.getAdapter()), metadata.getValue()
+				));
+	}
+
+	public boolean hasEntrypoints(String key) {
+		return entryMap.containsKey(key);
+	}
+
+	@SuppressWarnings("deprecation")
+	public <T> List<T> getEntrypoints(String key, Class<T> type) {
+		List<Entry> entries = entryMap.get(key);
+		if (entries == null) return Collections.emptyList();
+
+		EntrypointException exception = null;
+		List<T> results = new ArrayList<>(entries.size());
+
+		for (Entry entry : entries) {
+			try {
+				T result = entry.getOrCreate(type);
+
+				if (result != null) {
+					results.add(result);
+				}
+			} catch (Throwable t) {
+				if (exception == null) {
+					exception = new EntrypointException(key, entry.getModContainer().getMetadata().getId(), t);
+				} else {
+					exception.addSuppressed(t);
+				}
+			}
+		}
+
+		if (exception != null) {
+			throw exception;
+		}
+
+		return results;
+	}
+
+	@SuppressWarnings("deprecation")
+	public <T> List<EntrypointContainer<T>> getEntrypointContainers(String key, Class<T> type) {
+		List<Entry> entries = entryMap.get(key);
+		if (entries == null) return Collections.emptyList();
+
+		List<EntrypointContainer<T>> results = new ArrayList<>(entries.size());
+		EntrypointException exc = null;
+
+		for (Entry entry : entries) {
+			EntrypointContainerImpl<T> container;
+
+			if (entry.isOptional()) {
+				try {
+					T instance = entry.getOrCreate(type);
+					if (instance == null) continue;
+
+					container = new EntrypointContainerImpl<>(entry, instance);
+				} catch (Throwable t) {
+					if (exc == null) {
+						exc = new EntrypointException(key, entry.getModContainer().getMetadata().getId(), t);
+					} else {
+						exc.addSuppressed(t);
+					}
+
+					continue;
+				}
+			} else {
+				container = new EntrypointContainerImpl<>(key, type, entry);
+			}
+
+			results.add(container);
+		}
+
+		if (exc != null) throw exc;
+
+		return results;
+	}
+
+	@SuppressWarnings("unchecked") // return value allows "throw" declaration to end method
+	static <E extends Throwable> RuntimeException sneakyThrows(Throwable ex) throws E {
+		throw (E) ex;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/entrypoint/EntrypointUtils.java b/src/main/java/net/fabricmc/loader/impl/entrypoint/EntrypointUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..c2041be7ce3806a37f92ad5b785e65acc607f837
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/entrypoint/EntrypointUtils.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.entrypoint;
+
+import net.fabricmc.loader.api.entrypoint.EntrypointContainer;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.util.ExceptionUtil;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.util.Collection;
+import java.util.function.Consumer;
+
+public final class EntrypointUtils {
+	public static <T> void invoke(String name, Class<T> type, Consumer<? super T> invoker) {
+		FabricLoaderImpl loader = FabricLoaderImpl.INSTANCE;
+
+		if (!loader.hasEntrypoints(name)) {
+			Log.debug(LogCategory.ENTRYPOINT, "No subscribers for entrypoint '%s'", name);
+		} else {
+			invoke0(name, type, invoker);
+		}
+	}
+
+	private static <T> void invoke0(String name, Class<T> type, Consumer<? super T> invoker) {
+		RuntimeException exception = null;
+		Collection<EntrypointContainer<T>> entrypoints = FabricLoaderImpl.INSTANCE.getEntrypointContainers(name, type);
+
+		Log.debug(LogCategory.ENTRYPOINT, "Iterating over entrypoint '%s'", name);
+
+		for (EntrypointContainer<T> container : entrypoints) {
+			try {
+				invoker.accept(container.getEntrypoint());
+			} catch (Throwable t) {
+				exception = ExceptionUtil.gatherExceptions(t,
+						exception,
+						exc -> new RuntimeException(String.format("Could not execute entrypoint stage '%s' due to errors, provided by '%s'!",
+								name, container.getProvider().getMetadata().getId()),
+								exc));
+			}
+		}
+
+		if (exception != null) {
+			throw exception;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/GameProvider.java b/src/main/java/net/fabricmc/loader/impl/game/GameProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..27cac02610a9e3341591cd1b175986ae68b06894
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/GameProvider.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game;
+
+import net.fabricmc.loader.api.metadata.ModMetadata;
+import net.fabricmc.loader.impl.game.patch.GameTransformer;
+import net.fabricmc.loader.impl.launch.FabricLauncher;
+import net.fabricmc.loader.impl.util.Arguments;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+
+import java.nio.file.Path;
+import java.util.Collection;
+import java.util.List;
+import java.util.Objects;
+
+public interface GameProvider { // name directly referenced in net.fabricmc.loader.impl.launch.knot.Knot.findEmbedddedGameProvider() and service loader records
+	String getGameId();
+	String getGameName();
+	String getRawGameVersion();
+	String getNormalizedGameVersion();
+	Collection<BuiltinMod> getBuiltinMods();
+
+	String getEntrypoint();
+	Path getLaunchDirectory();
+	boolean isObfuscated();
+	boolean requiresUrlClassLoader();
+
+	boolean isEnabled();
+	boolean locateGame(FabricLauncher launcher, String[] args);
+	void initialize(FabricLauncher launcher);
+	GameTransformer getEntrypointTransformer();
+	void unlockClassPath(FabricLauncher launcher);
+	void launch(ClassLoader loader);
+
+	default boolean displayCrash(Throwable exception, String context) {
+		return false;
+	}
+
+	Arguments getArguments();
+	String[] getLaunchArguments(boolean sanitize);
+
+	default boolean canOpenErrorGui() {
+		return true;
+	}
+
+	default boolean hasAwtSupport() {
+		return LoaderUtil.hasAwtSupport();
+	}
+
+	class BuiltinMod {
+		public BuiltinMod(List<Path> paths, ModMetadata metadata) {
+			Objects.requireNonNull(paths, "null paths");
+			Objects.requireNonNull(metadata, "null metadata");
+
+			this.paths = paths;
+			this.metadata = metadata;
+		}
+
+		public final List<Path> paths;
+		public final ModMetadata metadata;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/GameProviderHelper.java b/src/main/java/net/fabricmc/loader/impl/game/GameProviderHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..9e950e5ef39aefb31896779b185712b9e932a701
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/GameProviderHelper.java
@@ -0,0 +1,350 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.FormattedException;
+import net.fabricmc.loader.impl.launch.FabricLauncher;
+import net.fabricmc.loader.impl.launch.MappingConfiguration;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.UrlConversionException;
+import net.fabricmc.loader.impl.util.UrlUtil;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import net.fabricmc.loader.impl.util.mappings.TinyRemapperMappingsHelper;
+import net.fabricmc.mapping.tree.TinyTree;
+import net.fabricmc.tinyremapper.InputTag;
+import net.fabricmc.tinyremapper.NonClassCopyMode;
+import net.fabricmc.tinyremapper.OutputConsumerPath;
+import net.fabricmc.tinyremapper.TinyRemapper;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URL;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.jar.JarFile;
+import java.util.zip.ZipFile;
+
+public final class GameProviderHelper {
+	private GameProviderHelper() { }
+
+	public static Path getCommonGameJar() {
+		return getGameJar(SystemProperties.GAME_JAR_PATH);
+	}
+
+	public static Path getEnvGameJar(EnvType env) {
+		return getGameJar(env == EnvType.CLIENT ? SystemProperties.GAME_JAR_PATH_CLIENT : SystemProperties.GAME_JAR_PATH_SERVER);
+	}
+
+	private static Path getGameJar(String property) {
+		String val = System.getProperty(property);
+		if (val == null) return null;
+
+		Path path = Paths.get(val);
+		if (!Files.exists(path)) throw new RuntimeException("Game jar "+path+" ("+LoaderUtil.normalizePath(path)+") configured through "+property+" system property doesn't exist");
+
+		return LoaderUtil.normalizeExistingPath(path);
+	}
+
+	public static Optional<Path> getSource(ClassLoader loader, String filename) {
+		URL url;
+
+		if ((url = loader.getResource(filename)) != null) {
+			try {
+				return Optional.of(UrlUtil.getCodeSource(url, filename));
+			} catch (UrlConversionException e) {
+				// TODO: Point to a logger
+				e.printStackTrace();
+			}
+		}
+
+		return Optional.empty();
+	}
+
+	public static List<Path> getSources(ClassLoader loader, String filename) {
+		try {
+			Enumeration<URL> urls = loader.getResources(filename);
+			List<Path> paths = new ArrayList<>();
+
+			while (urls.hasMoreElements()) {
+				URL url = urls.nextElement();
+
+				try {
+					paths.add(UrlUtil.getCodeSource(url, filename));
+				} catch (UrlConversionException e) {
+					// TODO: Point to a logger
+					e.printStackTrace();
+				}
+			}
+
+			return paths;
+		} catch (IOException e) {
+			e.printStackTrace();
+			return Collections.emptyList();
+		}
+	}
+
+	public static FindResult findFirst(List<Path> paths, Map<Path, ZipFile> zipFiles, boolean isClassName, String... names) {
+		for (String name : names) {
+			String file = isClassName ? LoaderUtil.getClassFileName(name) : name;
+
+			for (Path path : paths) {
+				if (Files.isDirectory(path)) {
+					if (Files.exists(path.resolve(file))) {
+						return new FindResult(name, path);
+					}
+				} else {
+					ZipFile zipFile = zipFiles.get(path);
+
+					if (zipFile == null) {
+						try {
+							zipFile = new ZipFile(path.toFile());
+							zipFiles.put(path, zipFile);
+						} catch (IOException e) {
+							throw new RuntimeException("Error reading "+path, e);
+						}
+					}
+
+					if (zipFile.getEntry(file) != null) {
+						return new FindResult(name, path);
+					}
+				}
+			}
+		}
+
+		return null;
+	}
+
+	public static final class FindResult {
+		public final String name;
+		public final Path path;
+
+		FindResult(String name, Path path) {
+			this.name = name;
+			this.path = path;
+		}
+	}
+
+	private static boolean emittedInfo = false;
+
+	public static Map<String, Path> deobfuscate(Map<String, Path> inputFileMap, String gameId, String gameVersion, Path gameDir, FabricLauncher launcher) {
+		Log.debug(LogCategory.GAME_REMAP, "Requesting deobfuscation of %s", inputFileMap);
+
+		if (launcher.isDevelopment()) { // in-dev is already deobfuscated
+			return inputFileMap;
+		}
+
+		MappingConfiguration mappingConfig = launcher.getMappingConfiguration();
+
+		if (!mappingConfig.matches(gameId, gameVersion)) {
+			String mappingsGameId = mappingConfig.getGameId();
+			String mappingsGameVersion = mappingConfig.getGameVersion();
+
+			throw new FormattedException("Incompatible mappings",
+					String.format("Supplied mappings for %s %s are incompatible with %s %s, this is likely caused by launcher misbehavior",
+							(mappingsGameId != null ? mappingsGameId : "(unknown)"),
+							(mappingsGameVersion != null ? mappingsGameVersion : "(unknown)"),
+							gameId,
+							gameVersion));
+		}
+
+		String targetNamespace = mappingConfig.getTargetNamespace();
+		TinyTree mappings = mappingConfig.getMappings();
+
+		if (mappings == null
+				|| !mappings.getMetadata().getNamespaces().contains(targetNamespace)) {
+			Log.debug(LogCategory.GAME_REMAP, "No mappings, using input files");
+			return inputFileMap;
+		}
+
+		Path deobfJarDir = getDeobfJarDir(gameDir, gameId, gameVersion);
+		List<Path> inputFiles = new ArrayList<>(inputFileMap.size());
+		List<Path> outputFiles = new ArrayList<>(inputFileMap.size());
+		List<Path> tmpFiles = new ArrayList<>(inputFileMap.size());
+		Map<String, Path> ret = new HashMap<>(inputFileMap.size());
+		boolean anyMissing = false;
+
+		for (Map.Entry<String, Path> entry : inputFileMap.entrySet()) {
+			String name = entry.getKey();
+			Path inputFile = entry.getValue();
+			// TODO: allow versioning mappings?
+			String deobfJarFilename = String.format("%s-%s.jar", name, targetNamespace);
+			Path outputFile = deobfJarDir.resolve(deobfJarFilename);
+			Path tmpFile = deobfJarDir.resolve(deobfJarFilename + ".tmp");
+
+			if (Files.exists(tmpFile)) { // previous unfinished remap attempt
+				Log.warn(LogCategory.GAME_REMAP, "Incomplete remapped file found! This means that the remapping process failed on the previous launch. If this persists, make sure to let us at Fabric know!");
+
+				try {
+					Files.deleteIfExists(outputFile);
+					Files.deleteIfExists(tmpFile);
+				} catch (IOException e) {
+					throw new RuntimeException("can't delete incompletely remapped files", e);
+				}
+			}
+
+			inputFiles.add(inputFile);
+			outputFiles.add(outputFile);
+			tmpFiles.add(tmpFile);
+			ret.put(name, outputFile);
+
+			if (!anyMissing && !Files.exists(outputFile)) {
+				anyMissing = true;
+			}
+		}
+
+		if (!anyMissing) {
+			Log.debug(LogCategory.GAME_REMAP, "Remapped files exist already, reusing them");
+			return ret;
+		}
+
+		Log.debug(LogCategory.GAME_REMAP, "Fabric mapping file detected, applying...");
+
+		if (!emittedInfo) {
+			Log.info(LogCategory.GAME_REMAP, "Fabric is preparing JARs on first launch, this may take a few seconds...");
+			emittedInfo = true;
+		}
+
+		try {
+			Files.createDirectories(deobfJarDir);
+			deobfuscate0(inputFiles, outputFiles, tmpFiles, mappings, targetNamespace, launcher);
+		} catch (IOException e) {
+			throw new RuntimeException("error remapping game jars "+inputFiles, e);
+		}
+
+		return ret;
+	}
+
+	private static Path getDeobfJarDir(Path gameDir, String gameId, String gameVersion) {
+		Path ret = gameDir.resolve(FabricLoaderImpl.CACHE_DIR_NAME).resolve(FabricLoaderImpl.REMAPPED_JARS_DIR_NAME);
+		StringBuilder versionDirName = new StringBuilder();
+
+		if (!gameId.isEmpty()) {
+			versionDirName.append(gameId);
+		}
+
+		if (!gameVersion.isEmpty()) {
+			if (versionDirName.length() > 0) versionDirName.append('-');
+			versionDirName.append(gameVersion);
+		}
+
+		if (versionDirName.length() > 0) versionDirName.append('-');
+		versionDirName.append(FabricLoaderImpl.VERSION);
+
+		return ret.resolve(versionDirName.toString().replaceAll("[^\\w\\-\\. ]+", "_"));
+	}
+
+	private static void deobfuscate0(List<Path> inputFiles, List<Path> outputFiles, List<Path> tmpFiles, TinyTree mappings, String targetNamespace, FabricLauncher launcher) throws IOException {
+		TinyRemapper remapper = TinyRemapper.newRemapper()
+				.withMappings(TinyRemapperMappingsHelper.create(mappings, "official", targetNamespace))
+				.rebuildSourceFilenames(true)
+				.build();
+
+		Set<Path> depPaths = new HashSet<>();
+
+		for (Path path : launcher.getClassPath()) {
+			if (!inputFiles.contains(path)) {
+				depPaths.add(path);
+
+				Log.debug(LogCategory.GAME_REMAP, "Appending '%s' to remapper classpath", path);
+				remapper.readClassPathAsync(path);
+			}
+		}
+
+		List<OutputConsumerPath> outputConsumers = new ArrayList<>(inputFiles.size());
+		List<InputTag> inputTags = new ArrayList<>(inputFiles.size());
+
+		try {
+			for (int i = 0; i < inputFiles.size(); i++) {
+				Path inputFile = inputFiles.get(i);
+				Path tmpFile = tmpFiles.get(i);
+
+				InputTag inputTag = remapper.createInputTag();
+				OutputConsumerPath outputConsumer = new OutputConsumerPath.Builder(tmpFile)
+						// force jar despite the .tmp extension
+						.assumeArchive(true)
+						.build();
+
+				outputConsumers.add(outputConsumer);
+				inputTags.add(inputTag);
+
+				outputConsumer.addNonClassFiles(inputFile, NonClassCopyMode.FIX_META_INF, remapper);
+				remapper.readInputsAsync(inputTag, inputFile);
+			}
+
+			for (int i = 0; i < inputFiles.size(); i++) {
+				remapper.apply(outputConsumers.get(i), inputTags.get(i));
+			}
+		} finally {
+			for (OutputConsumerPath outputConsumer : outputConsumers) {
+				outputConsumer.close();
+			}
+
+			remapper.finish();
+		}
+
+		// Minecraft doesn't tend to check if a ZipFileSystem is already present,
+		// so we clean up here.
+
+		depPaths.addAll(tmpFiles);
+
+		for (Path p : depPaths) {
+			try {
+				p.getFileSystem().close();
+			} catch (Exception e) {
+				// pass
+			}
+
+			try {
+				FileSystems.getFileSystem(new URI("jar:" + p.toUri())).close();
+			} catch (Exception e) {
+				// pass
+			}
+		}
+
+		List<Path> missing = new ArrayList<>();
+
+		for (int i = 0; i < inputFiles.size(); i++) {
+			Path inputFile = inputFiles.get(i);
+			Path tmpFile = tmpFiles.get(i);
+			Path outputFile = outputFiles.get(i);
+
+			boolean found;
+
+			try (JarFile jar = new JarFile(tmpFile.toFile())) {
+				found = jar.stream().anyMatch((e) -> e.getName().endsWith(".class"));
+			}
+
+			if (!found) {
+				missing.add(inputFile);
+				Files.delete(tmpFile);
+			} else {
+				Files.move(tmpFile, outputFile);
+			}
+		}
+
+		if (!missing.isEmpty()) {
+			throw new RuntimeException("Generated deobfuscated JARs contain no classes: "+missing);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/LibClassifier.java b/src/main/java/net/fabricmc/loader/impl/game/LibClassifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..343c4933f5349e564ed6e799dbf9b62d53861133
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/LibClassifier.java
@@ -0,0 +1,260 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.ManifestUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.UrlUtil;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.io.IOException;
+import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipError;
+import java.util.zip.ZipFile;
+
+public final class LibClassifier<L extends Enum<L> & LibClassifier.LibraryType> {
+	private static final boolean DEBUG = System.getProperty(SystemProperties.DEBUG_LOG_LIB_CLASSIFICATION) != null;
+
+	private final List<L> libs;
+	private final Map<L, Path> origins;
+	private final Map<L, String> localPaths;
+	private final Set<Path> loaderOrigins = new HashSet<>();
+	private final List<Path> unmatchedOrigins = new ArrayList<>();
+
+	public LibClassifier(Class<L> cls, EnvType env, GameProvider gameProvider) throws IOException {
+		L[] libs = cls.getEnumConstants();
+
+		this.libs = new ArrayList<>(libs.length);
+		this.origins = new EnumMap<>(cls);
+		this.localPaths = new EnumMap<>(cls);
+
+		// game provider libs
+
+		for (L lib : libs) {
+			if (lib.isApplicable(env)) {
+				this.libs.add(lib);
+			}
+		}
+
+		// loader libs
+
+		StringBuilder sb = DEBUG ? new StringBuilder() : null;
+
+		for (LoaderLibrary lib : LoaderLibrary.values()) {
+			if (!lib.isApplicable(env)) continue;
+
+			if (lib.path != null) {
+				Path path = LoaderUtil.normalizeExistingPath(lib.path);
+				loaderOrigins.add(path);
+
+				if (DEBUG) sb.append(String.format(" %s %s%n", lib.name(), path));
+			} else {
+				if (DEBUG) sb.append(String.format(" %s%n", lib.name()));
+			}
+		}
+
+		// game provider itself
+
+		Path gameProviderPath = UrlUtil.getCodeSource(gameProvider.getClass());
+
+		if (gameProviderPath != null) {
+			gameProviderPath = LoaderUtil.normalizeExistingPath(gameProviderPath);
+
+			if (loaderOrigins.add(gameProviderPath)) {
+				if (DEBUG) sb.append(String.format(" gameprovider %s%n", gameProviderPath));
+			}
+		} else {
+			if (DEBUG) sb.append(" gameprovider");
+		}
+
+		if (DEBUG) Log.info(LogCategory.LIB_CLASSIFICATION, "Loader libraries:%n%s", sb);
+
+		// process indirectly referenced libs
+
+		processManifestClassPath(LoaderLibrary.SERVER_LAUNCH, env); // not used by fabric itself, but others add Log4J this way
+	}
+
+	private void processManifestClassPath(LoaderLibrary lib, EnvType env) throws IOException {
+		if (lib.path == null || !lib.isApplicable(env) || !Files.isRegularFile(lib.path)) return;
+
+		Manifest manifest;
+
+		try (ZipFile zf = new ZipFile(lib.path.toFile())) {
+			ZipEntry entry = zf.getEntry(JarFile.MANIFEST_NAME);
+			if (entry == null) return;
+
+			manifest = new Manifest(zf.getInputStream(entry));
+		}
+
+		List<URL> cp = ManifestUtil.getClassPath(manifest, lib.path);
+		if (cp == null) return;
+
+		for (URL url : cp) {
+			process(url);
+		}
+	}
+
+	public void process(URL url) throws IOException {
+		process(UrlUtil.asPath(url));
+	}
+
+	@SafeVarargs
+	public final void process(Iterable<Path> paths, L... excludedLibs) throws IOException {
+		Set<L> excluded = makeSet(excludedLibs);
+
+		for (Path path : paths) {
+			process(path, excluded);
+		}
+	}
+
+	@SafeVarargs
+	public final void process(Path path, L... excludedLibs) throws IOException {
+		process(path, makeSet(excludedLibs));
+	}
+
+	private static <L extends Enum<L>> Set<L> makeSet(L[] libs) {
+		if (libs.length == 0) return Collections.emptySet();
+
+		Set<L> ret = EnumSet.of(libs[0]);
+
+		for (int i = 1; i < libs.length; i++) {
+			ret.add(libs[i]);
+		}
+
+		return ret;
+	}
+
+	private void process(Path path, Set<L> excludedLibs) throws IOException {
+		path = LoaderUtil.normalizeExistingPath(path);
+		if (loaderOrigins.contains(path)) return;
+
+		boolean matched = false;
+
+		if (Files.isDirectory(path)) {
+			for (L lib : libs) {
+				if (excludedLibs.contains(lib) || origins.containsKey(lib)) continue;
+
+				for (String p : lib.getPaths()) {
+					if (Files.exists(path.resolve(p))) {
+						matched = true;
+						addLibrary(lib, path, p);
+						break;
+					}
+				}
+			}
+		} else {
+			try (ZipFile zf = new ZipFile(path.toFile())) {
+				for (L lib : libs) {
+					if (excludedLibs.contains(lib) || origins.containsKey(lib)) continue;
+
+					for (String p : lib.getPaths()) {
+						if (zf.getEntry(p) != null) {
+							matched = true;
+							addLibrary(lib, path, p);
+							break;
+						}
+					}
+				}
+			} catch (ZipError | IOException e) {
+				throw new IOException("error reading "+path, e);
+			}
+		}
+
+		if (!matched) {
+			unmatchedOrigins.add(path);
+
+			if (DEBUG) Log.info(LogCategory.LIB_CLASSIFICATION, "unmatched %s", path);
+		}
+	}
+
+	private void addLibrary(L lib, Path originPath, String localPath) {
+		Path prev = origins.put(lib, originPath);
+		if (prev != null) throw new IllegalStateException("lib "+lib+" was already added");
+		localPaths.put(lib, localPath);
+
+		if (DEBUG) Log.info(LogCategory.LIB_CLASSIFICATION, "%s %s (%s)", lib.name(), originPath, localPath);
+	}
+
+	@SafeVarargs
+	public final boolean is(Path path, L... libs) {
+		for (L lib : libs) {
+			if (path.equals(origins.get(lib))) return true;
+		}
+
+		return false;
+	}
+
+	public boolean has(L lib) {
+		return origins.containsKey(lib);
+	}
+
+	public Path getOrigin(L lib) {
+		return origins.get(lib);
+	}
+
+	public String getLocalPath(L lib) {
+		return localPaths.get(lib);
+	}
+
+	public String getClassName(L lib) {
+		String localPath = localPaths.get(lib);
+		if (localPath == null || !localPath.endsWith(".class")) return null;
+
+		return localPath.substring(0, localPath.length() - 6).replace('/', '.');
+	}
+
+	public List<Path> getUnmatchedOrigins() {
+		return unmatchedOrigins;
+	}
+
+	public Collection<Path> getLoaderOrigins() {
+		return loaderOrigins;
+	}
+
+	public boolean remove(Path path) {
+		if (unmatchedOrigins.remove(path)) return true;
+
+		boolean ret = false;
+
+		for (Iterator<Map.Entry<L, Path>> it = origins.entrySet().iterator(); it.hasNext(); ) {
+			Map.Entry<L, Path> entry = it.next();
+
+			if (entry.getValue().equals(path)) {
+				localPaths.remove(entry.getKey());
+				it.remove();
+
+				ret = true;
+			}
+		}
+
+		return ret;
+	}
+
+	public interface LibraryType {
+		boolean isApplicable(EnvType env);
+		String[] getPaths();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/LoaderLibrary.java b/src/main/java/net/fabricmc/loader/impl/game/LoaderLibrary.java
new file mode 100644
index 0000000000000000000000000000000000000000..d8abb0ad4c861b611fec8d18f3c395a7020c2895
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/LoaderLibrary.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game;
+
+import net.fabricmc.accesswidener.AccessWidener;
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.util.UrlConversionException;
+import net.fabricmc.loader.impl.util.UrlUtil;
+import net.fabricmc.mapping.tree.TinyMappingFactory;
+import net.fabricmc.tinyremapper.TinyRemapper;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.commons.Remapper;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.analysis.Analyzer;
+import org.objectweb.asm.util.CheckClassAdapter;
+import org.sat4j.pb.SolverFactory;
+import org.sat4j.specs.ContradictionException;
+import org.spongepowered.asm.launch.MixinBootstrap;
+
+import java.net.URL;
+import java.nio.file.Path;
+
+enum LoaderLibrary {
+	FABRIC_LOADER(UrlUtil.LOADER_CODE_SOURCE),
+	TINY_MAPPINGS_PARSER(TinyMappingFactory.class),
+	SPONGE_MIXIN(MixinBootstrap.class),
+	TINY_REMAPPER(TinyRemapper.class),
+	ACCESS_WIDENER(AccessWidener.class),
+	ASM(ClassReader.class),
+	ASM_ANALYSIS(Analyzer.class),
+	ASM_COMMONS(Remapper.class),
+	ASM_TREE(ClassNode.class),
+	ASM_UTIL(CheckClassAdapter.class),
+	SAT4J_CORE(ContradictionException.class),
+	SAT4J_PB(SolverFactory.class),
+	SERVER_LAUNCH("fabric-server-launch.properties", EnvType.SERVER), // installer generated jar to run setup loader's class path
+	SERVER_LAUNCHER("net/fabricmc/installer/ServerLauncher.class", EnvType.SERVER); // installer based launch-through method
+
+	final Path path;
+	final EnvType env;
+
+	LoaderLibrary(Class<?> cls) {
+		this(UrlUtil.getCodeSource(cls));
+	}
+
+	LoaderLibrary(Path path) {
+		if (path == null) throw new RuntimeException("missing loader library "+name());
+
+		this.path = path;
+		this.env = null;
+	}
+
+	LoaderLibrary(String file, EnvType env) {
+		URL url = LoaderLibrary.class.getClassLoader().getResource(file);
+
+		try {
+			this.path = url != null ? UrlUtil.getCodeSource(url, file) : null;
+			this.env = env;
+		} catch (UrlConversionException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	boolean isApplicable(EnvType env) {
+		return this.env == null || this.env == env;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/minecraft/BundlerClassPathCapture.java b/src/main/java/net/fabricmc/loader/impl/game/minecraft/BundlerClassPathCapture.java
new file mode 100644
index 0000000000000000000000000000000000000000..598f78d1483ec1ccdaaa3e7f4a276223e0f1c1c0
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/minecraft/BundlerClassPathCapture.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.minecraft;
+
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.concurrent.CompletableFuture;
+
+public final class BundlerClassPathCapture {
+	static final CompletableFuture<URL[]> FUTURE = new CompletableFuture<>();
+
+	public static void main(String[] args) { // invoked by the bundler on a thread
+		try {
+			URLClassLoader cl = (URLClassLoader) Thread.currentThread().getContextClassLoader();
+			FUTURE.complete(cl.getURLs());
+		} catch (Throwable t) {
+			FUTURE.completeExceptionally(t);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/minecraft/BundlerProcessor.java b/src/main/java/net/fabricmc/loader/impl/game/minecraft/BundlerProcessor.java
new file mode 100644
index 0000000000000000000000000000000000000000..3e3f3a00f22d1628b8deb7e6abaa054de607427d
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/minecraft/BundlerProcessor.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.minecraft;
+
+import net.fabricmc.loader.impl.game.LibClassifier;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Method;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Path;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+
+final class BundlerProcessor {
+	private static final String MAIN_CLASS_PROPERTY = "bundlerMainClass";
+
+	static void process(LibClassifier<McLibrary> classifier) throws IOException {
+		Path bundlerOrigin = classifier.getOrigin(McLibrary.MC_BUNDLER);
+
+		// determine urls by running the bundler and extracting them from the context class loader
+
+		String prevProperty = null;
+		ClassLoader prevCl = null;
+		boolean restorePrev = false;
+		URL[] urls;
+
+		try (URLClassLoader bundlerCl = new URLClassLoader(new URL[] { bundlerOrigin.toUri().toURL() }, MinecraftGameProvider.class.getClassLoader()) {
+			@Override
+			protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+				synchronized (getClassLoadingLock(name)) {
+					Class<?> c = findLoadedClass(name);
+
+					if (c == null) {
+						if (name.startsWith("net.minecraft.")) {
+							URL url = getResource(LoaderUtil.getClassFileName(name));
+
+							if (url != null) {
+								try (InputStream is = url.openConnection().getInputStream()) {
+									byte[] data = new byte[Math.max(is.available() + 1, 1000)];
+									int offset = 0;
+									int len;
+
+									while ((len = is.read(data, offset, data.length - offset)) >= 0) {
+										offset += len;
+										if (offset == data.length) data = Arrays.copyOf(data, data.length * 2);
+									}
+
+									c = defineClass(name, data, 0, offset);
+								} catch (IOException e) {
+									throw new RuntimeException(e);
+								}
+							}
+						}
+
+						if (c == null) {
+							c = getParent().loadClass(name);
+						}
+					}
+
+					if (resolve) {
+						resolveClass(c);
+					}
+
+					return c;
+				}
+			}
+		}) {
+			Class<?> cls = Class.forName(classifier.getClassName(McLibrary.MC_BUNDLER), true, bundlerCl);
+			Method method = cls.getMethod("main", String[].class);
+
+			// save + restore the system property and context class loader just in case
+
+			prevProperty = System.getProperty(MAIN_CLASS_PROPERTY);
+			prevCl = Thread.currentThread().getContextClassLoader();
+			restorePrev = true;
+
+			System.setProperty(MAIN_CLASS_PROPERTY, BundlerClassPathCapture.class.getName());
+			Thread.currentThread().setContextClassLoader(bundlerCl);
+
+			method.invoke(null, (Object) new String[0]);
+			urls = BundlerClassPathCapture.FUTURE.get(10, TimeUnit.SECONDS);
+		} catch (ClassNotFoundException e) { // no bundler on the class path
+			return;
+		} catch (Throwable t) {
+			throw new RuntimeException("Error invoking MC server bundler: "+t, t);
+		} finally {
+			if (restorePrev) {
+				Thread.currentThread().setContextClassLoader(prevCl);
+
+				if (prevProperty != null) {
+					System.setProperty(MAIN_CLASS_PROPERTY, prevProperty);
+				} else {
+					System.clearProperty(MAIN_CLASS_PROPERTY);
+				}
+			}
+		}
+
+		// analyze urls to determine game/realms/log4j/misc libs and the entrypoint
+
+		classifier.remove(bundlerOrigin);
+
+		for (URL url : urls) {
+			classifier.process(url);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/minecraft/Hooks.java b/src/main/java/net/fabricmc/loader/impl/game/minecraft/Hooks.java
new file mode 100644
index 0000000000000000000000000000000000000000..875b125c04f0923c84ee5f181924fbcdafbb4856
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/minecraft/Hooks.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.minecraft;
+
+import net.fabricmc.api.ClientModInitializer;
+import net.fabricmc.api.DedicatedServerModInitializer;
+import net.fabricmc.api.ModInitializer;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.entrypoint.EntrypointUtils;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.io.File;
+
+public final class Hooks {
+	public static final String INTERNAL_NAME = Hooks.class.getName().replace('.', '/');
+
+	public static String appletMainClass;
+
+	public static final String FABRIC = "fabric";
+	public static final String VANILLA = "vanilla";
+
+	public static String insertBranding(final String brand) {
+		if (brand == null || brand.isEmpty()) {
+			Log.warn(LogCategory.GAME_PROVIDER, "Null or empty branding found!", new IllegalStateException());
+			return FABRIC;
+		}
+
+		return VANILLA.equals(brand) ? FABRIC : brand + ',' + FABRIC;
+	}
+
+	public static void startClient(File runDir, Object gameInstance) {
+		if (runDir == null) {
+			runDir = new File(".");
+		}
+
+		FabricLoaderImpl.INSTANCE.prepareModInit(runDir.toPath(), gameInstance);
+		EntrypointUtils.invoke("main", ModInitializer.class, ModInitializer::onInitialize);
+		EntrypointUtils.invoke("client", ClientModInitializer.class, ClientModInitializer::onInitializeClient);
+	}
+
+	public static void startServer(File runDir, Object gameInstance) {
+		if (runDir == null) {
+			runDir = new File(".");
+		}
+
+		FabricLoaderImpl.INSTANCE.prepareModInit(runDir.toPath(), gameInstance);
+		EntrypointUtils.invoke("main", ModInitializer.class, ModInitializer::onInitialize);
+		EntrypointUtils.invoke("server", DedicatedServerModInitializer.class, DedicatedServerModInitializer::onInitializeServer);
+	}
+
+	public static void setGameInstance(Object gameInstance) {
+		FabricLoaderImpl.INSTANCE.setGameInstance(gameInstance);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/minecraft/Log4jLogHandler.java b/src/main/java/net/fabricmc/loader/impl/game/minecraft/Log4jLogHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..ac4509209394e052eb71f893dd48e214e0a28d43
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/minecraft/Log4jLogHandler.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.minecraft;
+
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.impl.util.ManifestUtil;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import net.fabricmc.loader.impl.util.log.LogHandler;
+import net.fabricmc.loader.impl.util.log.LogLevel;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.logging.log4j.spi.LoggerContext;
+
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.net.URISyntaxException;
+import java.util.Locale;
+import java.util.Map;
+import java.util.jar.Attributes.Name;
+import java.util.jar.Manifest;
+
+public final class Log4jLogHandler implements LogHandler {
+	@Override
+	public boolean shouldLog(LogLevel level, LogCategory category) {
+		return getLogger(category).isEnabled(translateLogLevel(level));
+	}
+
+	@Override
+	public void log(long time, LogLevel level, LogCategory category, String msg, Throwable exc, boolean fromReplay, boolean wasSuppressed) {
+		// TODO: suppress console log output if wasSuppressed is false to avoid duplicate output
+		getLogger(category).log(translateLogLevel(level), msg, exc);
+	}
+
+	private static Logger getLogger(LogCategory category) {
+		Logger ret = (Logger) category.data;
+
+		if (ret == null) {
+			category.data = ret = LogManager.getLogger(category.toString());
+		}
+
+		return ret;
+	}
+
+	private static Level translateLogLevel(LogLevel level) {
+		// can't use enum due to it generating a nested class, which would have to be on the same class loader as Log4jLogHandler
+		if (level == LogLevel.ERROR) return Level.ERROR;
+		if (level == LogLevel.WARN) return Level.WARN;
+		if (level == LogLevel.INFO) return Level.INFO;
+		if (level == LogLevel.DEBUG) return Level.DEBUG;
+		if (level == LogLevel.TRACE) return Level.TRACE;
+
+		throw new IllegalArgumentException("unknown log level: "+level);
+	}
+
+	@Override
+	public void close() { }
+
+	static {
+		if (needsLookupRemoval()) {
+			patchJndi();
+		} else {
+			Log.debug(LogCategory.GAME_PROVIDER, "Log4J2 JNDI removal is unnecessary");
+		}
+	}
+
+	private static boolean needsLookupRemoval() {
+		Manifest manifest;
+
+		try {
+			manifest = ManifestUtil.readManifest(LogManager.class);
+		} catch (IOException | URISyntaxException e) {
+			Log.warn(LogCategory.GAME_PROVIDER, "Can't read Log4J2 Manifest", e);
+			return true;
+		}
+
+		if (manifest == null) return true;
+
+		String title = ManifestUtil.getManifestValue(manifest, Name.IMPLEMENTATION_TITLE);
+		if (title == null || !title.toLowerCase(Locale.ENGLISH).contains("log4j")) return true;
+
+		String version = ManifestUtil.getManifestValue(manifest, Name.IMPLEMENTATION_VERSION);
+		if (version == null) return true;
+
+		try {
+			return Version.parse(version).compareTo(Version.parse("2.16")) < 0; // 2.15+ doesn't lookup by default, but we patch anything up to 2.16 just in case
+		} catch (Exception e) {
+			Log.warn(LogCategory.GAME_PROVIDER, "Can't parse Log4J2 Manifest version %s", version, e);
+			return true;
+		}
+	}
+
+	private static void patchJndi() {
+		LoggerContext context = LogManager.getContext(false);
+
+		try {
+			context.getClass().getMethod("addPropertyChangeListener", PropertyChangeListener.class).invoke(context, new PropertyChangeListener() {
+				@Override
+				public void propertyChange(PropertyChangeEvent evt) {
+					if (evt.getPropertyName().equals("config")) {
+						removeSubstitutionLookups(true);
+					}
+				}
+			});
+		} catch (Exception e) {
+			Log.warn(LogCategory.GAME_PROVIDER, "Can't register Log4J2 PropertyChangeListener: %s", e.toString());
+		}
+
+		removeSubstitutionLookups(false);
+	}
+
+	private static void removeSubstitutionLookups(boolean ignoreMissing) {
+		// strip the jndi lookup and then all over lookups from the active org.apache.logging.log4j.core.lookup.Interpolator instance's lookups map
+
+		try {
+			LoggerContext context = LogManager.getContext(false);
+			if (context.getClass().getName().equals("org.apache.logging.log4j.simple.SimpleLoggerContext")) return; // -> no log4j core
+
+			Object config = context.getClass().getMethod("getConfiguration").invoke(context);
+			Object substitutor = config.getClass().getMethod("getStrSubstitutor").invoke(config);
+			Object varResolver = substitutor.getClass().getMethod("getVariableResolver").invoke(substitutor);
+			if (varResolver == null) return;
+
+			boolean removed = false;
+
+			for (Field field : varResolver.getClass().getDeclaredFields()) {
+				if (Map.class.isAssignableFrom(field.getType())) {
+					field.setAccessible(true);
+					@SuppressWarnings("unchecked")
+					Map<String, ?> map = (Map<String, ?>) field.get(varResolver);
+
+					if (map.remove("jndi") != null) {
+						map.clear();
+						removed = true;
+						break;
+					}
+				}
+			}
+
+			if (!removed) {
+				if (ignoreMissing) return;
+				throw new RuntimeException("couldn't find JNDI lookup entry");
+			}
+
+			Log.debug(LogCategory.GAME_PROVIDER, "Removed Log4J2 substitution lookups");
+		} catch (Exception e) {
+			Log.warn(LogCategory.GAME_PROVIDER, "Can't remove Log4J2 JNDI substitution Lookup: %s", e.toString());
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/minecraft/McLibrary.java b/src/main/java/net/fabricmc/loader/impl/game/minecraft/McLibrary.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f13713d146fdb7c2bd089dc710de11e95a53baa
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/minecraft/McLibrary.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.minecraft;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.game.LibClassifier.LibraryType;
+
+enum McLibrary implements LibraryType {
+	MC_CLIENT(EnvType.CLIENT, "net/minecraft/client/main/Main.class", "net/minecraft/client/MinecraftApplet.class", "com/mojang/minecraft/MinecraftApplet.class"),
+	MC_SERVER(EnvType.SERVER, "net/minecraft/server/Main.class", "net/minecraft/server/MinecraftServer.class", "com/mojang/minecraft/server/MinecraftServer.class"),
+	MC_COMMON("net/minecraft/server/MinecraftServer.class"),
+	MC_BUNDLER(EnvType.SERVER, "net/minecraft/bundler/Main.class"),
+	REALMS(EnvType.CLIENT, "realmsVersion"),
+	MODLOADER("ModLoader"),
+	LOG4J_API("org/apache/logging/log4j/LogManager.class"),
+	LOG4J_CORE("META-INF/services/org.apache.logging.log4j.spi.Provider", "META-INF/log4j-provider.properties"),
+	LOG4J_CONFIG("log4j2.xml"),
+	LOG4J_PLUGIN("com/mojang/util/UUIDTypeAdapter.class"), // in authlib
+	LOG4J_PLUGIN_2("com/mojang/patchy/LegacyXMLLayout.class"), // in patchy
+	LOG4J_PLUGIN_3("net/minecrell/terminalconsole/util/LoggerNamePatternSelector.class"), // in terminalconsoleappender, used by loom's log4j config
+	GSON("com/google/gson/TypeAdapter.class"), // used by log4j plugins
+	SLF4J_API("org/slf4j/Logger.class");
+
+	static final McLibrary[] GAME = { MC_CLIENT, MC_SERVER, MC_BUNDLER };
+	static final McLibrary[] LOGGING = { LOG4J_API, LOG4J_CORE, LOG4J_CONFIG, LOG4J_PLUGIN, LOG4J_PLUGIN_2, LOG4J_PLUGIN_3, GSON, SLF4J_API };
+
+	private final EnvType env;
+	private final String[] paths;
+
+	McLibrary(String path) {
+		this(null, new String[] { path });
+	}
+
+	McLibrary(String... paths) {
+		this(null, paths);
+	}
+
+	McLibrary(EnvType env, String... paths) {
+		this.paths = paths;
+		this.env = env;
+	}
+
+	@Override
+	public boolean isApplicable(EnvType env) {
+		return this.env == null || this.env == env;
+	}
+
+	@Override
+	public String[] getPaths() {
+		return paths;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/minecraft/McVersion.java b/src/main/java/net/fabricmc/loader/impl/game/minecraft/McVersion.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c63f9e54b1c1ee1e503b28b61ecf39049490d40
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/minecraft/McVersion.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.minecraft;
+
+import java.util.OptionalInt;
+
+public final class McVersion {
+	/**
+	 * The id from version.json, if available.
+	 */
+	private final String id;
+	/**
+	 * The name from version.json, if available.
+	 */
+	private final String name;
+	/**
+	 * The raw version, such as {@code 18w21a}.
+	 *
+	 * <p>This is derived from the version.json's id and name fields if available, otherwise through other sources.
+	 */
+	private final String raw;
+	/**
+	 * The normalized version.
+	 *
+	 * <p>This is usually compliant with Semver and
+	 * contains release and pre-release information.
+	 */
+	private final String normalized;
+	private final OptionalInt classVersion;
+
+	private McVersion(String id, String name, String raw, String release, OptionalInt classVersion) {
+		this.id = id;
+		this.name = name;
+		this.raw = raw;
+		this.normalized = McVersionLookup.normalizeVersion(raw, release);
+		this.classVersion = classVersion;
+	}
+
+	public String getId() {
+		return id;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public String getRaw() {
+		return this.raw;
+	}
+
+	public String getNormalized() {
+		return this.normalized;
+	}
+
+	public OptionalInt getClassVersion() {
+		return this.classVersion;
+	}
+
+	@Override
+	public String toString() {
+		return String.format("McVersion{id=%s, name=%s, raw=%s, normalized=%s, classVersion=%s}",
+				id, name, raw, normalized, classVersion);
+	}
+
+	public static final class Builder {
+		private String id; // id as in version.json
+		private String name; // name as in version.json
+		private String version; // derived from version.json's id and name or other sources
+		private String release; // mc release (major.minor)
+		private OptionalInt classVersion = OptionalInt.empty();
+
+		// Setters
+		public Builder setId(String id) {
+			this.id = id;
+			return this;
+		}
+
+		public Builder setName(String name) {
+			this.name = name;
+			return this;
+		}
+
+		public Builder setVersion(String name) {
+			this.version = name;
+			return this;
+		}
+
+		public Builder setRelease(String release) {
+			this.release = release;
+			return this;
+		}
+
+		public Builder setClassVersion(int classVersion) {
+			this.classVersion = OptionalInt.of(classVersion);
+			return this;
+		}
+
+		// Complex setters
+		public Builder setNameAndRelease(String name) {
+			return setVersion(name)
+					.setRelease(McVersionLookup.getRelease(name));
+		}
+
+		public Builder setFromFileName(String name) {
+			// strip extension
+			int pos = name.lastIndexOf('.');
+			if (pos > 0) name = name.substring(0, pos);
+
+			return setNameAndRelease(name);
+		}
+
+		public McVersion build() {
+			return new McVersion(this.id, this.name, this.version, this.release, this.classVersion);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/minecraft/McVersionLookup.java b/src/main/java/net/fabricmc/loader/impl/game/minecraft/McVersionLookup.java
new file mode 100644
index 0000000000000000000000000000000000000000..8cc6815ee6a67807d5ad8bde5a54f31d2aee2a47
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/minecraft/McVersionLookup.java
@@ -0,0 +1,868 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.minecraft;
+
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.lib.gson.JsonReader;
+import net.fabricmc.loader.impl.lib.gson.JsonToken;
+import net.fabricmc.loader.impl.util.ExceptionUtil;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SimpleClassPath;
+import net.fabricmc.loader.impl.util.SimpleClassPath.CpEntry;
+import net.fabricmc.loader.impl.util.version.SemanticVersionImpl;
+import net.fabricmc.loader.impl.util.version.VersionPredicateParser;
+import org.objectweb.asm.*;
+
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Path;
+import java.util.Collections;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public final class McVersionLookup {
+	private static final Pattern VERSION_PATTERN = Pattern.compile(
+			"0\\.\\d+(\\.\\d+)?a?(_\\d+)?|" // match classic versions first: 0.1.2a_34
+			+ "\\d+\\.\\d+(\\.\\d+)?(-pre\\d+| Pre-[Rr]elease \\d+)?|" // modern non-snapshot: 1.2, 1.2.3, optional -preN or " Pre-Release N" suffix
+			+ "\\d+\\.\\d+(\\.\\d+)?(-rc\\d+| [Rr]elease Candidate \\d+)?|" // 1.16+ Release Candidate
+			+ "\\d+w\\d+[a-z]|" // modern snapshot: 12w34a
+			+ "[a-c]\\d\\.\\d+(\\.\\d+)?[a-z]?(_\\d+)?[a-z]?|" // alpha/beta a1.2.3_45
+			+ "(Alpha|Beta) v?\\d+\\.\\d+(\\.\\d+)?[a-z]?(_\\d+)?[a-z]?|" // long alpha/beta names: Alpha v1.2.3_45
+			+ "Inf?dev (0\\.31 )?\\d+(-\\d+)?|" // long indev/infdev names: Infdev 12345678-9
+			+ "(rd|inf)-\\d+|" // early rd-123, inf-123
+			+ "1\\.RV-Pre1|3D Shareware v1\\.34|" // odd exceptions
+			+ "(.*[Ee]xperimental [Ss]napshot )(\\d+)" // Experimental versions.
+			);
+	private static final Pattern RELEASE_PATTERN = Pattern.compile("\\d+\\.\\d+(\\.\\d+)?");
+	private static final Pattern PRE_RELEASE_PATTERN = Pattern.compile(".+(?:-pre| Pre-[Rr]elease )(\\d+)");
+	private static final Pattern RELEASE_CANDIDATE_PATTERN = Pattern.compile(".+(?:-rc| [Rr]elease Candidate )(\\d+)");
+	private static final Pattern SNAPSHOT_PATTERN = Pattern.compile("(?:Snapshot )?(\\d+)w0?(0|[1-9]\\d*)([a-z])");
+	private static final Pattern EXPERIMENTAL_PATTERN = Pattern.compile("(?:.*[Ee]xperimental [Ss]napshot )(\\d+)");
+	private static final Pattern BETA_PATTERN = Pattern.compile("(?:b|Beta v?)1\\.(\\d+(\\.\\d+)?[a-z]?(_\\d+)?[a-z]?)");
+	private static final Pattern ALPHA_PATTERN = Pattern.compile("(?:a|Alpha v?)[01]\\.(\\d+(\\.\\d+)?[a-z]?(_\\d+)?[a-z]?)");
+	private static final Pattern INDEV_PATTERN = Pattern.compile("(?:inf-|Inf?dev )(?:0\\.31 )?(\\d+(-\\d+)?)");
+	private static final String STRING_DESC = "Ljava/lang/String;";
+
+	public static McVersion getVersion(List<Path> gameJars, String entrypointClass, String versionName) {
+		McVersion.Builder builder = new McVersion.Builder();
+
+		if (versionName != null) {
+			builder.setNameAndRelease(versionName);
+		}
+
+		try (SimpleClassPath cp = new SimpleClassPath(gameJars)) {
+			// Determine class version
+			if (entrypointClass != null) {
+				try (InputStream is = cp.getInputStream(LoaderUtil.getClassFileName(entrypointClass))) {
+					DataInputStream dis = new DataInputStream(is);
+
+					if (dis.readInt() == 0xCAFEBABE) {
+						dis.readUnsignedShort();
+						builder.setClassVersion(dis.readUnsignedShort());
+					}
+				}
+			}
+
+			// Check various known files for version information if unknown
+			if (versionName == null) {
+				fillVersionFromJar(cp, builder);
+			}
+		} catch (IOException e) {
+			throw ExceptionUtil.wrap(e);
+		}
+
+		return builder.build();
+	}
+
+	public static McVersion getVersionExceptClassVersion(Path gameJar) {
+		McVersion.Builder builder = new McVersion.Builder();
+
+		try (SimpleClassPath cp = new SimpleClassPath(Collections.singletonList(gameJar))) {
+			fillVersionFromJar(cp, builder);
+		} catch (IOException e) {
+			throw ExceptionUtil.wrap(e);
+		}
+
+		return builder.build();
+	}
+
+	public static void fillVersionFromJar(SimpleClassPath cp, McVersion.Builder builder) {
+		try {
+			InputStream is;
+
+			// version.json - contains version and target release for 18w47b+
+			if ((is = cp.getInputStream("version.json")) != null && fromVersionJson(is, builder)) {
+				return;
+			}
+
+			// constant field RealmsSharedConstants.VERSION_STRING
+			if ((is = cp.getInputStream("net/minecraft/realms/RealmsSharedConstants.class")) != null && fromAnalyzer(is, new FieldStringConstantVisitor("VERSION_STRING"), builder)) {
+				return;
+			}
+
+			// constant return value of RealmsBridge.getVersionString (presumably inlined+dead code eliminated VERSION_STRING)
+			if ((is = cp.getInputStream("net/minecraft/realms/RealmsBridge.class")) != null && fromAnalyzer(is, new MethodConstantRetVisitor("getVersionString"), builder)) {
+				return;
+			}
+
+			// version-like String constant used in MinecraftServer.run or another MinecraftServer method
+			if ((is = cp.getInputStream("net/minecraft/server/MinecraftServer.class")) != null && fromAnalyzer(is, new MethodConstantVisitor("run"), builder)) {
+				return;
+			}
+
+			CpEntry entry = cp.getEntry("net/minecraft/client/Minecraft.class");
+
+			if (entry != null) {
+				// version-like constant return value of a Minecraft method (obfuscated/unknown name)
+				if (fromAnalyzer(entry.getInputStream(), new MethodConstantRetVisitor(null), builder)) {
+					return;
+				}
+
+				// version-like constant passed into Display.setTitle in a Minecraft method (obfuscated/unknown name)
+				if (fromAnalyzer(entry.getInputStream(), new MethodStringConstantContainsVisitor("org/lwjgl/opengl/Display", "setTitle"), builder)) {
+					return;
+				}
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+
+		builder.setFromFileName(cp.getPaths().get(0).getFileName().toString());
+	}
+
+	private static boolean fromVersionJson(InputStream is, McVersion.Builder builder) {
+		try (JsonReader reader = new JsonReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {
+			String id = null;
+			String name = null;
+			String release = null;
+
+			reader.beginObject();
+
+			while (reader.hasNext()) {
+				switch (reader.nextName()) {
+				case "id":
+					if (reader.peek() != JsonToken.STRING) {
+						throw new IOException("\"id\" in version json must be a string");
+					}
+
+					id = reader.nextString();
+					break;
+				case "name":
+					if (reader.peek() != JsonToken.STRING) {
+						throw new IOException("\"name\" in version json must be a string");
+					}
+
+					name = reader.nextString();
+					break;
+				case "release_target":
+					if (reader.peek() != JsonToken.STRING) {
+						throw new IOException("\"release_target\" in version json must be a string");
+					}
+
+					release = reader.nextString();
+					break;
+				default:
+					// There is typically other stuff in the file, just ignore anything we don't know
+					reader.skipValue();
+				}
+			}
+
+			reader.endObject();
+
+			String version;
+
+			if (name == null
+					|| id != null && id.length() < name.length()) {
+				version = id;
+			} else {
+				version = name;
+			}
+
+			if (version != null && release != null) {
+				builder.setId(id);
+				builder.setName(name);
+				builder.setVersion(version);
+				builder.setRelease(release);
+
+				return true;
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+
+		return false;
+	}
+
+	private static <T extends ClassVisitor & Analyzer> boolean fromAnalyzer(InputStream is, T analyzer, McVersion.Builder builder) {
+		try {
+			ClassReader cr = new ClassReader(is);
+			cr.accept(analyzer, ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG);
+			String result = analyzer.getResult();
+
+			if (result != null) {
+				builder.setNameAndRelease(result);
+				return true;
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+		} finally {
+			try {
+				is.close();
+			} catch (IOException e) {
+				// ignored
+			}
+		}
+
+		return false;
+	}
+
+	protected static String getRelease(String version) {
+		if (RELEASE_PATTERN.matcher(version).matches()) return version;
+
+		assert isProbableVersion(version);
+
+		int pos = version.indexOf("-pre");
+		if (pos >= 0) return version.substring(0, pos);
+
+		pos = version.indexOf(" Pre-Release ");
+		if (pos >= 0) return version.substring(0, pos);
+
+		pos = version.indexOf(" Pre-release ");
+		if (pos >= 0) return version.substring(0, pos);
+
+		pos = version.indexOf(" Release Candidate ");
+		if (pos >= 0) return version.substring(0, pos);
+
+		Matcher matcher = SNAPSHOT_PATTERN.matcher(version);
+
+		if (matcher.matches()) {
+			int year = Integer.parseInt(matcher.group(1));
+			int week = Integer.parseInt(matcher.group(2));
+
+			if (year == 20 && week >= 6) {
+				return "1.16";
+			} else if (year == 19 && week >= 34) {
+				return "1.15";
+			} else if (year == 18 && week >= 43 || year == 19 && week <= 14) {
+				return "1.14";
+			} else if (year == 18 && week >= 30 && week <= 33) {
+				return "1.13.1";
+			} else if (year == 17 && week >= 43 || year == 18 && week <= 22) {
+				return "1.13";
+			} else if (year == 17 && week == 31) {
+				return "1.12.1";
+			} else if (year == 17 && week >= 6 && week <= 18) {
+				return "1.12";
+			} else if (year == 16 && week == 50) {
+				return "1.11.1";
+			} else if (year == 16 && week >= 32 && week <= 44) {
+				return "1.11";
+			} else if (year == 16 && week >= 20 && week <= 21) {
+				return "1.10";
+			} else if (year == 16 && week >= 14 && week <= 15) {
+				return "1.9.3";
+			} else if (year == 15 && week >= 31 || year == 16 && week <= 7) {
+				return "1.9";
+			} else if (year == 14 && week >= 2 && week <= 34) {
+				return "1.8";
+			} else if (year == 13 && week >= 47 && week <= 49) {
+				return "1.7.4";
+			} else if (year == 13 && week >= 36 && week <= 43) {
+				return "1.7.2";
+			} else if (year == 13 && week >= 16 && week <= 26) {
+				return "1.6";
+			} else if (year == 13 && week >= 11 && week <= 12) {
+				return "1.5.1";
+			} else if (year == 13 && week >= 1 && week <= 10) {
+				return "1.5";
+			} else if (year == 12 && week >= 49 && week <= 50) {
+				return "1.4.6";
+			} else if (year == 12 && week >= 32 && week <= 42) {
+				return "1.4.2";
+			} else if (year == 12 && week >= 15 && week <= 30) {
+				return "1.3.1";
+			} else if (year == 12 && week >= 3 && week <= 8) {
+				return "1.2.1";
+			} else if (year == 11 && week >= 47 || year == 12 && week <= 1) {
+				return "1.1";
+			}
+		}
+
+		return null;
+	}
+
+	private static boolean isProbableVersion(String str) {
+		return VERSION_PATTERN.matcher(str).matches();
+	}
+
+	/**
+	 * Returns the probable version contained in the given string, or null if the string doesn't contain a version.
+	 */
+	private static String findProbableVersion(String str) {
+		Matcher matcher = VERSION_PATTERN.matcher(str);
+
+		if (matcher.find()) {
+			return matcher.group();
+		} else {
+			return null;
+		}
+	}
+
+	/**
+	 * Convert an arbitrary MC version into semver-like release-preRelease form.
+	 *
+	 * <p>MC Snapshot -> alpha, MC Pre-Release -> rc.
+	 */
+	protected static String normalizeVersion(String name, String release) {
+		if (release == null || name.equals(release)) {
+			String ret = normalizeSpecialVersion(name);
+			return ret != null ? ret : normalizeVersion(name);
+		}
+
+		Matcher matcher;
+
+		if ((matcher = EXPERIMENTAL_PATTERN.matcher(name)).matches()) {
+			return String.format("%s-Experimental.%s", release, matcher.group(1));
+		} else if (name.startsWith(release)) {
+			matcher = RELEASE_CANDIDATE_PATTERN.matcher(name);
+
+			if (matcher.matches()) {
+				String rcBuild = matcher.group(1);
+
+				// This is a hack to fake 1.16's new release candidates to follow on from the 8 pre releases.
+				if (release.equals("1.16")) {
+					int build = Integer.parseInt(rcBuild);
+					rcBuild = Integer.toString(8 + build);
+				}
+
+				name = String.format("rc.%s", rcBuild);
+			} else {
+				matcher = PRE_RELEASE_PATTERN.matcher(name);
+
+				if (matcher.matches()) {
+					boolean legacyVersion;
+
+					try {
+						legacyVersion = VersionPredicateParser.parse("<=1.16").test(new SemanticVersionImpl(release, false));
+					} catch (Exception e) {
+						throw new RuntimeException("Failed to parse version: " + release);
+					}
+
+					// Mark pre-releases as 'beta' versions, except for version 1.16 and before, where they are 'rc'
+					if (legacyVersion) {
+						name = String.format("rc.%s", matcher.group(1));
+					} else {
+						name = String.format("beta.%s", matcher.group(1));
+					}
+				} else {
+					String ret = normalizeSpecialVersion(name);
+					if (ret != null) return ret;
+				}
+			}
+		} else if ((matcher = SNAPSHOT_PATTERN.matcher(name)).matches()) {
+			name = String.format("alpha.%s.%s.%s", matcher.group(1), matcher.group(2), matcher.group(3));
+		} else {
+			// Try short-circuiting special versions which are complete on their own
+			String ret = normalizeSpecialVersion(name);
+			if (ret != null) return ret;
+
+			name = normalizeVersion(name);
+		}
+
+		return String.format("%s-%s", release, name);
+	}
+
+	private static String normalizeVersion(String version) {
+		// old version normalization scheme
+		// do this before the main part of normalization as we can get crazy strings like "Indev 0.31 12345678-9"
+		Matcher matcher;
+
+		if ((matcher = BETA_PATTERN.matcher(version)).matches()) { // beta 1.2.3: 1.0.0-beta.2.3
+			version = "1.0.0-beta." + matcher.group(1);
+		} else if ((matcher = ALPHA_PATTERN.matcher(version)).matches()) { // alpha 1.2.3: 1.0.0-alpha.2.3
+			version = "1.0.0-alpha." + matcher.group(1);
+		} else if ((matcher = INDEV_PATTERN.matcher(version)).matches()) { // indev/infdev 12345678: 0.31.12345678
+			version = "0.31." + matcher.group(1);
+		} else if (version.startsWith("c0.")) { // classic: unchanged, except remove prefix
+			version = version.substring(1);
+		} else if (version.startsWith("rd-")) { // pre-classic
+			version = version.substring("rd-".length());
+			if ("20090515".equals(version)) version = "150000"; // account for a weird exception to the pre-classic versioning scheme
+			version = "0.0.0-rd." + version;
+		}
+
+		StringBuilder ret = new StringBuilder(version.length() + 5);
+		boolean lastIsDigit = false;
+		boolean lastIsLeadingZero = false;
+		boolean lastIsSeparator = false;
+
+		for (int i = 0, max = version.length(); i < max; i++) {
+			char c = version.charAt(i);
+
+			if (c >= '0' && c <= '9') {
+				if (i > 0 && !lastIsDigit && !lastIsSeparator) { // no separator between non-number and number, add one
+					ret.append('.');
+				} else if (lastIsDigit && lastIsLeadingZero) { // leading zero in output -> strip
+					ret.setLength(ret.length() - 1);
+				}
+
+				lastIsLeadingZero = c == '0' && (!lastIsDigit || lastIsLeadingZero); // leading or continued leading zero(es)
+				lastIsSeparator = false;
+				lastIsDigit = true;
+			} else if (c == '.' || c == '-') { // keep . and - separators
+				if (lastIsSeparator) continue;
+
+				lastIsSeparator = true;
+				lastIsDigit = false;
+			} else if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z')) { // replace remaining non-alphanumeric with .
+				if (lastIsSeparator) continue;
+
+				c = '.';
+				lastIsSeparator = true;
+				lastIsDigit = false;
+			} else { // keep other characters (alpha)
+				if (lastIsDigit) ret.append('.'); // no separator between number and non-number, add one
+
+				lastIsSeparator = false;
+				lastIsDigit = false;
+			}
+
+			ret.append(c);
+		}
+
+		// strip leading and trailing .
+
+		int start = 0;
+		while (start < ret.length() && ret.charAt(start) == '.') start++;
+
+		int end = ret.length();
+		while (end > start && ret.charAt(end - 1) == '.') end--;
+
+		return ret.substring(start, end);
+	}
+
+	private static String normalizeSpecialVersion(String version) {
+		switch (version) {
+		case "13w12~":
+			// A pair of debug snapshots immediately before 1.5.1-pre
+			return "1.5.1-alpha.13.12.a";
+
+		case "15w14a":
+			// The Love and Hugs Update, forked from 1.8.3
+			return "1.8.4-alpha.15.14.a+loveandhugs";
+
+		case "1.RV-Pre1":
+			// The Trendy Update, probably forked from 1.9.2 (although the protocol/data versions immediately follow 1.9.1-pre3)
+			return "1.9.2-rv+trendy";
+
+		case "3D Shareware v1.34":
+			// Minecraft 3D, forked from 19w13b
+			return "1.14-alpha.19.13.shareware";
+
+		case "20w14~":
+			// The Ultimate Content update, forked from 20w13b
+			return "1.16-alpha.20.13.inf"; // Not to be confused with the actual 20w14a
+
+		case "1.14.3 - Combat Test":
+			// The first Combat Test, forked from 1.14.3 Pre-Release 4
+			return "1.14.3-rc.4.combat.1";
+
+		case "Combat Test 2":
+			// The second Combat Test, forked from 1.14.4
+			return "1.14.5-combat.2";
+
+		case "Combat Test 3":
+			// The third Combat Test, forked from 1.14.4
+			return "1.14.5-combat.3";
+
+		case "Combat Test 4":
+			// The fourth Combat Test, forked from 1.15 Pre-release 3
+			return "1.15-rc.3.combat.4";
+
+		case "Combat Test 5":
+			// The fifth Combat Test, forked from 1.15.2 Pre-release 2
+			return "1.15.2-rc.2.combat.5";
+
+		case "Combat Test 6":
+			// The sixth Combat Test, forked from 1.16.2 Pre-release 3
+			return "1.16.2-beta.3.combat.6";
+
+		case "Combat Test 7":
+			// Private testing Combat Test 7, forked from 1.16.2
+			return "1.16.3-combat.7";
+
+		case "1.16_combat-2":
+			// Private testing Combat Test 7b, forked from 1.16.2
+			return "1.16.3-combat.7.b";
+
+		case "1.16_combat-3":
+			// The seventh Combat Test 7c, forked from 1.16.2
+			return "1.16.3-combat.7.c";
+
+		case "1.16_combat-4":
+			// Private testing Combat Test 8(a?), forked from 1.16.2
+			return "1.16.3-combat.8";
+
+		case "1.16_combat-5":
+			// The eighth Combat Test 8b, forked from 1.16.2
+			return "1.16.3-combat.8.b";
+
+		case "1.16_combat-6":
+			// The ninth Combat Test 8c, forked from 1.16.2
+			return "1.16.3-combat.8.c";
+
+		case "2point0_red":
+			// 2.0 update version red, forked from 1.5.1
+			return "1.5.2-red";
+
+		case "2point0_purple":
+			// 2.0 update version purple, forked from 1.5.1
+			return "1.5.2-purple";
+
+		case "2point0_blue":
+			// 2.0 update version blue, forked from 1.5.1
+			return "1.5.2-blue";
+
+		default:
+			return null; //Don't recognise the version
+		}
+	}
+
+	private interface Analyzer {
+		String getResult();
+	}
+
+	private static final class FieldStringConstantVisitor extends ClassVisitor implements Analyzer {
+		FieldStringConstantVisitor(String fieldName) {
+			super(FabricLoaderImpl.ASM_VERSION);
+
+			this.fieldName = fieldName;
+		}
+
+		@Override
+		public String getResult() {
+			return result;
+		}
+
+		@Override
+		public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
+			this.className = name;
+		}
+
+		@Override
+		public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {
+			if (result == null && name.equals(fieldName) && descriptor.equals(STRING_DESC) && value instanceof String) {
+				result = (String) value;
+			}
+
+			return null;
+		}
+
+		@Override
+		public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
+			if (result != null || !name.equals("<clinit>")) return null;
+
+			// capture LDC ".." followed by PUTSTATIC this.fieldName
+			return new InsnFwdMethodVisitor() {
+				@Override
+				public void visitLdcInsn(Object value) {
+					String str;
+
+					if (value instanceof String && isProbableVersion(str = (String) value)) {
+						lastLdc = str;
+					} else {
+						lastLdc = null;
+					}
+				}
+
+				@Override
+				public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {
+					if (result == null
+							&& lastLdc != null
+							&& opcode == Opcodes.PUTSTATIC
+							&& owner.equals(className)
+							&& name.equals(fieldName)
+							&& descriptor.equals(STRING_DESC)) {
+						result = lastLdc;
+					}
+
+					lastLdc = null;
+				}
+
+				@Override
+				protected void visitAnyInsn() {
+					lastLdc = null;
+				}
+
+				String lastLdc;
+			};
+		}
+
+		private final String fieldName;
+		private String className;
+		private String result;
+	}
+
+	private static final class MethodStringConstantContainsVisitor extends ClassVisitor implements Analyzer {
+		MethodStringConstantContainsVisitor(String methodOwner, String methodName) {
+			super(FabricLoaderImpl.ASM_VERSION);
+
+			this.methodOwner = methodOwner;
+			this.methodName = methodName;
+		}
+
+		@Override
+		public String getResult() {
+			return result;
+		}
+
+		@Override
+		public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
+			if (result != null) return null;
+
+			// capture LDC ".." followed by INVOKE methodOwner.methodName
+			return new InsnFwdMethodVisitor() {
+				@Override
+				public void visitLdcInsn(Object value) {
+					if (value instanceof String) {
+						lastLdc = findProbableVersion((String) value);
+					} else {
+						lastLdc = null;
+					}
+				}
+
+				@Override
+				public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean itf) {
+					if (result == null
+							&& lastLdc != null
+							&& owner.equals(methodOwner)
+							&& name.equals(methodName)
+							&& descriptor.startsWith("(" + STRING_DESC + ")")) {
+						result = lastLdc;
+					}
+
+					lastLdc = null;
+				}
+
+				@Override
+				protected void visitAnyInsn() {
+					lastLdc = null;
+				}
+
+				String lastLdc;
+			};
+		}
+
+		private final String methodOwner;
+		private final String methodName;
+		private String result;
+	}
+
+	private static final class MethodConstantRetVisitor extends ClassVisitor implements Analyzer {
+		MethodConstantRetVisitor(String methodName) {
+			super(FabricLoaderImpl.ASM_VERSION);
+
+			this.methodName = methodName;
+		}
+
+		@Override
+		public String getResult() {
+			return result;
+		}
+
+		@Override
+		public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
+			if (result != null
+					|| methodName != null && !name.equals(methodName)
+					|| !descriptor.endsWith(STRING_DESC)
+					|| descriptor.charAt(descriptor.length() - STRING_DESC.length() - 1) != ')') {
+				return null;
+			}
+
+			// capture LDC ".." followed by ARETURN
+			return new InsnFwdMethodVisitor() {
+				@Override
+				public void visitLdcInsn(Object value) {
+					String str;
+
+					if (value instanceof String && isProbableVersion(str = (String) value)) {
+						lastLdc = str;
+					} else {
+						lastLdc = null;
+					}
+				}
+
+				@Override
+				public void visitInsn(int opcode) {
+					if (result == null
+							&& lastLdc != null
+							&& opcode == Opcodes.ARETURN) {
+						result = lastLdc;
+					}
+
+					lastLdc = null;
+				}
+
+				@Override
+				protected void visitAnyInsn() {
+					lastLdc = null;
+				}
+
+				String lastLdc;
+			};
+		}
+
+		private final String methodName;
+		private String result;
+	}
+
+	private static final class MethodConstantVisitor extends ClassVisitor implements Analyzer {
+		private static final String STARTING_MESSAGE = "Starting minecraft server version ";
+
+		MethodConstantVisitor(String methodNameHint) {
+			super(FabricLoaderImpl.ASM_VERSION);
+
+			this.methodNameHint = methodNameHint;
+		}
+
+		@Override
+		public String getResult() {
+			return result;
+		}
+
+		@Override
+		public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
+			final boolean isRequestedMethod = name.equals(methodNameHint);
+
+			if (result != null && !isRequestedMethod) {
+				return null;
+			}
+
+			return new MethodVisitor(FabricLoaderImpl.ASM_VERSION) {
+				@Override
+				public void visitLdcInsn(Object value) {
+					if ((result == null || !foundInMethodHint && isRequestedMethod) && value instanceof String) {
+						String str = (String) value;
+
+						// a0.1.0 - 1.2.5 have a startup message including the version, extract it from there
+						// Examples:
+						//  release 1.0.0 - Starting minecraft server version 1.0.0
+						// 	beta 1.7.3 - Starting minecraft server version Beta 1.7.3
+						// 	alpha 0.2.8 - Starting minecraft server version 0.2.8
+						if (str.startsWith(STARTING_MESSAGE)) {
+							str = str.substring(STARTING_MESSAGE.length());
+
+							// Alpha servers don't have any prefix, but they all have 0 as the major
+							if (!str.startsWith("Beta") && str.startsWith("0.")) {
+								str = "Alpha " + str;
+							}
+						}
+
+						// 1.0.0 - 1.13.2 have an obfuscated method that just returns the version, so we can use that
+
+						if (isProbableVersion(str)) {
+							result = str;
+							foundInMethodHint = isRequestedMethod;
+						}
+					}
+				}
+			};
+		}
+
+		private final String methodNameHint;
+		private String result;
+		private boolean foundInMethodHint;
+	}
+
+	private abstract static class InsnFwdMethodVisitor extends MethodVisitor {
+		InsnFwdMethodVisitor() {
+			super(FabricLoaderImpl.ASM_VERSION);
+		}
+
+		protected abstract void visitAnyInsn();
+
+		@Override
+		public void visitLdcInsn(Object value) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitInsn(int opcode) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitIntInsn(int opcode, int operand) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitVarInsn(int opcode, int var) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitTypeInsn(int opcode, String type) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitJumpInsn(int opcode, Label label) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitIincInsn(int var, int increment) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
+			visitAnyInsn();
+		}
+
+		@Override
+		public void visitMultiANewArrayInsn(String descriptor, int numDimensions) {
+			visitAnyInsn();
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/minecraft/MinecraftGameProvider.java b/src/main/java/net/fabricmc/loader/impl/game/minecraft/MinecraftGameProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f8403a297cb60bb8da860becad532549ae9b416
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/minecraft/MinecraftGameProvider.java
@@ -0,0 +1,459 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.minecraft;
+
+import joptsimple.OptionSet;
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.ObjectShare;
+import net.fabricmc.loader.api.metadata.ModDependency;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.FormattedException;
+import net.fabricmc.loader.impl.game.GameProvider;
+import net.fabricmc.loader.impl.game.GameProviderHelper;
+import net.fabricmc.loader.impl.game.LibClassifier;
+import net.fabricmc.loader.impl.game.patch.BrandingPatch;
+import net.fabricmc.loader.impl.game.patch.GameTransformer;
+import net.fabricmc.loader.impl.launch.FabricLauncher;
+import net.fabricmc.loader.impl.metadata.BuiltinModMetadata;
+import net.fabricmc.loader.impl.metadata.ModDependencyImpl;
+import net.fabricmc.loader.impl.util.Arguments;
+import net.fabricmc.loader.impl.util.ExceptionUtil;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import net.fabricmc.loader.impl.util.log.LogHandler;
+import net.minecraft.server.Main;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.net.URISyntaxException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+
+public class MinecraftGameProvider implements GameProvider {
+	private static final String[] ALLOWED_EARLY_CLASS_PREFIXES = { "org.apache.logging.log4j.", "com.mojang.util." };
+
+	private static final Set<String> SENSITIVE_ARGS = new HashSet<>(Arrays.asList(
+			// all lowercase without --
+			"accesstoken",
+			"clientid",
+			"profileproperties",
+			"proxypass",
+			"proxyuser",
+			"username",
+			"userproperties",
+			"uuid",
+			"xuid"));
+
+	private EnvType envType;
+	private String entrypoint;
+	private Arguments arguments;
+	private final List<Path> gameJars = new ArrayList<>(2); // env game jar and potentially common game jar
+	private Path realmsJar;
+	private final Set<Path> logJars = new HashSet<>();
+	private boolean log4jAvailable;
+	private boolean slf4jAvailable;
+	private final List<Path> miscGameLibraries = new ArrayList<>(); // libraries not relevant for loader's uses
+	private Collection<Path> validParentClassPath; // computed parent class path restriction (loader+deps)
+	private McVersion versionData;
+	private boolean hasModLoader = false;
+
+	private static final GameTransformer TRANSFORMER = new GameTransformer(
+			new BrandingPatch());
+
+	@Override
+	public String getGameId() {
+		return "minecraft";
+	}
+
+	@Override
+	public String getGameName() {
+		return "Minecraft";
+	}
+
+	@Override
+	public String getRawGameVersion() {
+		return versionData.getRaw();
+	}
+
+	@Override
+	public String getNormalizedGameVersion() {
+		return versionData.getNormalized();
+	}
+
+	@Override
+	public Collection<BuiltinMod> getBuiltinMods() {
+		BuiltinModMetadata.Builder metadata = new BuiltinModMetadata.Builder(getGameId(), getNormalizedGameVersion())
+				.setName(getGameName());
+
+		if (versionData.getClassVersion().isPresent()) {
+			int version = versionData.getClassVersion().getAsInt() - 44;
+
+			try {
+				metadata.addDependency(new ModDependencyImpl(ModDependency.Kind.DEPENDS, "java", Collections.singletonList(String.format(">=%d", version))));
+			} catch (Throwable e) {
+				throw new RuntimeException(e);
+			}
+        }
+
+		return Collections.singletonList(new BuiltinMod(gameJars, metadata.build()));
+	}
+
+	public Path getGameJar() {
+		return gameJars.get(0);
+	}
+
+	@Override
+	public String getEntrypoint() {
+		return entrypoint;
+	}
+
+	@Override
+	public Path getLaunchDirectory() {
+		if (arguments == null) {
+			return Paths.get(".");
+		}
+
+		return getLaunchDirectory(arguments);
+	}
+
+	@Override
+	public boolean isObfuscated() {
+		return true; // generally yes...
+	}
+
+	@Override
+	public boolean requiresUrlClassLoader() {
+		return hasModLoader;
+	}
+
+	@Override
+	public boolean isEnabled() {
+		return System.getProperty(SystemProperties.SKIP_MC_PROVIDER) == null;
+	}
+
+	@Override
+	public boolean locateGame(FabricLauncher launcher, String[] args) {
+		this.envType = launcher.getEnvironmentType();
+		this.arguments = new Arguments();
+		arguments.parse(args);
+
+		try {
+			LibClassifier<McLibrary> classifier = new LibClassifier<>(McLibrary.class, envType, this);
+			McLibrary envGameLib = McLibrary.MC_SERVER;
+			Path commonGameJar = null;
+			Path envGameJar = new File(org.bukkit.craftbukkit.Main.class.getProtectionDomain().getCodeSource().getLocation()
+                .toURI()).toPath();
+			boolean commonGameJarDeclared = commonGameJar != null;
+
+			if (commonGameJarDeclared) {
+				if (envGameJar != null) {
+					classifier.process(envGameJar, McLibrary.MC_COMMON);
+				}
+
+				classifier.process(commonGameJar);
+			} else if (envGameJar != null) {
+				classifier.process(envGameJar);
+			}
+
+			classifier.process(launcher.getClassPath());
+
+			if (classifier.has(McLibrary.MC_BUNDLER)) {
+				BundlerProcessor.process(classifier);
+			}
+
+			//envGameJar = classifier.getOrigin(envGameLib);
+			if (envGameJar == null) return false;
+
+			commonGameJar = classifier.getOrigin(McLibrary.MC_COMMON);
+
+			if (commonGameJarDeclared && commonGameJar == null) {
+				Log.warn(LogCategory.GAME_PROVIDER, "The declared common game jar didn't contain any of the expected classes!");
+			}
+
+			gameJars.add(envGameJar);
+
+			if (commonGameJar != null && !commonGameJar.equals(envGameJar)) {
+				gameJars.add(commonGameJar);
+			}
+
+			entrypoint = classifier.getClassName(envGameLib);
+			realmsJar = classifier.getOrigin(McLibrary.REALMS);
+			hasModLoader = classifier.has(McLibrary.MODLOADER);
+			boolean hasLogLib = log4jAvailable || slf4jAvailable;
+
+			Log.configureBuiltin(hasLogLib, !hasLogLib);
+
+			for (McLibrary lib : McLibrary.LOGGING) {
+				Path path = classifier.getOrigin(lib);
+
+				if (path != null) {
+					if (hasLogLib) {
+						logJars.add(path);
+					} else if (!gameJars.contains(path)) {
+						miscGameLibraries.add(path);
+					}
+				}
+			}
+
+			miscGameLibraries.addAll(classifier.getUnmatchedOrigins());
+			validParentClassPath = classifier.getLoaderOrigins();
+		} catch (IOException e) {
+			throw ExceptionUtil.wrap(e);
+		} catch (URISyntaxException e) {
+            throw new RuntimeException(e);
+        }
+
+        // expose obfuscated jar locations for mods to more easily remap code from obfuscated to intermediary
+		ObjectShare share = FabricLoaderImpl.INSTANCE.getObjectShare();
+		share.put("fabric-loader:inputGameJar", gameJars.get(0)); // deprecated
+		share.put("fabric-loader:inputGameJars", gameJars);
+		if (realmsJar != null) share.put("fabric-loader:inputRealmsJar", realmsJar);
+
+		String version = arguments.remove(Arguments.GAME_VERSION);
+		if (version == null) version = System.getProperty(SystemProperties.GAME_VERSION);
+		versionData = McVersionLookup.getVersion(gameJars, entrypoint, version);
+
+		processArgumentMap(arguments, envType);
+
+		return true;
+	}
+
+	private static void processArgumentMap(Arguments argMap, EnvType envType) {
+		switch (envType) {
+		case CLIENT:
+			if (!argMap.containsKey("accessToken")) {
+				argMap.put("accessToken", "FabricMC");
+			}
+
+			if (!argMap.containsKey("version")) {
+				argMap.put("version", "Fabric");
+			}
+
+			String versionType = "";
+
+			if (argMap.containsKey("versionType") && !argMap.get("versionType").equalsIgnoreCase("release")) {
+				versionType = argMap.get("versionType") + "/";
+			}
+
+			argMap.put("versionType", versionType + "Fabric");
+
+			if (!argMap.containsKey("gameDir")) {
+				argMap.put("gameDir", getLaunchDirectory(argMap).toAbsolutePath().normalize().toString());
+			}
+
+			break;
+		case SERVER:
+			argMap.remove("version");
+			argMap.remove("gameDir");
+			argMap.remove("assetsDir");
+			break;
+		}
+	}
+
+	private static Path getLaunchDirectory(Arguments argMap) {
+		return Paths.get(argMap.getOrDefault("gameDir", "."));
+	}
+
+	@Override
+	public void initialize(FabricLauncher launcher) {
+		launcher.setValidParentClassPath(validParentClassPath);
+
+		if (isObfuscated()) {
+			Map<String, Path> obfJars = new HashMap<>(3);
+			String[] names = new String[gameJars.size()];
+
+			for (int i = 0; i < gameJars.size(); i++) {
+				String name;
+
+				if (i == 0) {
+					name = envType.name().toLowerCase(Locale.ENGLISH);
+				} else if (i == 1) {
+					name = "common";
+				} else {
+					name = String.format("extra-%d", i - 2);
+				}
+
+				obfJars.put(name, gameJars.get(i));
+				names[i] = name;
+			}
+
+			if (realmsJar != null) {
+				obfJars.put("realms", realmsJar);
+			}
+
+			obfJars = GameProviderHelper.deobfuscate(obfJars,
+					getGameId(), getNormalizedGameVersion(),
+					getLaunchDirectory(),
+					launcher);
+
+			for (int i = 0; i < gameJars.size(); i++) {
+				Path newJar = obfJars.get(names[i]);
+				Path oldJar = gameJars.set(i, newJar);
+
+				if (logJars.remove(oldJar)) logJars.add(newJar);
+			}
+
+			realmsJar = obfJars.get("realms");
+		}
+
+		if (!logJars.isEmpty()) {
+			for (Path jar : logJars) {
+				if (gameJars.contains(jar)) {
+					launcher.addToClassPath(jar, ALLOWED_EARLY_CLASS_PREFIXES);
+				} else {
+					launcher.addToClassPath(jar);
+				}
+			}
+		}
+
+		setupLogHandler(launcher, true);
+
+		TRANSFORMER.locateEntrypoints(launcher, gameJars);
+	}
+
+	private void setupLogHandler(FabricLauncher launcher, boolean useTargetCl) {
+		System.setProperty("log4j2.formatMsgNoLookups", "true"); // lookups are not used by mc and cause issues with older log4j2 versions
+
+		try {
+			final String logHandlerClsName;
+
+            log4jAvailable = false;
+            slf4jAvailable = false;
+			if (log4jAvailable) {
+				logHandlerClsName = "net.fabricmc.loader.impl.game.minecraft.Log4jLogHandler";
+			} else if (slf4jAvailable) {
+				logHandlerClsName = "net.fabricmc.loader.impl.game.minecraft.Slf4jLogHandler";
+			} else {
+				return;
+			}
+
+			ClassLoader prevCl = Thread.currentThread().getContextClassLoader();
+			Class<?> logHandlerCls;
+
+			if (useTargetCl) {
+				Thread.currentThread().setContextClassLoader(launcher.getTargetClassLoader());
+				logHandlerCls = launcher.loadIntoTarget(logHandlerClsName);
+			} else {
+				logHandlerCls = Class.forName(logHandlerClsName);
+			}
+
+			Log.init((LogHandler) logHandlerCls.getConstructor().newInstance());
+			Thread.currentThread().setContextClassLoader(prevCl);
+		} catch (ReflectiveOperationException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	@Override
+	public Arguments getArguments() {
+		return arguments;
+	}
+
+	@Override
+	public String[] getLaunchArguments(boolean sanitize) {
+		if (arguments == null) return new String[0];
+
+		String[] ret = arguments.toArray();
+		if (!sanitize) return ret;
+
+		int writeIdx = 0;
+
+		for (int i = 0; i < ret.length; i++) {
+			String arg = ret[i];
+
+			if (i + 1 < ret.length
+					&& arg.startsWith("--")
+					&& SENSITIVE_ARGS.contains(arg.substring(2).toLowerCase(Locale.ENGLISH))) {
+				i++; // skip value
+			} else {
+				ret[writeIdx++] = arg;
+			}
+		}
+
+		if (writeIdx < ret.length) ret = Arrays.copyOf(ret, writeIdx);
+
+		return ret;
+	}
+
+	@Override
+	public GameTransformer getEntrypointTransformer() {
+		return TRANSFORMER;
+	}
+
+	@Override
+	public boolean canOpenErrorGui() {
+		if (arguments == null || envType == EnvType.CLIENT) {
+			return true;
+		}
+
+		List<String> extras = arguments.getExtraArgs();
+		return !extras.contains("nogui") && !extras.contains("--nogui");
+	}
+
+	@Override
+	public boolean hasAwtSupport() {
+		// MC always sets -XstartOnFirstThread for LWJGL
+		return !LoaderUtil.hasMacOs();
+	}
+
+	@Override
+	public void unlockClassPath(FabricLauncher launcher) {
+		for (Path gameJar : gameJars) {
+			if (logJars.contains(gameJar)) {
+				launcher.setAllowedPrefixes(gameJar);
+			} else {
+				launcher.addToClassPath(gameJar);
+			}
+		}
+
+		if (realmsJar != null) launcher.addToClassPath(realmsJar);
+
+		for (Path lib : miscGameLibraries) {
+			launcher.addToClassPath(lib);
+		}
+	}
+
+	@Override
+	public void launch(ClassLoader loader) {
+		String targetClass = entrypoint;
+
+		if (envType == EnvType.CLIENT && targetClass.contains("Applet")) {
+			targetClass = "net.fabricmc.loader.impl.game.minecraft.applet.AppletMain";
+		}
+
+		MethodHandle invoker;
+
+		try {
+			Class<?> c = Main.class;
+			invoker = MethodHandles.lookup().findStatic(c, "main", MethodType.methodType(void.class, OptionSet.class));
+		} catch (NoSuchMethodException | IllegalAccessException e) {
+			throw new FormattedException("Failed to start Minecraft", e);
+		}
+
+		try {
+			invoker.invokeExact(arguments.toArray());
+		} catch (Throwable t) {
+			throw new FormattedException("Minecraft has crashed!", t);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/patch/BrandingPatch.java b/src/main/java/net/fabricmc/loader/impl/game/patch/BrandingPatch.java
new file mode 100644
index 0000000000000000000000000000000000000000..00d3e0207f526ee733313a883ef5ad4ad766fc32
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/patch/BrandingPatch.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.patch;
+
+import net.fabricmc.loader.impl.game.minecraft.Hooks;
+import net.fabricmc.loader.impl.launch.FabricLauncher;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.tree.AbstractInsnNode;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.MethodInsnNode;
+import org.objectweb.asm.tree.MethodNode;
+
+import java.util.ListIterator;
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+public final class BrandingPatch extends GamePatch {
+	@Override
+	public void process(FabricLauncher launcher, Function<String, ClassReader> classSource, Consumer<ClassNode> classEmitter) {
+		for (String brandClassName : new String[] {
+				"net.minecraft.client.ClientBrandRetriever",
+				"net.minecraft.server.MinecraftServer"
+		}) {
+			ClassNode brandClass = readClass(classSource.apply(brandClassName));
+
+			if (brandClass != null) {
+				if (applyBrandingPatch(brandClass)) {
+					classEmitter.accept(brandClass);
+				}
+			}
+		}
+	}
+
+	private boolean applyBrandingPatch(ClassNode classNode) {
+		boolean applied = false;
+
+		for (MethodNode node : classNode.methods) {
+			if (node.name.equals("getClientModName") || node.name.equals("getServerModName") && node.desc.endsWith(")Ljava/lang/String;")) {
+				Log.debug(LogCategory.GAME_PATCH, "Applying brand name hook to %s::%s", classNode.name, node.name);
+
+				ListIterator<AbstractInsnNode> it = node.instructions.iterator();
+
+				while (it.hasNext()) {
+					if (it.next().getOpcode() == Opcodes.ARETURN) {
+						it.previous();
+						it.add(new MethodInsnNode(Opcodes.INVOKESTATIC, Hooks.INTERNAL_NAME, "insertBranding", "(Ljava/lang/String;)Ljava/lang/String;", false));
+						it.next();
+					}
+				}
+
+				applied = true;
+			}
+		}
+
+		return applied;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/patch/GamePatch.java b/src/main/java/net/fabricmc/loader/impl/game/patch/GamePatch.java
new file mode 100644
index 0000000000000000000000000000000000000000..d0fcc1b6ff51e892adbb8cb7b8e1e6f7c7cc8f6b
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/patch/GamePatch.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.patch;
+
+import net.fabricmc.loader.impl.launch.FabricLauncher;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.tree.AbstractInsnNode;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.FieldNode;
+import org.objectweb.asm.tree.MethodNode;
+
+import java.util.List;
+import java.util.ListIterator;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+
+public abstract class GamePatch {
+	protected static ClassNode readClass(ClassReader reader) {
+		if (reader == null) return null;
+
+		ClassNode node = new ClassNode();
+		reader.accept(node, 0);
+		return node;
+	}
+
+	protected FieldNode findField(ClassNode node, Predicate<FieldNode> predicate) {
+		return node.fields.stream().filter(predicate).findAny().orElse(null);
+	}
+
+	protected List<FieldNode> findFields(ClassNode node, Predicate<FieldNode> predicate) {
+		return node.fields.stream().filter(predicate).collect(Collectors.toList());
+	}
+
+	protected MethodNode findMethod(ClassNode node, Predicate<MethodNode> predicate) {
+		return node.methods.stream().filter(predicate).findAny().orElse(null);
+	}
+
+	protected AbstractInsnNode findInsn(MethodNode node, Predicate<AbstractInsnNode> predicate, boolean last) {
+		if (last) {
+			for (int i = node.instructions.size() - 1; i >= 0; i--) {
+				AbstractInsnNode insn = node.instructions.get(i);
+
+				if (predicate.test(insn)) {
+					return insn;
+				}
+			}
+		} else {
+			for (int i = 0; i < node.instructions.size(); i++) {
+				AbstractInsnNode insn = node.instructions.get(i);
+
+				if (predicate.test(insn)) {
+					return insn;
+				}
+			}
+		}
+
+		return null;
+	}
+
+	protected void moveAfter(ListIterator<AbstractInsnNode> it, int opcode) {
+		while (it.hasNext()) {
+			AbstractInsnNode node = it.next();
+
+			if (node.getOpcode() == opcode) {
+				break;
+			}
+		}
+	}
+
+	protected void moveBefore(ListIterator<AbstractInsnNode> it, int opcode) {
+		moveAfter(it, opcode);
+		it.previous();
+	}
+
+	protected void moveAfter(ListIterator<AbstractInsnNode> it, AbstractInsnNode targetNode) {
+		while (it.hasNext()) {
+			AbstractInsnNode node = it.next();
+
+			if (node == targetNode) {
+				break;
+			}
+		}
+	}
+
+	protected void moveBefore(ListIterator<AbstractInsnNode> it, AbstractInsnNode targetNode) {
+		moveAfter(it, targetNode);
+		it.previous();
+	}
+
+	protected void moveBeforeType(ListIterator<AbstractInsnNode> it, int nodeType) {
+		while (it.hasPrevious()) {
+			AbstractInsnNode node = it.previous();
+
+			if (node.getType() == nodeType) {
+				break;
+			}
+		}
+	}
+
+	protected boolean isStatic(int access) {
+		return ((access & Opcodes.ACC_STATIC) != 0);
+	}
+
+	protected boolean isPublicStatic(int access) {
+		return ((access & 0x0F) == (Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC));
+	}
+
+	protected boolean isPublicInstance(int access) {
+		//noinspection PointlessBitwiseExpression
+		return ((access & 0x0F) == (Opcodes.ACC_PUBLIC | 0 /* non-static */));
+	}
+
+	public abstract void process(FabricLauncher launcher, Function<String, ClassReader> classSource, Consumer<ClassNode> classEmitter);
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/game/patch/GameTransformer.java b/src/main/java/net/fabricmc/loader/impl/game/patch/GameTransformer.java
new file mode 100644
index 0000000000000000000000000000000000000000..f2c18025a90213958490a8cabb6e3386d0411254
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/game/patch/GameTransformer.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.game.patch;
+
+import net.fabricmc.loader.impl.launch.FabricLauncher;
+import net.fabricmc.loader.impl.util.ExceptionUtil;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SimpleClassPath;
+import net.fabricmc.loader.impl.util.SimpleClassPath.CpEntry;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassWriter;
+import org.objectweb.asm.tree.ClassNode;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.zip.ZipError;
+
+public class GameTransformer {
+	private final List<GamePatch> patches;
+	private Map<String, byte[]> patchedClasses;
+	private boolean entrypointsLocated = false;
+
+	public GameTransformer(GamePatch... patches) {
+		this.patches = Arrays.asList(patches);
+	}
+
+	private void addPatchedClass(ClassNode node) {
+		String key = node.name.replace('/', '.');
+
+		if (patchedClasses.containsKey(key)) {
+			throw new RuntimeException("Duplicate addPatchedClasses call: " + key);
+		}
+
+		ClassWriter writer = new ClassWriter(0);
+		node.accept(writer);
+		patchedClasses.put(key, writer.toByteArray());
+	}
+
+	public void locateEntrypoints(FabricLauncher launcher, List<Path> gameJars) {
+		if (entrypointsLocated) {
+			return;
+		}
+
+		patchedClasses = new HashMap<>();
+
+		try (SimpleClassPath cp = new SimpleClassPath(gameJars)) {
+			Function<String, ClassReader> classSource = name -> {
+				byte[] data = patchedClasses.get(name);
+
+				if (data != null) {
+					return new ClassReader(data);
+				}
+
+				try {
+					CpEntry entry = cp.getEntry(LoaderUtil.getClassFileName(name));
+					if (entry == null) return null;
+
+					try (InputStream is = entry.getInputStream()) {
+						return new ClassReader(is);
+					} catch (IOException | ZipError e) {
+						throw new RuntimeException(String.format("error reading %s in %s: %s", name, LoaderUtil.normalizePath(entry.getOrigin()), e), e);
+					}
+				} catch (IOException e) {
+					throw ExceptionUtil.wrap(e);
+				}
+			};
+
+			for (GamePatch patch : patches) {
+				patch.process(launcher, classSource, this::addPatchedClass);
+			}
+		} catch (IOException e) {
+			throw ExceptionUtil.wrap(e);
+		}
+
+		Log.debug(LogCategory.GAME_PATCH, "Patched %d class%s", patchedClasses.size(), patchedClasses.size() != 1 ? "s" : "");
+		entrypointsLocated = true;
+	}
+
+	/**
+	 * This must run first, contractually!
+	 * @param className The class name,
+	 * @return The transformed class data.
+	 */
+	public byte[] transform(String className) {
+		return patchedClasses.get(className);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/gui/FabricGuiEntry.java b/src/main/java/net/fabricmc/loader/impl/gui/FabricGuiEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..0bc13e0d5b277f319ea2b8c6ee60072c8ad29afd
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/gui/FabricGuiEntry.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.gui;
+
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.game.GameProvider;
+import net.fabricmc.loader.impl.gui.FabricStatusTree.FabricBasicButtonType;
+import net.fabricmc.loader.impl.gui.FabricStatusTree.FabricStatusTab;
+import net.fabricmc.loader.impl.gui.FabricStatusTree.FabricTreeWarningLevel;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.UrlUtil;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.awt.*;
+import java.io.*;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.function.Consumer;
+
+/** The main entry point for all fabric-based stuff. */
+public final class FabricGuiEntry {
+	/** Opens the given {@link FabricStatusTree} in a new swing window.
+	 *
+	 * @throws Exception if something went wrong while opening the window. */
+	public static void open(FabricStatusTree tree) throws Exception {
+		GameProvider provider = FabricLoaderImpl.INSTANCE.tryGetGameProvider();
+
+		if (provider == null && LoaderUtil.hasAwtSupport()
+				|| provider != null && provider.hasAwtSupport()) {
+			FabricMainWindow.open(tree, true);
+		} else {
+			openForked(tree);
+		}
+	}
+
+	private static void openForked(FabricStatusTree tree) throws IOException, InterruptedException {
+		Path javaBinDir = LoaderUtil.normalizePath(Paths.get(System.getProperty("java.home"), "bin"));
+		String[] executables = { "javaw.exe", "java.exe", "java" };
+		Path javaPath = null;
+
+		for (String executable : executables) {
+			Path path = javaBinDir.resolve(executable);
+
+			if (Files.isRegularFile(path)) {
+				javaPath = path;
+				break;
+			}
+		}
+
+		if (javaPath == null) throw new RuntimeException("can't find java executable in "+javaBinDir);
+
+		Process process = new ProcessBuilder(javaPath.toString(), "-Xmx100M", "-cp", UrlUtil.LOADER_CODE_SOURCE.toString(), FabricGuiEntry.class.getName())
+				.redirectOutput(ProcessBuilder.Redirect.INHERIT)
+				.redirectError(ProcessBuilder.Redirect.INHERIT)
+				.start();
+
+		try (DataOutputStream os = new DataOutputStream(process.getOutputStream())) {
+			tree.writeTo(os);
+		}
+
+		int rVal = process.waitFor();
+		if (rVal != 0) throw new IOException("subprocess exited with code "+rVal);
+	}
+
+	public static void main(String[] args) throws Exception {
+		FabricStatusTree tree = new FabricStatusTree(new DataInputStream(System.in));
+		FabricMainWindow.open(tree, true);
+		System.exit(0);
+	}
+
+	/** @param exitAfter If true then this will call {@link System#exit(int)} after showing the gui, otherwise this will
+	 *            return normally. */
+	public static void displayCriticalError(Throwable exception, boolean exitAfter) {
+		Log.error(LogCategory.GENERAL, "A critical error occurred", exception);
+
+		displayError("Failed to launch!", exception, exitAfter);
+	}
+
+	public static void displayError(String mainText, Throwable exception, boolean exitAfter) {
+		displayError(mainText, exception, tree -> {
+			StringWriter error = new StringWriter();
+			error.append(mainText);
+
+			if (exception != null) {
+				error.append(System.lineSeparator());
+				exception.printStackTrace(new PrintWriter(error));
+			}
+
+			tree.addButton("Copy error", FabricBasicButtonType.CLICK_MANY).withClipboard(error.toString());
+		}, exitAfter);
+	}
+
+	public static void displayError(String mainText, Throwable exception, Consumer<FabricStatusTree> treeCustomiser, boolean exitAfter) {
+		GameProvider provider = FabricLoaderImpl.INSTANCE.tryGetGameProvider();
+
+		if (!GraphicsEnvironment.isHeadless() && (provider == null || provider.canOpenErrorGui())) {
+			String title = "Fabric Loader " + FabricLoaderImpl.VERSION;
+			FabricStatusTree tree = new FabricStatusTree(title, mainText);
+			FabricStatusTab crashTab = tree.addTab("Crash");
+
+			if (exception != null) {
+				crashTab.node.addCleanedException(exception);
+			} else {
+				crashTab.node.addMessage("No further details available", FabricTreeWarningLevel.NONE);
+			}
+
+			// Maybe add an "open mods folder" button?
+			// or should that be part of the main tree's right-click menu?
+			tree.addButton("Exit", FabricBasicButtonType.CLICK_ONCE).makeClose();
+			treeCustomiser.accept(tree);
+
+			try {
+				open(tree);
+			} catch (Exception e) {
+				if (exitAfter) {
+					Log.warn(LogCategory.GENERAL, "Failed to open the error gui!", e);
+				} else {
+					throw new RuntimeException("Failed to open the error gui!", e);
+				}
+			}
+		}
+
+		if (exitAfter) {
+			System.exit(1);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/gui/FabricMainWindow.java b/src/main/java/net/fabricmc/loader/impl/gui/FabricMainWindow.java
new file mode 100644
index 0000000000000000000000000000000000000000..98113758c7a6a5ccfc7a0909f77b5e0abfd84501
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/gui/FabricMainWindow.java
@@ -0,0 +1,506 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.gui;
+
+import net.fabricmc.loader.impl.gui.FabricStatusTree.*;
+import net.fabricmc.loader.impl.util.StringUtil;
+
+import javax.imageio.ImageIO;
+import javax.swing.*;
+import javax.swing.tree.DefaultTreeCellRenderer;
+import javax.swing.tree.DefaultTreeModel;
+import javax.swing.tree.TreeNode;
+import java.awt.*;
+import java.awt.datatransfer.StringSelection;
+import java.awt.event.WindowAdapter;
+import java.awt.event.WindowEvent;
+import java.awt.image.BufferedImage;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Method;
+import java.util.List;
+import java.util.*;
+import java.util.concurrent.CountDownLatch;
+
+class FabricMainWindow {
+	static Icon missingIcon = null;
+
+	static void open(FabricStatusTree tree, boolean shouldWait) throws Exception {
+		if (GraphicsEnvironment.isHeadless()) {
+			throw new HeadlessException();
+		}
+
+		// Set MacOS specific system props
+		System.setProperty("apple.awt.application.appearance", "system");
+		System.setProperty("apple.awt.application.name", tree.title);
+
+		UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
+		open0(tree, shouldWait);
+	}
+
+	private static void open0(FabricStatusTree tree, boolean shouldWait) throws Exception {
+		CountDownLatch guiTerminatedLatch = new CountDownLatch(1);
+
+		SwingUtilities.invokeAndWait(() -> {
+			createUi(guiTerminatedLatch, tree);
+		});
+
+		if (shouldWait) {
+			guiTerminatedLatch.await();
+		}
+	}
+
+	private static void createUi(CountDownLatch onCloseLatch, FabricStatusTree tree) {
+		JFrame window = new JFrame();
+		window.setVisible(false);
+		window.setTitle(tree.title);
+
+		try {
+			Image image = loadImage("/ui/icon/fabric_x128.png");
+			window.setIconImage(image);
+			setTaskBarImage(image);
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+
+		window.setMinimumSize(new Dimension(640, 480));
+		window.setPreferredSize(new Dimension(800, 480));
+		window.setLocationByPlatform(true);
+		window.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
+		window.addWindowListener(new WindowAdapter() {
+			@Override
+			public void windowClosed(WindowEvent e) {
+				onCloseLatch.countDown();
+			}
+		});
+
+		Container contentPane = window.getContentPane();
+
+		if (tree.mainText != null && !tree.mainText.isEmpty()) {
+			JLabel errorLabel = new JLabel(tree.mainText);
+			errorLabel.setHorizontalAlignment(SwingConstants.CENTER);
+			Font font = errorLabel.getFont();
+			errorLabel.setFont(font.deriveFont(font.getSize() * 2.0f));
+			contentPane.add(errorLabel, BorderLayout.NORTH);
+		}
+
+		IconSet icons = new IconSet();
+
+		if (tree.tabs.isEmpty()) {
+			FabricStatusTab tab = new FabricStatusTab("Opening Errors");
+			tab.addChild("No tabs provided! (Something is very broken)").setError();
+			contentPane.add(createTreePanel(tab.node, tab.filterLevel, icons), BorderLayout.CENTER);
+		} else if (tree.tabs.size() == 1) {
+			FabricStatusTab tab = tree.tabs.get(0);
+			contentPane.add(createTreePanel(tab.node, tab.filterLevel, icons), BorderLayout.CENTER);
+		} else {
+			JTabbedPane tabs = new JTabbedPane();
+			contentPane.add(tabs, BorderLayout.CENTER);
+
+			for (FabricStatusTab tab : tree.tabs) {
+				tabs.addTab(tab.node.name, createTreePanel(tab.node, tab.filterLevel, icons));
+			}
+		}
+
+		if (!tree.buttons.isEmpty()) {
+			JPanel buttons = new JPanel();
+			contentPane.add(buttons, BorderLayout.SOUTH);
+			buttons.setLayout(new FlowLayout(FlowLayout.TRAILING));
+
+			for (FabricStatusButton button : tree.buttons) {
+				JButton btn = new JButton(button.text);
+				buttons.add(btn);
+				btn.addActionListener(event -> {
+					if (button.type == FabricBasicButtonType.CLICK_ONCE) btn.setEnabled(false);
+
+					if (button.clipboard != null) {
+						try {
+							StringSelection clipboard = new StringSelection(button.clipboard);
+							Toolkit.getDefaultToolkit().getSystemClipboard().setContents(clipboard, clipboard);
+						} catch (IllegalStateException e) {
+							//Clipboard unavailable?
+						}
+					}
+
+					if (button.shouldClose) {
+						window.dispose();
+					}
+
+					if (button.shouldContinue) {
+						onCloseLatch.countDown();
+					}
+				});
+			}
+		}
+
+		window.pack();
+		window.setVisible(true);
+		window.requestFocus();
+	}
+
+	private static JPanel createTreePanel(FabricStatusNode rootNode, FabricTreeWarningLevel minimumWarningLevel,
+			IconSet iconSet) {
+		JPanel panel = new JPanel();
+		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
+
+		TreeNode treeNode = new CustomTreeNode(null, rootNode, minimumWarningLevel);
+
+		DefaultTreeModel model = new DefaultTreeModel(treeNode);
+		JTree tree = new JTree(model);
+		tree.setRootVisible(false);
+		tree.setRowHeight(0); // Allow rows to be multiple lines tall
+
+		for (int row = 0; row < tree.getRowCount(); row++) {
+			if (!tree.isVisible(tree.getPathForRow(row))) {
+				continue;
+			}
+
+			CustomTreeNode node = ((CustomTreeNode) tree.getPathForRow(row).getLastPathComponent());
+
+			if (node.node.expandByDefault) {
+				tree.expandRow(row);
+			}
+		}
+
+		ToolTipManager.sharedInstance().registerComponent(tree);
+		tree.setCellRenderer(new CustomTreeCellRenderer(iconSet));
+
+		JScrollPane scrollPane = new JScrollPane(tree);
+		panel.add(scrollPane);
+
+		return panel;
+	}
+
+	private static BufferedImage loadImage(String str) throws IOException {
+		return ImageIO.read(loadStream(str));
+	}
+
+	private static InputStream loadStream(String str) throws FileNotFoundException {
+		InputStream stream = FabricMainWindow.class.getResourceAsStream(str);
+
+		if (stream == null) {
+			throw new FileNotFoundException(str);
+		}
+
+		return stream;
+	}
+
+	private static void setTaskBarImage(Image image) {
+		try {
+			// TODO Remove reflection when updating past Java 8
+			Class<?> taskbarClass = Class.forName("java.awt.Taskbar");
+			Method getTaskbar = taskbarClass.getDeclaredMethod("getTaskbar");
+			Method setIconImage = taskbarClass.getDeclaredMethod("setIconImage", Image.class);
+			Object taskbar = getTaskbar.invoke(null);
+			setIconImage.invoke(taskbar, image);
+		} catch (Exception e) {
+			// Ignored
+		}
+	}
+
+	static final class IconSet {
+		/** Map of IconInfo -> Integer Size -> Real Icon. */
+		private final Map<IconInfo, Map<Integer, Icon>> icons = new HashMap<>();
+
+		public Icon get(IconInfo info) {
+			// TODO: HDPI
+
+			int scale = 16;
+			Map<Integer, Icon> map = icons.get(info);
+
+			if (map == null) {
+				icons.put(info, map = new HashMap<>());
+			}
+
+			Icon icon = map.get(scale);
+
+			if (icon == null) {
+				try {
+					icon = loadIcon(info, scale);
+				} catch (IOException e) {
+					e.printStackTrace();
+					icon = missingIcon();
+				}
+
+				map.put(scale, icon);
+			}
+
+			return icon;
+		}
+	}
+
+	private static Icon missingIcon() {
+		if (missingIcon == null) {
+			BufferedImage img = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
+
+			for (int y = 0; y < 16; y++) {
+				for (int x = 0; x < 16; x++) {
+					img.setRGB(x, y, 0xff_ff_f2);
+				}
+			}
+
+			for (int i = 0; i < 16; i++) {
+				img.setRGB(0, i, 0x22_22_22);
+				img.setRGB(15, i, 0x22_22_22);
+				img.setRGB(i, 0, 0x22_22_22);
+				img.setRGB(i, 15, 0x22_22_22);
+			}
+
+			for (int i = 3; i < 13; i++) {
+				img.setRGB(i, i, 0x9b_00_00);
+				img.setRGB(i, 16 - i, 0x9b_00_00);
+			}
+
+			missingIcon = new ImageIcon(img);
+		}
+
+		return missingIcon;
+	}
+
+	private static Icon loadIcon(IconInfo info, int scale) throws IOException {
+		BufferedImage img = new BufferedImage(scale, scale, BufferedImage.TYPE_INT_ARGB);
+		Graphics2D imgG2d = img.createGraphics();
+
+		BufferedImage main = loadImage("/ui/icon/" + info.mainPath + "_x" + scale + ".png");
+		assert main.getWidth() == scale;
+		assert main.getHeight() == scale;
+		imgG2d.drawImage(main, null, 0, 0);
+
+		final int[][] coords = { { 0, 8 }, { 8, 8 }, { 8, 0 } };
+
+		for (int i = 0; i < info.decor.length; i++) {
+			String decor = info.decor[i];
+
+			if (decor == null) {
+				continue;
+			}
+
+			BufferedImage decorImg = loadImage("/ui/icon/decoration/" + decor + "_x" + (scale / 2) + ".png");
+			assert decorImg.getWidth() == scale / 2;
+			assert decorImg.getHeight() == scale / 2;
+			imgG2d.drawImage(decorImg, null, coords[i][0], coords[i][1]);
+		}
+
+		return new ImageIcon(img);
+	}
+
+	static final class IconInfo {
+		public final String mainPath;
+		public final String[] decor;
+		private final int hash;
+
+		IconInfo(String mainPath) {
+			this.mainPath = mainPath;
+			this.decor = new String[0];
+			hash = mainPath.hashCode();
+		}
+
+		IconInfo(String mainPath, String[] decor) {
+			this.mainPath = mainPath;
+			this.decor = decor;
+			assert decor.length < 4 : "Cannot fit more than 3 decorations into an image (and leave space for the background)";
+
+			if (decor.length == 0) {
+				// To mirror the no-decor constructor
+				hash = mainPath.hashCode();
+			} else {
+				hash = mainPath.hashCode() * 31 + Arrays.hashCode(decor);
+			}
+		}
+
+		public static IconInfo fromNode(FabricStatusNode node) {
+			String[] split = node.iconType.split("\\+");
+
+			if (split.length == 1 && split[0].isEmpty()) {
+				split = new String[0];
+			}
+
+			final String main;
+			List<String> decors = new ArrayList<>();
+			FabricTreeWarningLevel warnLevel = node.getMaximumWarningLevel();
+
+			if (split.length == 0) {
+				// Empty string, but we might replace it with a warning
+				if (warnLevel == FabricTreeWarningLevel.NONE) {
+					main = "missing";
+				} else {
+					main = "level_" + warnLevel.lowerCaseName;
+				}
+			} else {
+				main = split[0];
+
+				if (warnLevel == FabricTreeWarningLevel.NONE) {
+					// Just to add a gap
+					decors.add(null);
+				} else {
+					decors.add("level_" + warnLevel.lowerCaseName);
+				}
+
+				for (int i = 1; i < split.length && i < 3; i++) {
+					decors.add(split[i]);
+				}
+			}
+
+			return new IconInfo(main, decors.toArray(new String[0]));
+		}
+
+		@Override
+		public int hashCode() {
+			return hash;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (obj == this) {
+				return true;
+			}
+
+			if (obj == null || obj.getClass() != getClass()) {
+				return false;
+			}
+
+			IconInfo other = (IconInfo) obj;
+			return mainPath.equals(other.mainPath) && Arrays.equals(decor, other.decor);
+		}
+	}
+
+	private static final class CustomTreeCellRenderer extends DefaultTreeCellRenderer {
+		private static final long serialVersionUID = -5621219150752332739L;
+
+		private final IconSet iconSet;
+
+		private CustomTreeCellRenderer(IconSet icons) {
+			this.iconSet = icons;
+			//setVerticalTextPosition(TOP); // Move icons to top rather than centre
+		}
+
+		@Override
+		public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded,
+				boolean leaf, int row, boolean hasFocus) {
+			super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);
+
+			setBorder(BorderFactory.createEmptyBorder(2, 0, 2, 0));
+
+			if (value instanceof CustomTreeNode) {
+				CustomTreeNode c = (CustomTreeNode) value;
+				setIcon(iconSet.get(c.getIconInfo()));
+
+				if (c.node.details == null || c.node.details.isEmpty()) {
+					setToolTipText(null);
+				} else {
+					setToolTipText(applyWrapping(c.node.details));
+				}
+			}
+
+			return this;
+		}
+	}
+
+	private static String applyWrapping(String str) {
+		if (str.indexOf('\n') < 0) {
+			return str;
+		}
+
+		str = str.replace("&", "&amp;")
+				.replace("<", "&lt;")
+				.replace(">", "&gt;")
+				.replace("\n", "<br>");
+
+		return "<html>" + str + "</html>";
+	}
+
+	static class CustomTreeNode implements TreeNode {
+		public final TreeNode parent;
+		public final FabricStatusNode node;
+		public final List<CustomTreeNode> displayedChildren = new ArrayList<>();
+		private IconInfo iconInfo;
+
+		CustomTreeNode(TreeNode parent, FabricStatusNode node, FabricTreeWarningLevel minimumWarningLevel) {
+			this.parent = parent;
+			this.node = node;
+
+			for (FabricStatusNode c : node.children) {
+				if (minimumWarningLevel.isHigherThan(c.getMaximumWarningLevel())) {
+					continue;
+				}
+
+				displayedChildren.add(new CustomTreeNode(this, c, minimumWarningLevel));
+			}
+		}
+
+		public IconInfo getIconInfo() {
+			if (iconInfo == null) {
+				iconInfo = IconInfo.fromNode(node);
+			}
+
+			return iconInfo;
+		}
+
+		@Override
+		public String toString() {
+			return applyWrapping(StringUtil.wrapLines(node.name, 120));
+		}
+
+		@Override
+		public TreeNode getChildAt(int childIndex) {
+			return displayedChildren.get(childIndex);
+		}
+
+		@Override
+		public int getChildCount() {
+			return displayedChildren.size();
+		}
+
+		@Override
+		public TreeNode getParent() {
+			return parent;
+		}
+
+		@Override
+		public int getIndex(TreeNode node) {
+			return displayedChildren.indexOf(node);
+		}
+
+		@Override
+		public boolean getAllowsChildren() {
+			return !isLeaf();
+		}
+
+		@Override
+		public boolean isLeaf() {
+			return displayedChildren.isEmpty();
+		}
+
+		@Override
+		public Enumeration<CustomTreeNode> children() {
+			return new Enumeration<CustomTreeNode>() {
+				Iterator<CustomTreeNode> it = displayedChildren.iterator();
+
+				@Override
+				public boolean hasMoreElements() {
+					return it.hasNext();
+				}
+
+				@Override
+				public CustomTreeNode nextElement() {
+					return it.next();
+				}
+			};
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/gui/FabricStatusTree.java b/src/main/java/net/fabricmc/loader/impl/gui/FabricStatusTree.java
new file mode 100644
index 0000000000000000000000000000000000000000..dfbdff51c7dc439e92c2d2b39148e0ec2dfc2cb5
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/gui/FabricStatusTree.java
@@ -0,0 +1,505 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.gui;
+
+import net.fabricmc.loader.impl.FormattedException;
+
+import java.io.*;
+import java.util.*;
+import java.util.function.UnaryOperator;
+
+public final class FabricStatusTree {
+	public enum FabricTreeWarningLevel {
+		ERROR,
+		WARN,
+		INFO,
+		NONE;
+
+		public final String lowerCaseName = name().toLowerCase(Locale.ROOT);
+
+		public boolean isHigherThan(FabricTreeWarningLevel other) {
+			return ordinal() < other.ordinal();
+		}
+
+		public boolean isAtLeast(FabricTreeWarningLevel other) {
+			return ordinal() <= other.ordinal();
+		}
+
+		public static FabricTreeWarningLevel getHighest(FabricTreeWarningLevel a, FabricTreeWarningLevel b) {
+			return a.isHigherThan(b) ? a : b;
+		}
+	}
+
+	public enum FabricBasicButtonType {
+		/** Sends the status message to the main application, then disables itself. */
+		CLICK_ONCE,
+		/** Sends the status message to the main application, remains enabled. */
+		CLICK_MANY;
+	}
+
+	/** No icon is displayed. */
+	public static final String ICON_TYPE_DEFAULT = "";
+	/** Generic folder. */
+	public static final String ICON_TYPE_FOLDER = "folder";
+	/** Generic (unknown contents) file. */
+	public static final String ICON_TYPE_UNKNOWN_FILE = "file";
+	/** Generic non-Fabric jar file. */
+	public static final String ICON_TYPE_JAR_FILE = "jar";
+	/** Generic Fabric-related jar file. */
+	public static final String ICON_TYPE_FABRIC_JAR_FILE = "jar+fabric";
+	/** Something related to Fabric (It's not defined what exactly this is for, but it uses the main Fabric logo). */
+	public static final String ICON_TYPE_FABRIC = "fabric";
+	/** Generic JSON file. */
+	public static final String ICON_TYPE_JSON = "json";
+	/** A file called "fabric.mod.json". */
+	public static final String ICON_TYPE_FABRIC_JSON = "json+fabric";
+	/** Java bytecode class file. */
+	public static final String ICON_TYPE_JAVA_CLASS = "java_class";
+	/** A folder inside of a Java JAR. */
+	public static final String ICON_TYPE_PACKAGE = "package";
+	/** A folder that contains Java class files. */
+	public static final String ICON_TYPE_JAVA_PACKAGE = "java_package";
+	/** A tick symbol, used to indicate that something matched. */
+	public static final String ICON_TYPE_TICK = "tick";
+	/** A cross symbol, used to indicate that something didn't match (although it's not an error). Used as the opposite
+	 * of {@link #ICON_TYPE_TICK} */
+	public static final String ICON_TYPE_LESSER_CROSS = "lesser_cross";
+
+	public final String title;
+	public final String mainText;
+	public final List<FabricStatusTab> tabs = new ArrayList<>();
+	public final List<FabricStatusButton> buttons = new ArrayList<>();
+
+	public FabricStatusTree(String title, String mainText) {
+		Objects.requireNonNull(title, "null title");
+		Objects.requireNonNull(mainText, "null mainText");
+
+		this.title = title;
+		this.mainText = mainText;
+	}
+
+	public FabricStatusTree(DataInputStream is) throws IOException {
+		title = is.readUTF();
+		mainText = is.readUTF();
+
+		for (int i = is.readInt(); i > 0; i--) {
+			tabs.add(new FabricStatusTab(is));
+		}
+
+		for (int i = is.readInt(); i > 0; i--) {
+			buttons.add(new FabricStatusButton(is));
+		}
+	}
+
+	public void writeTo(DataOutputStream os) throws IOException {
+		os.writeUTF(title);
+		os.writeUTF(mainText);
+		os.writeInt(tabs.size());
+
+		for (FabricStatusTab tab : tabs) {
+			tab.writeTo(os);
+		}
+
+		os.writeInt(buttons.size());
+
+		for (FabricStatusButton button : buttons) {
+			button.writeTo(os);
+		}
+	}
+
+	public FabricStatusTab addTab(String name) {
+		FabricStatusTab tab = new FabricStatusTab(name);
+		tabs.add(tab);
+		return tab;
+	}
+
+	public FabricStatusButton addButton(String text, FabricBasicButtonType type) {
+		FabricStatusButton button = new FabricStatusButton(text, type);
+		buttons.add(button);
+		return button;
+	}
+
+	public static final class FabricStatusButton {
+		public final String text;
+		public final FabricBasicButtonType type;
+		public String clipboard;
+		public boolean shouldClose, shouldContinue;
+
+		public FabricStatusButton(String text, FabricBasicButtonType type) {
+			Objects.requireNonNull(text, "null text");
+
+			this.text = text;
+			this.type = type;
+		}
+
+		public FabricStatusButton(DataInputStream is) throws IOException {
+			text = is.readUTF();
+			type = FabricBasicButtonType.valueOf(is.readUTF());
+			shouldClose = is.readBoolean();
+			shouldContinue = is.readBoolean();
+
+			if (is.readBoolean()) clipboard = is.readUTF();
+		}
+
+		public void writeTo(DataOutputStream os) throws IOException {
+			os.writeUTF(text);
+			os.writeUTF(type.name());
+			os.writeBoolean(shouldClose);
+			os.writeBoolean(shouldContinue);
+
+			if (clipboard != null) {
+				os.writeBoolean(true);
+				os.writeUTF(clipboard);
+			} else {
+				os.writeBoolean(false);
+			}
+		}
+
+		public FabricStatusButton makeClose() {
+			shouldClose = true;
+			return this;
+		}
+
+		public FabricStatusButton makeContinue() {
+			this.shouldContinue = true;
+			return this;
+		}
+
+		public FabricStatusButton withClipboard(String clipboard) {
+			this.clipboard = clipboard;
+			return this;
+		}
+	}
+
+	public static final class FabricStatusTab {
+		public final FabricStatusNode node;
+
+		/** The minimum warning level to display for this tab. */
+		public FabricTreeWarningLevel filterLevel = FabricTreeWarningLevel.NONE;
+
+		public FabricStatusTab(String name) {
+			this.node = new FabricStatusNode(null, name);
+		}
+
+		public FabricStatusTab(DataInputStream is) throws IOException {
+			node = new FabricStatusNode(null, is);
+			filterLevel = FabricTreeWarningLevel.valueOf(is.readUTF());
+		}
+
+		public void writeTo(DataOutputStream os) throws IOException {
+			node.writeTo(os);
+			os.writeUTF(filterLevel.name());
+		}
+
+		public FabricStatusNode addChild(String name) {
+			return node.addChild(name);
+		}
+	}
+
+	public static final class FabricStatusNode {
+		private FabricStatusNode parent;
+		public String name;
+		/** The icon type. There can be a maximum of 2 decorations (added with "+" symbols), or 3 if the
+		 * {@link #setWarningLevel(FabricTreeWarningLevel) warning level} is set to
+		 * {@link FabricTreeWarningLevel#NONE } */
+		public String iconType = ICON_TYPE_DEFAULT;
+		private FabricTreeWarningLevel warningLevel = FabricTreeWarningLevel.NONE;
+		public boolean expandByDefault = false;
+		/** Extra text for more information. Lines should be separated by "\n". */
+		public String details;
+		public final List<FabricStatusNode> children = new ArrayList<>();
+
+		private FabricStatusNode(FabricStatusNode parent, String name) {
+			Objects.requireNonNull(name, "null name");
+
+			this.parent = parent;
+			this.name = name;
+		}
+
+		public FabricStatusNode(FabricStatusNode parent, DataInputStream is) throws IOException {
+			this.parent = parent;
+
+			name = is.readUTF();
+			iconType = is.readUTF();
+			warningLevel = FabricTreeWarningLevel.valueOf(is.readUTF());
+			expandByDefault = is.readBoolean();
+			if (is.readBoolean()) details = is.readUTF();
+
+			for (int i = is.readInt(); i > 0; i--) {
+				children.add(new FabricStatusNode(this, is));
+			}
+		}
+
+		public void writeTo(DataOutputStream os) throws IOException {
+			os.writeUTF(name);
+			os.writeUTF(iconType);
+			os.writeUTF(warningLevel.name());
+			os.writeBoolean(expandByDefault);
+			os.writeBoolean(details != null);
+			if (details != null) os.writeUTF(details);
+			os.writeInt(children.size());
+
+			for (FabricStatusNode child : children) {
+				child.writeTo(os);
+			}
+		}
+
+		public void moveTo(FabricStatusNode newParent) {
+			parent.children.remove(this);
+			this.parent = newParent;
+			newParent.children.add(this);
+		}
+
+		public FabricTreeWarningLevel getMaximumWarningLevel() {
+			return warningLevel;
+		}
+
+		public void setWarningLevel(FabricTreeWarningLevel level) {
+			if (this.warningLevel == level) {
+				return;
+			}
+
+			if (warningLevel.isHigherThan(level)) {
+				// Just because I haven't written the back-fill revalidation for this
+				throw new Error("Why would you set the warning level multiple times?");
+			} else {
+				if (parent != null && level.isHigherThan(parent.warningLevel)) {
+					parent.setWarningLevel(level);
+				}
+
+				this.warningLevel = level;
+				expandByDefault |= level.isAtLeast(FabricTreeWarningLevel.WARN);
+			}
+		}
+
+		public void setError() {
+			setWarningLevel(FabricTreeWarningLevel.ERROR);
+		}
+
+		public void setWarning() {
+			setWarningLevel(FabricTreeWarningLevel.WARN);
+		}
+
+		public void setInfo() {
+			setWarningLevel(FabricTreeWarningLevel.INFO);
+		}
+
+		private FabricStatusNode addChild(String string) {
+			if (string.startsWith("\t")) {
+				if (children.size() == 0) {
+					FabricStatusNode rootChild = new FabricStatusNode(this, "");
+					children.add(rootChild);
+				}
+
+				FabricStatusNode lastChild = children.get(children.size() - 1);
+				lastChild.addChild(string.substring(1));
+				lastChild.expandByDefault = true;
+				return lastChild;
+			} else {
+				FabricStatusNode child = new FabricStatusNode(this, cleanForNode(string));
+				children.add(child);
+				return child;
+			}
+		}
+
+		private String cleanForNode(String string) {
+			string = string.trim();
+
+			if (string.length() > 1) {
+				if (string.startsWith("-")) {
+					string = string.substring(1);
+					string = string.trim();
+				}
+			}
+
+			return string;
+		}
+
+		public FabricStatusNode addMessage(String message, FabricTreeWarningLevel warningLevel) {
+			String[] lines = message.split("\n");
+
+			FabricStatusNode sub = new FabricStatusNode(this, lines[0]);
+			children.add(sub);
+			sub.setWarningLevel(warningLevel);
+
+			for (int i = 1; i < lines.length; i++) {
+				sub.addChild(lines[i]);
+			}
+
+			return sub;
+		}
+
+		public FabricStatusNode addException(Throwable exception) {
+			return addException(this, Collections.newSetFromMap(new IdentityHashMap<>()), exception, UnaryOperator.identity(), new StackTraceElement[0]);
+		}
+
+		public FabricStatusNode addCleanedException(Throwable exception) {
+			return addException(this, Collections.newSetFromMap(new IdentityHashMap<>()), exception, e -> {
+				// Remove some self-repeating exception traces from the tree
+				// (for example the RuntimeException that is is created unnecessarily by ForkJoinTask)
+				Throwable cause;
+
+				while ((cause = e.getCause()) != null) {
+					if (e.getSuppressed().length > 0) {
+						break;
+					}
+
+					String msg = e.getMessage();
+
+					if (msg == null) {
+						msg = e.getClass().getName();
+					}
+
+					if (!msg.equals(cause.getMessage()) && !msg.equals(cause.toString())) {
+						break;
+					}
+
+					e = cause;
+				}
+
+				return e;
+			}, new StackTraceElement[0]);
+		}
+
+		private static FabricStatusNode addException(FabricStatusNode node, Set<Throwable> seen, Throwable exception, UnaryOperator<Throwable> filter, StackTraceElement[] parentTrace) {
+			if (!seen.add(exception)) {
+				return node;
+			}
+
+			exception = filter.apply(exception);
+			FabricStatusNode sub = node.addException(exception, parentTrace);
+			StackTraceElement[] trace = exception.getStackTrace();
+
+			for (Throwable t : exception.getSuppressed()) {
+				FabricStatusNode suppressed = addException(sub, seen, t, filter, trace);
+				suppressed.name += " (suppressed)";
+				suppressed.expandByDefault = false;
+			}
+
+			if (exception.getCause() != null) {
+				addException(sub, seen, exception.getCause(), filter, trace);
+			}
+
+			return sub;
+		}
+
+		private FabricStatusNode addException(Throwable exception, StackTraceElement[] parentTrace) {
+			boolean showTrace = !(exception instanceof FormattedException) || exception.getCause() != null;
+			String msg;
+
+			if (exception instanceof FormattedException) {
+				msg = Objects.toString(exception.getMessage());
+			} else if (exception.getMessage() == null || exception.getMessage().isEmpty()) {
+				msg = exception.toString();
+			} else {
+				msg = String.format("%s: %s", exception.getClass().getSimpleName(), exception.getMessage());
+			}
+
+			FabricStatusNode sub = addMessage(msg, FabricTreeWarningLevel.ERROR);
+
+			if (!showTrace) return sub;
+
+			StackTraceElement[] trace = exception.getStackTrace();
+			int uniqueFrames = trace.length - 1;
+
+			for (int i = parentTrace.length - 1; uniqueFrames >= 0 && i >= 0 && trace[uniqueFrames].equals(parentTrace[i]); i--) {
+				uniqueFrames--;
+			}
+
+			StringJoiner frames = new StringJoiner("\n");
+			int inheritedFrames = trace.length - 1 - uniqueFrames;
+
+			for (int i = 0; i <= uniqueFrames; i++) {
+				frames.add("at " + trace[i]);
+			}
+
+			if (inheritedFrames > 0) {
+				frames.add("... " + inheritedFrames + " more");
+			}
+
+			sub.addChild(frames.toString()).iconType = ICON_TYPE_JAVA_CLASS;
+
+			StringWriter sw = new StringWriter();
+			exception.printStackTrace(new PrintWriter(sw));
+			sub.details = sw.toString();
+
+			return sub;
+		}
+
+		/** If this node has one child then it merges the child node into this one. */
+		public void mergeWithSingleChild(String join) {
+			if (children.size() != 1) {
+				return;
+			}
+
+			FabricStatusNode child = children.remove(0);
+			name += join + child.name;
+
+			for (FabricStatusNode cc : child.children) {
+				cc.parent = this;
+				children.add(cc);
+			}
+
+			child.children.clear();
+		}
+
+		public void mergeSingleChildFilePath(String folderType) {
+			if (!iconType.equals(folderType)) {
+				return;
+			}
+
+			while (children.size() == 1 && children.get(0).iconType.equals(folderType)) {
+				mergeWithSingleChild("/");
+			}
+
+			children.sort((a, b) -> a.name.compareTo(b.name));
+			mergeChildFilePaths(folderType);
+		}
+
+		public void mergeChildFilePaths(String folderType) {
+			for (FabricStatusNode node : children) {
+				node.mergeSingleChildFilePath(folderType);
+			}
+		}
+
+		public FabricStatusNode getFileNode(String file, String folderType, String fileType) {
+			FabricStatusNode fileNode = this;
+
+			pathIteration: for (String s : file.split("/")) {
+				if (s.isEmpty()) {
+					continue;
+				}
+
+				for (FabricStatusNode c : fileNode.children) {
+					if (c.name.equals(s)) {
+						fileNode = c;
+						continue pathIteration;
+					}
+				}
+
+				if (fileNode.iconType.equals(FabricStatusTree.ICON_TYPE_DEFAULT)) {
+					fileNode.iconType = folderType;
+				}
+
+				fileNode = fileNode.addChild(s);
+			}
+
+			fileNode.iconType = fileType;
+			return fileNode;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/gui/package-info.java b/src/main/java/net/fabricmc/loader/impl/gui/package-info.java
new file mode 100644
index 0000000000000000000000000000000000000000..b95ee014ccd2ddc29d878af946ee0a82d789f456
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/gui/package-info.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** The swing GUI shown if any major errors are thrown while obtaining the list of mods in
+ * {@link net.fabricmc.loader.FabricLoader#load()}.
+ *
+ * <p>This could potentially be useful for showing an tree-like structure while in-game, however this usecase is rather
+ * limited. */
+package net.fabricmc.loader.impl.gui;
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/FabricLauncher.java b/src/main/java/net/fabricmc/loader/impl/launch/FabricLauncher.java
new file mode 100644
index 0000000000000000000000000000000000000000..9de7f497cf44666803ad7a33a27d62fe9304dfd9
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/FabricLauncher.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch;
+
+import net.fabricmc.api.EnvType;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.util.Collection;
+import java.util.List;
+import java.util.jar.Manifest;
+
+public interface FabricLauncher {
+	MappingConfiguration getMappingConfiguration();
+
+	void addToClassPath(Path path, String... allowedPrefixes);
+	void setAllowedPrefixes(Path path, String... prefixes);
+	void setValidParentClassPath(Collection<Path> paths);
+
+	EnvType getEnvironmentType();
+
+	boolean isClassLoaded(String name);
+
+	/**
+	 * Load a class into the game's class loader even if its bytes are only available from the parent class loader.
+	 */
+	Class<?> loadIntoTarget(String name) throws ClassNotFoundException;
+
+	InputStream getResourceAsStream(String name);
+
+	ClassLoader getTargetClassLoader();
+
+	/**
+	 * Gets the byte array for a particular class.
+	 *
+	 * @param name The name of the class to retrieve
+	 * @param runTransformers Whether to run all transformers <i>except mixin</i> on the class
+	 */
+	byte[] getClassByteArray(String name, boolean runTransformers) throws IOException;
+
+	Manifest getManifest(Path originPath);
+
+	boolean isDevelopment();
+
+	String getEntrypoint();
+
+	String getTargetNamespace();
+
+	List<Path> getClassPath();
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/FabricLauncherBase.java b/src/main/java/net/fabricmc/loader/impl/launch/FabricLauncherBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..a6922603e23410f086ce69c2adb177bc9d85e3cc
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/FabricLauncherBase.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch;
+
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.FormattedException;
+import net.fabricmc.loader.impl.game.GameProvider;
+import net.fabricmc.loader.impl.gui.FabricGuiEntry;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import org.spongepowered.asm.mixin.MixinEnvironment;
+
+import java.io.FileDescriptor;
+import java.io.FileOutputStream;
+import java.io.PrintWriter;
+import java.lang.reflect.Method;
+import java.util.Map;
+
+public abstract class FabricLauncherBase implements FabricLauncher {
+	private static boolean mixinReady;
+	private static Map<String, Object> properties;
+	private static FabricLauncher launcher;
+	private static MappingConfiguration mappingConfiguration = new MappingConfiguration();
+
+	protected FabricLauncherBase() {
+		setLauncher(this);
+	}
+
+	public static Class<?> getClass(String className) throws ClassNotFoundException {
+		return Class.forName(className, true, getLauncher().getTargetClassLoader());
+	}
+
+	@Override
+	public MappingConfiguration getMappingConfiguration() {
+		return mappingConfiguration;
+	}
+
+	protected static void setProperties(Map<String, Object> propertiesA) {
+		if (properties != null && properties != propertiesA) {
+			throw new RuntimeException("Duplicate setProperties call!");
+		}
+
+		properties = propertiesA;
+	}
+
+	private static void setLauncher(FabricLauncher launcherA) {
+		if (launcher != null && launcher != launcherA) {
+			throw new RuntimeException("Duplicate setLauncher call!");
+		}
+
+		launcher = launcherA;
+	}
+
+	public static FabricLauncher getLauncher() {
+		return launcher;
+	}
+
+	public static Map<String, Object> getProperties() {
+		return properties;
+	}
+
+	protected static void handleFormattedException(FormattedException exc) {
+		Throwable actualExc = exc.getMessage() != null ? exc : exc.getCause();
+		Log.error(LogCategory.GENERAL, exc.getMainText(), actualExc);
+
+		GameProvider gameProvider = FabricLoaderImpl.INSTANCE.tryGetGameProvider();
+
+		if (gameProvider == null || !gameProvider.displayCrash(actualExc, exc.getMainText())) {
+			FabricGuiEntry.displayError(exc.getMainText(), actualExc, true);
+		} else {
+			System.exit(1);
+		}
+
+		throw new AssertionError("exited");
+	}
+
+	protected static void setupUncaughtExceptionHandler() {
+		Thread mainThread = Thread.currentThread();
+		Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+			@Override
+			public void uncaughtException(Thread t, Throwable e) {
+				try {
+					if (e instanceof FormattedException) {
+						handleFormattedException((FormattedException) e);
+					} else {
+						String mainText = String.format("Uncaught exception in thread \"%s\"", t.getName());
+						Log.error(LogCategory.GENERAL, mainText, e);
+
+						GameProvider gameProvider = FabricLoaderImpl.INSTANCE.tryGetGameProvider();
+
+						if (Thread.currentThread() == mainThread
+								&& (gameProvider == null || !gameProvider.displayCrash(e, mainText))) {
+							FabricGuiEntry.displayError(mainText, e, false);
+						}
+					}
+				} catch (Throwable e2) { // just in case
+					e.addSuppressed(e2);
+
+					try {
+						e.printStackTrace();
+					} catch (Throwable e3) {
+						PrintWriter pw = new PrintWriter(new FileOutputStream(FileDescriptor.err));
+						e.printStackTrace(pw);
+						pw.flush();
+					}
+				}
+			}
+		});
+	}
+
+	protected static void finishMixinBootstrapping() {
+		if (mixinReady) {
+			throw new RuntimeException("Must not call FabricLauncherBase.finishMixinBootstrapping() twice!");
+		}
+
+		try {
+			Method m = MixinEnvironment.class.getDeclaredMethod("gotoPhase", MixinEnvironment.Phase.class);
+			m.setAccessible(true);
+			m.invoke(null, MixinEnvironment.Phase.INIT);
+			m.invoke(null, MixinEnvironment.Phase.DEFAULT);
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+
+		mixinReady = true;
+	}
+
+	public static boolean isMixinReady() {
+		return mixinReady;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/FabricMixinBootstrap.java b/src/main/java/net/fabricmc/loader/impl/launch/FabricMixinBootstrap.java
new file mode 100644
index 0000000000000000000000000000000000000000..563393057f09b12e21da7c72f67ab5305e2913f9
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/FabricMixinBootstrap.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.api.metadata.ModDependency;
+import net.fabricmc.loader.api.metadata.ModDependency.Kind;
+import net.fabricmc.loader.api.metadata.version.VersionInterval;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.ModContainerImpl;
+import net.fabricmc.loader.impl.launch.knot.MixinServiceKnot;
+import net.fabricmc.loader.impl.launch.knot.MixinServiceKnotBootstrap;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import net.fabricmc.loader.impl.util.mappings.MixinIntermediaryDevRemapper;
+import net.fabricmc.mapping.tree.TinyTree;
+import org.spongepowered.asm.launch.MixinBootstrap;
+import org.spongepowered.asm.mixin.FabricUtil;
+import org.spongepowered.asm.mixin.MixinEnvironment;
+import org.spongepowered.asm.mixin.Mixins;
+import org.spongepowered.asm.mixin.extensibility.IMixinConfig;
+import org.spongepowered.asm.mixin.transformer.Config;
+
+import java.util.*;
+
+public final class FabricMixinBootstrap {
+	private FabricMixinBootstrap() { }
+
+	private static boolean initialized = false;
+
+	public static void init(EnvType side, FabricLoaderImpl loader) {
+		if (initialized) {
+			throw new RuntimeException("FabricMixinBootstrap has already been initialized!");
+		}
+
+		System.setProperty("mixin.bootstrapService", MixinServiceKnotBootstrap.class.getName());
+		System.setProperty("mixin.service", MixinServiceKnot.class.getName());
+
+		MixinBootstrap.init();
+
+		if (FabricLauncherBase.getLauncher().isDevelopment()) {
+			MappingConfiguration mappingConfiguration = FabricLauncherBase.getLauncher().getMappingConfiguration();
+			TinyTree mappings = mappingConfiguration.getMappings();
+
+			if (mappings != null) {
+				List<String> namespaces = mappings.getMetadata().getNamespaces();
+
+				if (namespaces.contains("intermediary") && namespaces.contains(mappingConfiguration.getTargetNamespace())) {
+					System.setProperty("mixin.env.remapRefMap", "true");
+
+					try {
+						MixinIntermediaryDevRemapper remapper = new MixinIntermediaryDevRemapper(mappings, "intermediary", mappingConfiguration.getTargetNamespace());
+						MixinEnvironment.getDefaultEnvironment().getRemappers().add(remapper);
+						Log.info(LogCategory.MIXIN, "Loaded Fabric development mappings for mixin remapper!");
+					} catch (Exception e) {
+						Log.error(LogCategory.MIXIN, "Fabric development environment setup error - the game will probably crash soon!");
+						e.printStackTrace();
+					}
+				}
+			}
+		}
+
+		Map<String, ModContainerImpl> configToModMap = new HashMap<>();
+
+		for (ModContainerImpl mod : loader.getModsInternal()) {
+			for (String config : mod.getMetadata().getMixinConfigs(side)) {
+				ModContainerImpl prev = configToModMap.putIfAbsent(config, mod);
+				if (prev != null) throw new RuntimeException(String.format("Non-unique Mixin config name %s used by the mods %s and %s", config, prev.getMetadata().getId(), mod.getMetadata().getId()));
+
+				try {
+					Mixins.addConfiguration(config);
+				} catch (Throwable t) {
+					throw new RuntimeException(String.format("Error creating Mixin config %s for mod %s", config, mod.getMetadata().getId()), t);
+				}
+			}
+		}
+
+		for (Config config : Mixins.getConfigs()) {
+			ModContainerImpl mod = configToModMap.get(config.getName());
+			if (mod == null) continue;
+		}
+
+		try {
+			IMixinConfig.class.getMethod("decorate", String.class, Object.class);
+			MixinConfigDecorator.apply(configToModMap);
+		} catch (NoSuchMethodException e) {
+			Log.info(LogCategory.MIXIN, "Detected old Mixin version without config decoration support");
+		}
+
+		initialized = true;
+	}
+
+	private static final class MixinConfigDecorator {
+		private static final List<LoaderMixinVersionEntry> versions = new ArrayList<>();
+
+		static {
+			// maximum loader version and bundled fabric mixin version, DESCENDING ORDER, LATEST FIRST
+			// loader versions with new mixin versions need to be added here
+
+			// addVersion("0.13", FabricUtil.COMPATIBILITY_0_11_0); // example for next entry (latest first!)
+			addVersion("0.12.0-", FabricUtil.COMPATIBILITY_0_10_0);
+		}
+
+		static void apply(Map<String, ModContainerImpl> configToModMap) {
+			for (Config rawConfig : Mixins.getConfigs()) {
+				ModContainerImpl mod = configToModMap.get(rawConfig.getName());
+				if (mod == null) continue;
+
+				IMixinConfig config = rawConfig.getConfig();
+				config.decorate(FabricUtil.KEY_MOD_ID, mod.getMetadata().getId());
+				config.decorate(FabricUtil.KEY_COMPATIBILITY, getMixinCompat(mod));
+			}
+		}
+
+		private static int getMixinCompat(ModContainerImpl mod) {
+			// infer from loader dependency by determining the least relevant loader version the mod accepts
+			// AND any loader deps
+
+			List<VersionInterval> reqIntervals = Collections.singletonList(VersionInterval.INFINITE);
+
+			for (ModDependency dep : mod.getMetadata().getDependencies()) {
+				if (dep.getModId().equals("fabricloader") || dep.getModId().equals("fabric-loader")) {
+					if (dep.getKind() == Kind.DEPENDS) {
+						reqIntervals = VersionInterval.and(reqIntervals, dep.getVersionIntervals());
+					} else if (dep.getKind() == Kind.BREAKS) {
+						reqIntervals = VersionInterval.and(reqIntervals, VersionInterval.not(dep.getVersionIntervals()));
+					}
+				}
+			}
+
+			if (reqIntervals.isEmpty()) throw new IllegalStateException("mod "+mod+" is incompatible with every loader version?"); // shouldn't get there
+
+			Version minLoaderVersion = reqIntervals.get(0).getMin(); // it is sorted, to 0 has the absolute lower bound
+
+			if (minLoaderVersion != null) { // has a lower bound
+				for (LoaderMixinVersionEntry version : versions) {
+					if (minLoaderVersion.compareTo(version.loaderVersion) >= 0) { // lower bound is >= current version
+						return version.mixinVersion;
+					} else {
+						break;
+					}
+				}
+			}
+
+			return FabricUtil.COMPATIBILITY_0_9_2;
+		}
+
+		private static void addVersion(String minLoaderVersion, int mixinCompat) {
+			try {
+				versions.add(new LoaderMixinVersionEntry(SemanticVersion.parse(minLoaderVersion), mixinCompat));
+			} catch (Exception e) {
+				throw new RuntimeException(e);
+			}
+		}
+
+		private static final class LoaderMixinVersionEntry {
+			final SemanticVersion loaderVersion;
+			final int mixinVersion;
+
+			LoaderMixinVersionEntry(SemanticVersion loaderVersion, int mixinVersion) {
+				this.loaderVersion = loaderVersion;
+				this.mixinVersion = mixinVersion;
+			}
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/MappingConfiguration.java b/src/main/java/net/fabricmc/loader/impl/launch/MappingConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..52420966ea086fcda47980f7bd4b0aa35e2e9bb0
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/MappingConfiguration.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch;
+
+import net.fabricmc.loader.impl.util.ManifestUtil;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import net.fabricmc.mapping.tree.TinyMappingFactory;
+import net.fabricmc.mapping.tree.TinyTree;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.JarURLConnection;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.jar.Attributes.Name;
+import java.util.jar.Manifest;
+import java.util.zip.ZipError;
+
+public final class MappingConfiguration {
+	private boolean initialized;
+
+	private String gameId;
+	private String gameVersion;
+	private TinyTree mappings;
+
+	public String getGameId() {
+		initialize();
+
+		return gameId;
+	}
+
+	public String getGameVersion() {
+		initialize();
+
+		return gameVersion;
+	}
+
+	public boolean matches(String gameId, String gameVersion) {
+		initialize();
+
+		return (this.gameId == null || gameId == null || gameId.equals(this.gameId))
+				&& (this.gameVersion == null || gameVersion == null || gameVersion.equals(this.gameVersion));
+	}
+
+	public TinyTree getMappings() {
+		initialize();
+
+		return mappings;
+	}
+
+	public String getTargetNamespace() {
+		return FabricLauncherBase.getLauncher().isDevelopment() ? "named" : "intermediary";
+	}
+
+	public boolean requiresPackageAccessHack() {
+		// TODO
+		return getTargetNamespace().equals("named");
+	}
+
+	private void initialize() {
+		if (initialized) return;
+
+		URL url = MappingConfiguration.class.getClassLoader().getResource("mappings/mappings.tiny");
+
+		if (url != null) {
+			try {
+				URLConnection connection = url.openConnection();
+
+				if (connection instanceof JarURLConnection) {
+					Manifest manifest = ((JarURLConnection) connection).getManifest();
+
+					if (manifest != null) {
+						gameId = ManifestUtil.getManifestValue(manifest, new Name("Game-Id"));
+						gameVersion = ManifestUtil.getManifestValue(manifest, new Name("Game-Version"));
+					}
+				}
+
+				try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
+					long time = System.currentTimeMillis();
+					mappings = TinyMappingFactory.loadWithDetection(reader);
+					Log.debug(LogCategory.MAPPINGS, "Loading mappings took %d ms", System.currentTimeMillis() - time);
+				}
+			} catch (IOException | ZipError e) {
+				throw new RuntimeException("Error reading "+url, e);
+			}
+		}
+
+		if (mappings == null) {
+			Log.info(LogCategory.MAPPINGS, "Mappings not present!");
+			mappings = TinyMappingFactory.EMPTY_TREE;
+		}
+
+		initialized = true;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/DummyClassLoader.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/DummyClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..77a9da076f90ec5a2fa0363af4c89f776a14639b
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/DummyClassLoader.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import java.io.IOException;
+import java.net.URL;
+import java.util.Enumeration;
+
+class DummyClassLoader extends ClassLoader {
+	private static final Enumeration<URL> NULL_ENUMERATION = new Enumeration<URL>() {
+		@Override
+		public boolean hasMoreElements() {
+			return false;
+		}
+
+		@Override
+		public URL nextElement() {
+			return null;
+		}
+	};
+
+	static {
+		registerAsParallelCapable();
+	}
+
+	@Override
+	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+		throw new ClassNotFoundException(name);
+	}
+
+	@Override
+	public URL getResource(String name) {
+		return null;
+	}
+
+	@Override
+	public Enumeration<URL> getResources(String var1) throws IOException {
+		return NULL_ENUMERATION;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/FabricGlobalPropertyService.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/FabricGlobalPropertyService.java
new file mode 100644
index 0000000000000000000000000000000000000000..1ab181d48598ffc2563094fee7bc2f4f7eec0e10
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/FabricGlobalPropertyService.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import org.spongepowered.asm.service.IGlobalPropertyService;
+import org.spongepowered.asm.service.IPropertyKey;
+
+public class FabricGlobalPropertyService implements IGlobalPropertyService {
+	@Override
+	public IPropertyKey resolveKey(String name) {
+		return new MixinStringPropertyKey(name);
+	}
+
+	private String keyString(IPropertyKey key) {
+		return ((MixinStringPropertyKey) key).key;
+	}
+
+	@Override
+	@SuppressWarnings("unchecked")
+	public <T> T getProperty(IPropertyKey key) {
+		return (T) FabricLauncherBase.getProperties().get(keyString(key));
+	}
+
+	@Override
+	public void setProperty(IPropertyKey key, Object value) {
+		FabricLauncherBase.getProperties().put(keyString(key), value);
+	}
+
+	@Override
+	@SuppressWarnings("unchecked")
+	public <T> T getProperty(IPropertyKey key, T defaultValue) {
+		return (T) FabricLauncherBase.getProperties().getOrDefault(keyString(key), defaultValue);
+	}
+
+	@Override
+	public String getPropertyString(IPropertyKey key, String defaultValue) {
+		Object o = FabricLauncherBase.getProperties().get(keyString(key));
+		return o != null ? o.toString() : defaultValue;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/Knot.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/Knot.java
new file mode 100644
index 0000000000000000000000000000000000000000..81fda02d810767e6c1d05beae45cec27d057dc80
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/Knot.java
@@ -0,0 +1,340 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.entrypoint.PreLaunchEntrypoint;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.FormattedException;
+import net.fabricmc.loader.impl.entrypoint.EntrypointUtils;
+import net.fabricmc.loader.impl.game.GameProvider;
+import net.fabricmc.loader.impl.game.minecraft.MinecraftGameProvider;
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import net.fabricmc.loader.impl.launch.FabricMixinBootstrap;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.UrlUtil;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+import java.util.jar.Manifest;
+import java.util.stream.Collectors;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+public final class Knot extends FabricLauncherBase {
+	protected Map<String, Object> properties = new HashMap<>();
+
+	private KnotClassLoaderInterface classLoader;
+	private boolean isDevelopment;
+	private EnvType envType;
+	private final List<Path> classPath = new ArrayList<>();
+	private GameProvider provider;
+	private boolean unlocked;
+
+	public static void launch(String[] args, EnvType type) {
+		setupUncaughtExceptionHandler();
+
+		try {
+			Knot knot = new Knot(type);
+			ClassLoader cl = knot.init(args);
+
+			if (knot.provider == null) {
+				throw new IllegalStateException("Game provider was not initialized! (Knot#init(String[]))");
+			}
+
+			knot.provider.launch(cl);
+		} catch (FormattedException e) {
+			handleFormattedException(e);
+		}
+	}
+
+	public Knot(EnvType type) {
+		this.envType = type;
+	}
+
+	public ClassLoader init(String[] args) {
+		setProperties(properties);
+
+		// configure fabric vars
+		if (envType == null) {
+			String side = System.getProperty(SystemProperties.SIDE);
+			if (side == null) throw new RuntimeException("Please specify side or use a dedicated Knot!");
+
+			switch (side.toLowerCase(Locale.ROOT)) {
+			case "client":
+				envType = EnvType.CLIENT;
+				break;
+			case "server":
+				envType = EnvType.SERVER;
+				break;
+			default:
+				throw new RuntimeException("Invalid side provided: must be \"client\" or \"server\"!");
+			}
+		}
+
+		classPath.clear();
+
+		List<String> missing = null;
+		List<String> unsupported = null;
+
+		for (String cpEntry : System.getProperty("java.class.path").split(File.pathSeparator)) {
+			if (cpEntry.equals("*") || cpEntry.endsWith(File.separator + "*")) {
+				if (unsupported == null) unsupported = new ArrayList<>();
+				unsupported.add(cpEntry);
+				continue;
+			}
+
+			Path path = Paths.get(cpEntry);
+
+			if (!Files.exists(path)) {
+				if (missing == null) missing = new ArrayList<>();
+				missing.add(cpEntry);
+				continue;
+			}
+
+			classPath.add(LoaderUtil.normalizeExistingPath(path));
+		}
+
+		if (unsupported != null) Log.warn(LogCategory.KNOT, "Knot does not support wildcard class path entries: %s - the game may not load properly!", String.join(", ", unsupported));
+		if (missing != null) Log.warn(LogCategory.KNOT, "Class path entries reference missing files: %s - the game may not load properly!", String.join(", ", missing));
+
+		provider = createGameProvider(args);
+		Log.finishBuiltinConfig();
+		Log.info(LogCategory.GAME_PROVIDER, "Loading %s %s with Fabric Loader %s", provider.getGameName(), provider.getRawGameVersion(), FabricLoaderImpl.VERSION);
+
+		isDevelopment = Boolean.parseBoolean(System.getProperty(SystemProperties.DEVELOPMENT, "false"));
+
+		// Setup classloader
+		// TODO: Provide KnotCompatibilityClassLoader in non-exclusive-Fabric pre-1.13 environments?
+		boolean useCompatibility = provider.requiresUrlClassLoader() || Boolean.parseBoolean(System.getProperty("fabric.loader.useCompatibilityClassLoader", "false"));
+		classLoader = KnotClassLoaderInterface.create(useCompatibility, isDevelopment(), envType, provider);
+		ClassLoader cl = classLoader.getClassLoader();
+
+		provider.initialize(this);
+
+		Thread.currentThread().setContextClassLoader(cl);
+
+		FabricLoaderImpl loader = FabricLoaderImpl.INSTANCE;
+		loader.setGameProvider(provider);
+		loader.load();
+		loader.freeze();
+
+		FabricLoaderImpl.INSTANCE.loadAccessWideners();
+
+		FabricMixinBootstrap.init(getEnvironmentType(), loader);
+		FabricLauncherBase.finishMixinBootstrapping();
+
+		classLoader.initializeTransformers();
+
+		provider.unlockClassPath(this);
+		unlocked = true;
+
+		try {
+			EntrypointUtils.invoke("preLaunch", PreLaunchEntrypoint.class, PreLaunchEntrypoint::onPreLaunch);
+		} catch (RuntimeException e) {
+			throw new FormattedException("A mod crashed on startup!", e);
+		}
+
+		return cl;
+	}
+
+	private GameProvider createGameProvider(String[] args) {
+		// fast path with direct lookup
+
+		GameProvider embeddedGameProvider = findEmbedddedGameProvider();
+
+		if (embeddedGameProvider != null
+				&& embeddedGameProvider.isEnabled()
+				&& embeddedGameProvider.locateGame(this, args)) {
+			return embeddedGameProvider;
+		}
+
+		// slow path with service loader
+
+		List<GameProvider> failedProviders = new ArrayList<>();
+
+		GameProvider provider = new MinecraftGameProvider();
+			if (provider != embeddedGameProvider // don't retry already failed provider
+					&& provider.locateGame(this, args)) {
+				return provider;
+			}
+
+			failedProviders.add(provider);
+
+
+		// nothing found
+
+		String msg;
+
+		if (failedProviders.isEmpty()) {
+			msg = "No game providers present on the class path!";
+		} else if (failedProviders.size() == 1) {
+			msg = String.format("%s game provider couldn't locate the game! "
+					+ "The game may be absent from the class path, lacks some expected files, suffers from jar "
+					+ "corruption or is of an unsupported variety/version.",
+					failedProviders.get(0).getGameName());
+		} else {
+			msg = String.format("None of the game providers (%s) were able to locate their game!",
+					failedProviders.stream().map(GameProvider::getGameName).collect(Collectors.joining(", ")));
+		}
+
+		Log.error(LogCategory.GAME_PROVIDER, msg);
+
+		throw new RuntimeException(msg);
+	}
+
+	/**
+	 * Find game provider embedded into the Fabric Loader jar, best effort.
+	 *
+	 * <p>This is faster than going through service loader because it only looks at a single jar.
+	 */
+	private static GameProvider findEmbedddedGameProvider() {
+		try {
+			Path flPath = UrlUtil.getCodeSource(Knot.class);
+			if (flPath == null || !flPath.getFileName().toString().endsWith(".jar")) return null; // not a jar
+
+			try (ZipFile zf = new ZipFile(flPath.toFile())) {
+				ZipEntry entry = zf.getEntry("META-INF/services/net.fabricmc.loader.impl.game.GameProvider"); // same file as used by service loader
+				if (entry == null) return null;
+
+				try (InputStream is = zf.getInputStream(entry)) {
+					byte[] buffer = new byte[100];
+					int offset = 0;
+					int len;
+
+					while ((len = is.read(buffer, offset, buffer.length - offset)) >= 0) {
+						offset += len;
+						if (offset == buffer.length) buffer = Arrays.copyOf(buffer, buffer.length * 2);
+					}
+
+					String content = new String(buffer, 0, offset, StandardCharsets.UTF_8).trim();
+					if (content.indexOf('\n') >= 0) return null; // potentially more than one entry -> bail out
+
+					int pos = content.indexOf('#');
+					if (pos >= 0) content = content.substring(0, pos).trim();
+
+					if (!content.isEmpty()) {
+						return (GameProvider) Class.forName(content).getConstructor().newInstance();
+					}
+				}
+			}
+
+			return null;
+		} catch (IOException | ReflectiveOperationException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	@Override
+	public String getTargetNamespace() {
+		// TODO: Won't work outside of Yarn
+		return isDevelopment ? "named" : "intermediary";
+	}
+
+	@Override
+	public List<Path> getClassPath() {
+		return classPath;
+	}
+
+	@Override
+	public void addToClassPath(Path path, String... allowedPrefixes) {
+		Log.debug(LogCategory.KNOT, "Adding " + path + " to classpath.");
+
+		classLoader.setAllowedPrefixes(path, allowedPrefixes);
+		classLoader.addCodeSource(path);
+	}
+
+	@Override
+	public void setAllowedPrefixes(Path path, String... prefixes) {
+		classLoader.setAllowedPrefixes(path, prefixes);
+	}
+
+	@Override
+	public void setValidParentClassPath(Collection<Path> paths) {
+		classLoader.setValidParentClassPath(paths);
+	}
+
+	@Override
+	public EnvType getEnvironmentType() {
+		return envType;
+	}
+
+	@Override
+	public boolean isClassLoaded(String name) {
+		return classLoader.isClassLoaded(name);
+	}
+
+	@Override
+	public Class<?> loadIntoTarget(String name) throws ClassNotFoundException {
+		return classLoader.loadIntoTarget(name);
+	}
+
+	@Override
+	public InputStream getResourceAsStream(String name) {
+		return classLoader.getClassLoader().getResourceAsStream(name);
+	}
+
+	@Override
+	public ClassLoader getTargetClassLoader() {
+		KnotClassLoaderInterface classLoader = this.classLoader;
+
+		return classLoader != null ? classLoader.getClassLoader() : null;
+	}
+
+	@Override
+	public byte[] getClassByteArray(String name, boolean runTransformers) throws IOException {
+		if (!unlocked) throw new IllegalStateException("early getClassByteArray access");
+
+		if (runTransformers) {
+			return classLoader.getPreMixinClassBytes(name);
+		} else {
+			return classLoader.getRawClassBytes(name);
+		}
+	}
+
+	@Override
+	public Manifest getManifest(Path originPath) {
+		return classLoader.getManifest(originPath);
+	}
+
+	@Override
+	public boolean isDevelopment() {
+		return isDevelopment;
+	}
+
+	@Override
+	public String getEntrypoint() {
+		return provider.getEntrypoint();
+	}
+
+	public static void main(String[] args) {
+		new Knot(null).init(args);
+	}
+
+	static {
+		LoaderUtil.verifyNotInTargetCl(Knot.class);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClassDelegate.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClassDelegate.java
new file mode 100644
index 0000000000000000000000000000000000000000..26c4b755eb9f73d170a55d1f0ef56470d04085c0
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClassDelegate.java
@@ -0,0 +1,522 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.game.GameProvider;
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import net.fabricmc.loader.impl.transformer.FabricTransformer;
+import net.fabricmc.loader.impl.util.*;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import org.spongepowered.asm.mixin.transformer.IMixinTransformer;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Constructor;
+import java.net.JarURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.nio.file.FileSystemNotFoundException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.security.CodeSource;
+import java.security.cert.Certificate;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.jar.Manifest;
+
+final class KnotClassDelegate<T extends ClassLoader & KnotClassDelegate.ClassLoaderAccess> implements KnotClassLoaderInterface {
+	private static final boolean LOG_CLASS_LOAD = System.getProperty(SystemProperties.DEBUG_LOG_CLASS_LOAD) != null;
+	private static final boolean LOG_CLASS_LOAD_ERRORS = LOG_CLASS_LOAD || System.getProperty(SystemProperties.DEBUG_LOG_CLASS_LOAD_ERRORS) != null;
+	private static final boolean LOG_TRANSFORM_ERRORS = System.getProperty(SystemProperties.DEBUG_LOG_TRANSFORM_ERRORS) != null;
+	private static final boolean DISABLE_ISOLATION = System.getProperty(SystemProperties.DEBUG_DISABLE_CLASS_PATH_ISOLATION) != null;
+
+	static final class Metadata {
+		static final Metadata EMPTY = new Metadata(null, null);
+
+		final Manifest manifest;
+		final CodeSource codeSource;
+
+		Metadata(Manifest manifest, CodeSource codeSource) {
+			this.manifest = manifest;
+			this.codeSource = codeSource;
+		}
+	}
+
+	private static final ClassLoader PLATFORM_CLASS_LOADER = getPlatformClassLoader();
+
+	private final Map<Path, Metadata> metadataCache = new ConcurrentHashMap<>();
+	private final T classLoader;
+	private final ClassLoader parentClassLoader;
+	private final GameProvider provider;
+	private final boolean isDevelopment;
+	private final EnvType envType;
+	private IMixinTransformer mixinTransformer;
+	private boolean transformInitialized = false;
+	private volatile Set<Path> codeSources = Collections.emptySet();
+	private volatile Set<Path> validParentCodeSources = Collections.emptySet();
+	private final Map<Path, String[]> allowedPrefixes = new ConcurrentHashMap<>();
+	private final Set<String> parentSourcedClasses = Collections.newSetFromMap(new ConcurrentHashMap<>());
+
+	KnotClassDelegate(boolean isDevelopment, EnvType envType, T classLoader, ClassLoader parentClassLoader, GameProvider provider) {
+		this.isDevelopment = isDevelopment;
+		this.envType = envType;
+		this.classLoader = classLoader;
+		this.parentClassLoader = parentClassLoader;
+		this.provider = provider;
+	}
+
+	@Override
+	public ClassLoader getClassLoader() {
+		return classLoader;
+	}
+
+	@Override
+	public void initializeTransformers() {
+		if (transformInitialized) throw new IllegalStateException("Cannot initialize KnotClassDelegate twice!");
+
+		mixinTransformer = MixinServiceKnot.getTransformer();
+
+		if (mixinTransformer == null) {
+			try { // reflective instantiation for older mixin versions
+				@SuppressWarnings("unchecked")
+				Constructor<IMixinTransformer> ctor = (Constructor<IMixinTransformer>) Class.forName("org.spongepowered.asm.mixin.transformer.MixinTransformer").getConstructor();
+				ctor.setAccessible(true);
+				mixinTransformer = ctor.newInstance();
+			} catch (ReflectiveOperationException e) {
+				Log.debug(LogCategory.KNOT, "Can't create Mixin transformer through reflection (only applicable for 0.8-0.8.2): %s", e);
+
+				// both lookups failed (not received through IMixinService.offer and not found through reflection)
+				throw new IllegalStateException("mixin transformer unavailable?");
+			}
+		}
+
+		transformInitialized = true;
+	}
+
+	private IMixinTransformer getMixinTransformer() {
+		assert mixinTransformer != null;
+		return mixinTransformer;
+	}
+
+	@Override
+	public void addCodeSource(Path path) {
+		path = LoaderUtil.normalizeExistingPath(path);
+
+		synchronized (this) {
+			Set<Path> codeSources = this.codeSources;
+			if (codeSources.contains(path)) return;
+
+			Set<Path> newCodeSources = new HashSet<>(codeSources.size() + 1, 1);
+			newCodeSources.addAll(codeSources);
+			newCodeSources.add(path);
+
+			this.codeSources = newCodeSources;
+		}
+
+		try {
+			classLoader.addUrlFwd(UrlUtil.asUrl(path));
+		} catch (MalformedURLException e) {
+			throw new RuntimeException(e);
+		}
+
+		if (LOG_CLASS_LOAD_ERRORS) Log.info(LogCategory.KNOT, "added code source %s", path);
+	}
+
+	@Override
+	public void setAllowedPrefixes(Path codeSource, String... prefixes) {
+		codeSource = LoaderUtil.normalizeExistingPath(codeSource);
+
+		if (prefixes.length == 0) {
+			allowedPrefixes.remove(codeSource);
+		} else {
+			allowedPrefixes.put(codeSource, prefixes);
+		}
+	}
+
+	@Override
+	public void setValidParentClassPath(Collection<Path> paths) {
+		Set<Path> validPaths = new HashSet<>(paths.size(), 1);
+
+		for (Path path : paths) {
+			validPaths.add(LoaderUtil.normalizeExistingPath(path));
+		}
+
+		this.validParentCodeSources = validPaths;
+	}
+
+	@Override
+	public Manifest getManifest(Path codeSource) {
+		return getMetadata(LoaderUtil.normalizeExistingPath(codeSource)).manifest;
+	}
+
+	@Override
+	public boolean isClassLoaded(String name) {
+		synchronized (classLoader.getClassLoadingLockFwd(name)) {
+			return classLoader.findLoadedClassFwd(name) != null;
+		}
+	}
+
+	@Override
+	public Class<?> loadIntoTarget(String name) throws ClassNotFoundException {
+		synchronized (classLoader.getClassLoadingLockFwd(name)) {
+			Class<?> c = classLoader.findLoadedClassFwd(name);
+
+			if (c == null) {
+				c = tryLoadClass(name, true);
+
+				if (c == null) {
+					throw new ClassNotFoundException("can't find class "+name);
+				} else if (LOG_CLASS_LOAD) {
+					Log.info(LogCategory.KNOT, "loaded class %s into target", name);
+				}
+			}
+
+			classLoader.resolveClassFwd(c);
+
+			return c;
+		}
+	}
+
+	Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+		synchronized (classLoader.getClassLoadingLockFwd(name)) {
+			Class<?> c = classLoader.findLoadedClassFwd(name);
+
+			if (c == null) {
+				if (name.startsWith("java.")) { // fast path for java.** (can only be loaded by the platform CL anyway)
+					c = PLATFORM_CLASS_LOADER.loadClass(name);
+				} else {
+					c = tryLoadClass(name, false); // try local load
+
+					if (c == null) { // not available locally, try system class loader
+						String fileName = LoaderUtil.getClassFileName(name);
+						URL url = parentClassLoader.getResource(fileName);
+
+						if (url == null) { // no .class file
+							try {
+								c = PLATFORM_CLASS_LOADER.loadClass(name);
+								if (LOG_CLASS_LOAD) Log.info(LogCategory.KNOT, "loaded resources-less class %s from platform class loader");
+							} catch (ClassNotFoundException e) {
+								if (LOG_CLASS_LOAD_ERRORS) Log.warn(LogCategory.KNOT, "can't find class %s", name);
+								throw e;
+							}
+						} else if (!isValidParentUrl(url, fileName)) { // available, but restricted
+							// The class would technically be available, but the game provider restricted it from being
+							// loaded by setting validParentUrls and not including "url". Typical causes are:
+							// - accessing classes too early (game libs shouldn't be used until Loader is ready)
+							// - using jars that are only transient (deobfuscation input or pass-through installers)
+							String msg = String.format("can't load class %s at %s as it hasn't been exposed to the game (yet?)", name, getCodeSource(url, fileName));
+							if (LOG_CLASS_LOAD_ERRORS) Log.warn(LogCategory.KNOT, msg);
+							throw new ClassNotFoundException(msg);
+						} else { // load from system cl
+							if (LOG_CLASS_LOAD) Log.info(LogCategory.KNOT, "loading class %s using the parent class loader", name);
+							c = parentClassLoader.loadClass(name);
+						}
+					} else if (LOG_CLASS_LOAD) {
+						Log.info(LogCategory.KNOT, "loaded class %s", name);
+					}
+				}
+			}
+
+			if (resolve) {
+				classLoader.resolveClassFwd(c);
+			}
+
+			return c;
+		}
+	}
+
+	/**
+	 * Check if an url is loadable by the parent class loader.
+	 *
+	 * <p>This handles explicit parent url whitelisting by {@link #validParentCodeSources} or shadowing by {@link #codeSources}
+	 */
+	private boolean isValidParentUrl(URL url, String fileName) {
+		if (url == null) return false;
+		if (DISABLE_ISOLATION) return true;
+		if (!hasRegularCodeSource(url)) return true;
+
+		Path codeSource = getCodeSource(url, fileName);
+		Set<Path> validParentCodeSources = this.validParentCodeSources;
+
+		if (validParentCodeSources != null) { // explicit whitelist (in addition to platform cl classes)
+			return validParentCodeSources.contains(codeSource) || PLATFORM_CLASS_LOADER.getResource(fileName) != null;
+		} else { // reject urls shadowed by this cl
+			return !codeSources.contains(codeSource);
+		}
+	}
+
+	Class<?> tryLoadClass(String name, boolean allowFromParent) throws ClassNotFoundException {
+		if (name.startsWith("java.")) {
+			return null;
+		}
+
+		if (!allowedPrefixes.isEmpty() && !DISABLE_ISOLATION) { // check prefix restrictions (allows exposing libraries partially during startup)
+			String fileName = LoaderUtil.getClassFileName(name);
+			URL url = classLoader.getResource(fileName);
+
+			if (url != null && hasRegularCodeSource(url)) {
+				Path codeSource = getCodeSource(url, fileName);
+				String[] prefixes = allowedPrefixes.get(codeSource);
+
+				if (prefixes != null) {
+					assert prefixes.length > 0;
+					boolean found = false;
+
+					for (String prefix : prefixes) {
+						if (name.startsWith(prefix)) {
+							found = true;
+							break;
+						}
+					}
+
+					if (!found) {
+						String msg = "class "+name+" is currently restricted from being loaded";
+						if (LOG_CLASS_LOAD_ERRORS) Log.warn(LogCategory.KNOT, msg);
+						throw new ClassNotFoundException(msg);
+					}
+				}
+			}
+		}
+
+		if (!allowFromParent && !parentSourcedClasses.isEmpty()) { // propagate loadIntoTarget behavior to its nested classes
+			int pos = name.length();
+
+			while ((pos = name.lastIndexOf('$', pos - 1)) > 0) {
+				if (parentSourcedClasses.contains(name.substring(0, pos))) {
+					allowFromParent = true;
+					break;
+				}
+			}
+		}
+
+		byte[] input = getPostMixinClassByteArray(name, allowFromParent);
+		if (input == null) return null;
+
+		if (allowFromParent) {
+			parentSourcedClasses.add(name);
+		}
+
+		Metadata metadata = getMetadata(name);
+
+		int pkgDelimiterPos = name.lastIndexOf('.');
+
+		if (pkgDelimiterPos > 0) {
+			// TODO: package definition stub
+			String pkgString = name.substring(0, pkgDelimiterPos);
+
+			if (classLoader.getPackageFwd(pkgString) == null) {
+				try {
+					classLoader.definePackageFwd(pkgString, null, null, null, null, null, null, null);
+				} catch (IllegalArgumentException e) { // presumably concurrent package definition
+					if (classLoader.getPackageFwd(pkgString) == null) throw e; // still not defined?
+				}
+			}
+		}
+
+		return classLoader.defineClassFwd(name, input, 0, input.length, metadata.codeSource);
+	}
+
+	private Metadata getMetadata(String name) {
+		String fileName = LoaderUtil.getClassFileName(name);
+		URL url = classLoader.getResource(fileName);
+		if (url == null || !hasRegularCodeSource(url)) return Metadata.EMPTY;
+
+		return getMetadata(getCodeSource(url, fileName));
+	}
+
+	private Metadata getMetadata(Path codeSource) {
+		return metadataCache.computeIfAbsent(codeSource, (Path path) -> {
+			Manifest manifest = null;
+			CodeSource cs = null;
+			Certificate[] certificates = null;
+
+			try {
+				if (Files.isDirectory(path)) {
+					manifest = ManifestUtil.readManifest(path);
+				} else {
+					URLConnection connection = new URL("jar:" + path.toUri().toString() + "!/").openConnection();
+
+					if (connection instanceof JarURLConnection) {
+						manifest = ((JarURLConnection) connection).getManifest();
+						certificates = ((JarURLConnection) connection).getCertificates();
+					}
+
+					if (manifest == null) {
+						try (FileSystemUtil.FileSystemDelegate jarFs = FileSystemUtil.getJarFileSystem(path, false)) {
+							manifest = ManifestUtil.readManifest(jarFs.get().getRootDirectories().iterator().next());
+						}
+					}
+
+					// TODO
+					/* JarEntry codeEntry = codeSourceJar.getJarEntry(filename);
+
+					if (codeEntry != null) {
+						cs = new CodeSource(codeSourceURL, codeEntry.getCodeSigners());
+					} */
+				}
+			} catch (IOException | FileSystemNotFoundException e) {
+				if (FabricLauncherBase.getLauncher().isDevelopment()) {
+					Log.warn(LogCategory.KNOT, "Failed to load manifest", e);
+				}
+			}
+
+			if (cs == null) {
+				try {
+					cs = new CodeSource(UrlUtil.asUrl(path), certificates);
+				} catch (MalformedURLException e) {
+					throw new RuntimeException(e);
+				}
+			}
+
+			return new Metadata(manifest, cs);
+		});
+	}
+
+	private byte[] getPostMixinClassByteArray(String name, boolean allowFromParent) {
+		byte[] transformedClassArray = getPreMixinClassByteArray(name, allowFromParent);
+
+		if (!transformInitialized || !canTransformClass(name)) {
+			return transformedClassArray;
+		}
+
+		try {
+			return getMixinTransformer().transformClassBytes(name, name, transformedClassArray);
+		} catch (Throwable t) {
+			String msg = String.format("Mixin transformation of %s failed", name);
+			if (LOG_TRANSFORM_ERRORS) Log.warn(LogCategory.KNOT, msg, t);
+
+			throw new RuntimeException(msg, t);
+		}
+	}
+
+	@Override
+	public byte[] getPreMixinClassBytes(String name) {
+		return getPreMixinClassByteArray(name, true);
+	}
+
+	/**
+	 * Runs all the class transformers except mixin.
+	 */
+	private byte[] getPreMixinClassByteArray(String name, boolean allowFromParent) {
+		// some of the transformers rely on dot notation
+		name = name.replace('/', '.');
+
+		if (!transformInitialized || !canTransformClass(name)) {
+			try {
+				return getRawClassByteArray(name, allowFromParent);
+			} catch (IOException e) {
+				throw new RuntimeException("Failed to load class file for '" + name + "'!", e);
+			}
+		}
+
+		byte[] input = provider.getEntrypointTransformer().transform(name);
+
+		if (input == null) {
+			try {
+				input = getRawClassByteArray(name, allowFromParent);
+			} catch (IOException e) {
+				throw new RuntimeException("Failed to load class file for '" + name + "'!", e);
+			}
+		}
+
+		if (input != null) {
+			return FabricTransformer.transform(isDevelopment, envType, name, input);
+		}
+
+		return null;
+	}
+
+	private static boolean canTransformClass(String name) {
+		name = name.replace('/', '.');
+		// Blocking Fabric Loader classes is no longer necessary here as they don't exist on the modding class loader
+		return /* !"net.fabricmc.api.EnvType".equals(name) && !name.startsWith("net.fabricmc.loader.") && */ !name.startsWith("org.apache.logging.log4j");
+	}
+
+	@Override
+	public byte[] getRawClassBytes(String name) throws IOException {
+		return getRawClassByteArray(name, true);
+	}
+
+	private byte[] getRawClassByteArray(String name, boolean allowFromParent) throws IOException {
+		name = LoaderUtil.getClassFileName(name);
+		URL url = classLoader.findResourceFwd(name);
+
+		if (url == null) {
+			if (!allowFromParent) return null;
+
+			url = parentClassLoader.getResource(name);
+
+			if (!isValidParentUrl(url, name)) {
+				if (LOG_CLASS_LOAD) Log.info(LogCategory.KNOT, "refusing to load class %s at %s from parent class loader", name, getCodeSource(url, name));
+
+				return null;
+			}
+		}
+
+		try (InputStream inputStream = url.openStream()) {
+			int a = inputStream.available();
+			ByteArrayOutputStream outputStream = new ByteArrayOutputStream(a < 32 ? 32768 : a);
+			byte[] buffer = new byte[8192];
+			int len;
+
+			while ((len = inputStream.read(buffer)) > 0) {
+				outputStream.write(buffer, 0, len);
+			}
+
+			return outputStream.toByteArray();
+		}
+	}
+
+	private static boolean hasRegularCodeSource(URL url) {
+		return url.getProtocol().equals("file") || url.getProtocol().equals("jar");
+	}
+
+	private static Path getCodeSource(URL url, String fileName) {
+		try {
+			return LoaderUtil.normalizeExistingPath(UrlUtil.getCodeSource(url, fileName));
+		} catch (UrlConversionException e) {
+			throw ExceptionUtil.wrap(e);
+		}
+	}
+
+	private static ClassLoader getPlatformClassLoader() {
+		try {
+			return (ClassLoader) ClassLoader.class.getMethod("getPlatformClassLoader").invoke(null); // Java 9+ only
+		} catch (NoSuchMethodException e) {
+			return new ClassLoader(null) { }; // fall back to boot cl
+		} catch (ReflectiveOperationException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	interface ClassLoaderAccess {
+		void addUrlFwd(URL url);
+		URL findResourceFwd(String name);
+
+		Package getPackageFwd(String name);
+		Package definePackageFwd(String name, String specTitle, String specVersion, String specVendor, String implTitle, String implVersion, String implVendor, URL sealBase) throws IllegalArgumentException;
+
+		Object getClassLoadingLockFwd(String name);
+		Class<?> findLoadedClassFwd(String name);
+		Class<?> defineClassFwd(String name, byte[] b, int off, int len, CodeSource cs);
+		void resolveClassFwd(Class<?> cls);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClassLoader.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..09880e46e3e8431bffc462f0484c1e58d2112274
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClassLoader.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.game.GameProvider;
+import net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.ClassLoaderAccess;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.security.CodeSource;
+import java.security.SecureClassLoader;
+import java.util.Enumeration;
+import java.util.Objects;
+
+// class name referenced by string constant in net.fabricmc.loader.impl.util.LoaderUtil.verifyNotInTargetCl
+final class KnotClassLoader extends SecureClassLoader implements ClassLoaderAccess {
+	private static final class DynamicURLClassLoader extends URLClassLoader {
+		private DynamicURLClassLoader(URL[] urls) {
+			super(urls, new DummyClassLoader());
+		}
+
+		@Override
+		public void addURL(URL url) {
+			super.addURL(url);
+		}
+
+		static {
+			registerAsParallelCapable();
+		}
+	}
+
+	private final DynamicURLClassLoader urlLoader;
+	private final ClassLoader originalLoader;
+	private final KnotClassDelegate<KnotClassLoader> delegate;
+
+	KnotClassLoader(boolean isDevelopment, EnvType envType, GameProvider provider) {
+		super(new DynamicURLClassLoader(new URL[0]));
+		this.originalLoader = getClass().getClassLoader();
+		this.urlLoader = (DynamicURLClassLoader) getParent();
+		this.delegate = new KnotClassDelegate<>(isDevelopment, envType, this, originalLoader, provider);
+	}
+
+	KnotClassDelegate<?> getDelegate() {
+		return delegate;
+	}
+
+	@Override
+	public URL getResource(String name) {
+		Objects.requireNonNull(name);
+
+		URL url = urlLoader.getResource(name);
+
+		if (url == null) {
+			url = originalLoader.getResource(name);
+		}
+
+		return url;
+	}
+
+	@Override
+	public URL findResource(String name) {
+		Objects.requireNonNull(name);
+
+		return urlLoader.findResource(name);
+	}
+
+	@Override
+	public InputStream getResourceAsStream(String name) {
+		Objects.requireNonNull(name);
+
+		InputStream inputStream = urlLoader.getResourceAsStream(name);
+
+		if (inputStream == null) {
+			inputStream = originalLoader.getResourceAsStream(name);
+		}
+
+		return inputStream;
+	}
+
+	@Override
+	public Enumeration<URL> getResources(String name) throws IOException {
+		Objects.requireNonNull(name);
+
+		Enumeration<URL> first = urlLoader.getResources(name);
+		Enumeration<URL> second = originalLoader.getResources(name);
+		return new Enumeration<URL>() {
+			Enumeration<URL> current = first;
+
+			@Override
+			public boolean hasMoreElements() {
+				if (current == null) {
+					return false;
+				}
+
+				if (current.hasMoreElements()) {
+					return true;
+				}
+
+				if (current == first && second.hasMoreElements()) {
+					return true;
+				}
+
+				return false;
+			}
+
+			@Override
+			public URL nextElement() {
+				if (current == null) {
+					return null;
+				}
+
+				if (!current.hasMoreElements()) {
+					if (current == first) {
+						current = second;
+					} else {
+						current = null;
+						return null;
+					}
+				}
+
+				return current.nextElement();
+			}
+		};
+	}
+
+	@Override
+	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+		return delegate.loadClass(name, resolve);
+	}
+
+	@Override
+	protected Class<?> findClass(String name) throws ClassNotFoundException {
+		return delegate.tryLoadClass(name, false);
+	}
+
+	@Override
+	public void addUrlFwd(URL url) {
+		urlLoader.addURL(url);
+	}
+
+	@Override
+	public URL findResourceFwd(String name) {
+		return urlLoader.findResource(name);
+	}
+
+	@Override
+	public Package getPackageFwd(String name) {
+		return super.getPackage(name);
+	}
+
+	@Override
+	public Package definePackageFwd(String name, String specTitle, String specVersion, String specVendor,
+			String implTitle, String implVersion, String implVendor, URL sealBase) throws IllegalArgumentException {
+		return super.definePackage(name, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, sealBase);
+	}
+
+	@Override
+	public Object getClassLoadingLockFwd(String name) {
+		return super.getClassLoadingLock(name);
+	}
+
+	@Override
+	public Class<?> findLoadedClassFwd(String name) {
+		return super.findLoadedClass(name);
+	}
+
+	@Override
+	public Class<?> defineClassFwd(String name, byte[] b, int off, int len, CodeSource cs) {
+		return super.defineClass(name, b, off, len, cs);
+	}
+
+	@Override
+	public void resolveClassFwd(Class<?> cls) {
+		super.resolveClass(cls);
+	}
+
+	static {
+		registerAsParallelCapable();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClassLoaderInterface.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClassLoaderInterface.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c9207f895e932a1771607113dc3881ef0ef9a1f
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClassLoaderInterface.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.game.GameProvider;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.Collection;
+import java.util.jar.Manifest;
+
+interface KnotClassLoaderInterface {
+	@SuppressWarnings("resource")
+	static KnotClassLoaderInterface create(boolean useCompatibility, boolean isDevelopment, EnvType envType, GameProvider provider) {
+		if (useCompatibility) {
+			return new KnotCompatibilityClassLoader(isDevelopment, envType, provider).getDelegate();
+		} else {
+			return new KnotClassLoader(isDevelopment, envType, provider).getDelegate();
+		}
+	}
+
+	void initializeTransformers();
+
+	ClassLoader getClassLoader();
+
+	void addCodeSource(Path path);
+	void setAllowedPrefixes(Path codeSource, String... prefixes);
+	void setValidParentClassPath(Collection<Path> codeSources);
+
+	Manifest getManifest(Path codeSource);
+
+	boolean isClassLoaded(String name);
+	Class<?> loadIntoTarget(String name) throws ClassNotFoundException;
+
+	byte[] getRawClassBytes(String name) throws IOException;
+	byte[] getPreMixinClassBytes(String name);
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClient.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..a44b8486c210a7271c3a80d5e34acddefcc5b013
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotClient.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import net.fabricmc.api.EnvType;
+
+public class KnotClient {
+	public static void main(String[] args) {
+		Knot.launch(args, EnvType.CLIENT);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotCompatibilityClassLoader.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotCompatibilityClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..d9d422f7b6e183cb92eb04ba4a3cf0294f07cbb1
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotCompatibilityClassLoader.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.game.GameProvider;
+import net.fabricmc.loader.impl.launch.knot.KnotClassDelegate.ClassLoaderAccess;
+
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.security.CodeSource;
+
+class KnotCompatibilityClassLoader extends URLClassLoader implements ClassLoaderAccess {
+	private final KnotClassDelegate<KnotCompatibilityClassLoader> delegate;
+
+	KnotCompatibilityClassLoader(boolean isDevelopment, EnvType envType, GameProvider provider) {
+		super(new URL[0], KnotCompatibilityClassLoader.class.getClassLoader());
+		this.delegate = new KnotClassDelegate<>(isDevelopment, envType, this, getParent(), provider);
+	}
+
+	KnotClassDelegate<?> getDelegate() {
+		return delegate;
+	}
+
+	@Override
+	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+		return delegate.loadClass(name, resolve);
+	}
+
+	@Override
+	protected Class<?> findClass(String name) throws ClassNotFoundException {
+		return delegate.tryLoadClass(name, false);
+	}
+
+	@Override
+	public void addUrlFwd(URL url) {
+		super.addURL(url);
+	}
+
+	@Override
+	public URL findResourceFwd(String name) {
+		return findResource(name);
+	}
+
+	@Override
+	public Package getPackageFwd(String name) {
+		return super.getPackage(name);
+	}
+
+	@Override
+	public Package definePackageFwd(String name, String specTitle, String specVersion, String specVendor,
+			String implTitle, String implVersion, String implVendor, URL sealBase) throws IllegalArgumentException {
+		return super.definePackage(name, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, sealBase);
+	}
+
+	@Override
+	public Object getClassLoadingLockFwd(String name) {
+		return super.getClassLoadingLock(name);
+	}
+
+	@Override
+	public Class<?> findLoadedClassFwd(String name) {
+		return super.findLoadedClass(name);
+	}
+
+	@Override
+	public Class<?> defineClassFwd(String name, byte[] b, int off, int len, CodeSource cs) {
+		return super.defineClass(name, b, off, len, cs);
+	}
+
+	@Override
+	public void resolveClassFwd(Class<?> cls) {
+		super.resolveClass(cls);
+	}
+
+	static {
+		registerAsParallelCapable();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotServer.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..33c1e196a2dadffcf02a1001fac4a43cc4c2a9db
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/KnotServer.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import net.fabricmc.api.EnvType;
+
+public class KnotServer {
+	public static void main(String[] args) {
+		Knot.launch(args, EnvType.SERVER);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinContainerHandleMod.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinContainerHandleMod.java
new file mode 100644
index 0000000000000000000000000000000000000000..23bd994275b2a553939cc2a1ddba3fad91c22f9c
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinContainerHandleMod.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import org.spongepowered.asm.launch.platform.container.IContainerHandle;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class MixinContainerHandleMod implements IContainerHandle {
+	@Override
+	public String getAttribute(String name) {
+		return null;
+	}
+
+	@Override
+	public Collection<IContainerHandle> getNestedContainers() {
+		return Collections.emptyList();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinLogger.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinLogger.java
new file mode 100644
index 0000000000000000000000000000000000000000..09c8ba4a804b8786b9ebdb4c62e06a0ace467075
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinLogger.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+import net.fabricmc.loader.impl.util.log.LogLevel;
+import org.spongepowered.asm.logging.ILogger;
+import org.spongepowered.asm.logging.Level;
+import org.spongepowered.asm.logging.LoggerAdapterAbstract;
+
+import java.util.Arrays;
+import java.util.EnumMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+final class MixinLogger extends LoggerAdapterAbstract {
+	private static final Map<String, ILogger> LOGGER_MAP = new ConcurrentHashMap<>();
+	private static final Map<Level, LogLevel> LEVEL_MAP = createLevelMap();
+
+	private final LogCategory logCategory;
+
+	static ILogger get(String name) {
+		return LOGGER_MAP.computeIfAbsent(name, MixinLogger::new);
+	}
+
+	MixinLogger(String name) {
+		super(name);
+
+		this.logCategory = LogCategory.create(name.replace("mixin", LogCategory.MIXIN.name).replace(".", LogCategory.SEPARATOR));
+	}
+
+	@Override
+	public String getType() {
+		return "Fabric Mixin Logger";
+	}
+
+	@Override
+	public void catching(Level level, Throwable t) {
+		log(level, "Catching ".concat(t.toString()), t);
+	}
+
+	@Override
+	public void log(Level level, String message, Object... params) {
+		LogLevel fabricLevel = translateLevel(level);
+		if (!Log.shouldLog(fabricLevel, logCategory)) return;
+
+		Throwable exc = null;
+
+		if (params != null && params.length > 0) {
+			if (message == null) {
+				if (params[0] instanceof Throwable) exc = (Throwable) params[0];
+			} else {
+				// emulate Log4J's {} tokens and \ escapes
+				StringBuilder sb = new StringBuilder(message.length() + 20);
+				int paramIdx = 0;
+				boolean escaped = false;
+
+				for (int i = 0, max = message.length(); i < max; i++) {
+					char c = message.charAt(i);
+
+					if (escaped) {
+						sb.append(c);
+						escaped = false;
+					} else if (c == '\\' && i + 1 < max) {
+						escaped = true;
+					} else if (c == '{' && i + 1 < max && message.charAt(i + 1) == '}' && paramIdx < params.length) { // unescaped {} with matching param idx
+						Object param = params[paramIdx++];
+
+						if (param == null) {
+							sb.append("null");
+						} else if (param.getClass().isArray()) {
+							String val = Arrays.deepToString(new Object[] { param });
+							sb.append(val, 1, val.length() - 1);
+						} else {
+							sb.append(param);
+						}
+
+						i++; // skip over }
+					} else {
+						sb.append(c);
+					}
+				}
+
+				message = sb.toString();
+
+				if (paramIdx < params.length && params[params.length - 1] instanceof Throwable) {
+					exc = (Throwable) params[params.length - 1];
+				}
+			}
+		}
+
+		Log.log(fabricLevel, logCategory, message, exc);
+	}
+
+	@Override
+	public void log(Level level, String message, Throwable t) {
+		Log.log(translateLevel(level), logCategory, message, t);
+	}
+
+	@Override
+	public <T extends Throwable> T throwing(T t) {
+		log(Level.ERROR, "Throwing ".concat(t.toString()), t);
+
+		return t;
+	}
+
+	private static LogLevel translateLevel(Level level) {
+		return LEVEL_MAP.getOrDefault(level, LogLevel.INFO);
+	}
+
+	private static Map<Level, LogLevel> createLevelMap() {
+		Map<Level, LogLevel> ret = new EnumMap<>(Level.class);
+
+		ret.put(Level.FATAL, LogLevel.ERROR);
+		ret.put(Level.ERROR, LogLevel.ERROR);
+		ret.put(Level.WARN, LogLevel.WARN);
+		ret.put(Level.INFO, LogLevel.INFO);
+		ret.put(Level.DEBUG, LogLevel.DEBUG);
+		ret.put(Level.TRACE, LogLevel.TRACE);
+
+		return ret;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinServiceKnot.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinServiceKnot.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b500967ff430285072e5e9d790e144568f5b0a2
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinServiceKnot.java
@@ -0,0 +1,230 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import net.fabricmc.loader.impl.util.UrlUtil;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.tree.ClassNode;
+import org.spongepowered.asm.launch.platform.container.ContainerHandleURI;
+import org.spongepowered.asm.launch.platform.container.IContainerHandle;
+import org.spongepowered.asm.logging.ILogger;
+import org.spongepowered.asm.mixin.MixinEnvironment;
+import org.spongepowered.asm.mixin.transformer.IMixinTransformer;
+import org.spongepowered.asm.mixin.transformer.IMixinTransformerFactory;
+import org.spongepowered.asm.service.*;
+import org.spongepowered.asm.util.ReEntranceLock;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.Collection;
+import java.util.Collections;
+
+public class MixinServiceKnot implements IMixinService, IClassProvider, IClassBytecodeProvider, ITransformerProvider, IClassTracker {
+	static IMixinTransformer transformer;
+
+	private final ReEntranceLock lock;
+
+	public MixinServiceKnot() {
+		lock = new ReEntranceLock(1);
+	}
+
+	public byte[] getClassBytes(String name, String transformedName) throws IOException {
+		return FabricLauncherBase.getLauncher().getClassByteArray(name, true);
+	}
+
+	public byte[] getClassBytes(String name, boolean runTransformers) throws ClassNotFoundException, IOException {
+		byte[] classBytes = FabricLauncherBase.getLauncher().getClassByteArray(name, runTransformers);
+
+		if (classBytes != null) {
+			return classBytes;
+		} else {
+			throw new ClassNotFoundException(name);
+		}
+	}
+
+	@Override
+	public ClassNode getClassNode(String name) throws ClassNotFoundException, IOException {
+		return getClassNode(name, true);
+	}
+
+	@Override
+	public ClassNode getClassNode(String name, boolean runTransformers) throws ClassNotFoundException, IOException {
+		ClassReader reader = new ClassReader(getClassBytes(name, runTransformers));
+		ClassNode node = new ClassNode();
+		reader.accept(node, 0);
+		return node;
+	}
+
+	@Override
+	public URL[] getClassPath() {
+		// Mixin 0.7.x only uses getClassPath() to find itself; we implement CodeSource correctly,
+		// so this is unnecessary.
+		return new URL[0];
+	}
+
+	@Override
+	public Class<?> findClass(String name) throws ClassNotFoundException {
+		return FabricLauncherBase.getLauncher().getTargetClassLoader().loadClass(name);
+	}
+
+	@Override
+	public Class<?> findClass(String name, boolean initialize) throws ClassNotFoundException {
+		return Class.forName(name, initialize, FabricLauncherBase.getLauncher().getTargetClassLoader());
+	}
+
+	@Override
+	public Class<?> findAgentClass(String name, boolean initialize) throws ClassNotFoundException {
+		return Class.forName(name, initialize, Knot.class.getClassLoader());
+	}
+
+	@Override
+	public String getName() {
+		return FabricLauncherBase.getLauncher() instanceof Knot ? "Knot/Fabric" : "Launchwrapper/Fabric";
+	}
+
+	@Override
+	public boolean isValid() {
+		return true;
+	}
+
+	@Override
+	public void prepare() { }
+
+	@Override
+	public MixinEnvironment.Phase getInitialPhase() {
+		return MixinEnvironment.Phase.PREINIT;
+	}
+
+	@Override
+	public void offer(IMixinInternal internal) {
+		if (internal instanceof IMixinTransformerFactory) {
+			transformer = ((IMixinTransformerFactory) internal).createTransformer();
+		}
+	}
+
+	@Override
+	public void init() {
+	}
+
+	@Override
+	public void beginPhase() { }
+
+	@Override
+	public void checkEnv(Object bootSource) { }
+
+	@Override
+	public ReEntranceLock getReEntranceLock() {
+		return lock;
+	}
+
+	@Override
+	public IClassProvider getClassProvider() {
+		return this;
+	}
+
+	@Override
+	public IClassBytecodeProvider getBytecodeProvider() {
+		return this;
+	}
+
+	@Override
+	public ITransformerProvider getTransformerProvider() {
+		return this;
+	}
+
+	@Override
+	public IClassTracker getClassTracker() {
+		return this;
+	}
+
+	@Override
+	public IMixinAuditTrail getAuditTrail() {
+		return null;
+	}
+
+	@Override
+	public Collection<String> getPlatformAgents() {
+		return Collections.singletonList("org.spongepowered.asm.launch.platform.MixinPlatformAgentDefault");
+	}
+
+	@Override
+	public IContainerHandle getPrimaryContainer() {
+		return new ContainerHandleURI(UrlUtil.LOADER_CODE_SOURCE.toUri());
+	}
+
+	@Override
+	public Collection<IContainerHandle> getMixinContainers() {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public InputStream getResourceAsStream(String name) {
+		return FabricLauncherBase.getLauncher().getResourceAsStream(name);
+	}
+
+	@Override
+	public void registerInvalidClass(String className) { }
+
+	@Override
+	public boolean isClassLoaded(String className) {
+		return FabricLauncherBase.getLauncher().isClassLoaded(className);
+	}
+
+	@Override
+	public String getClassRestrictions(String className) {
+		return "";
+	}
+
+	@Override
+	public Collection<ITransformer> getTransformers() {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public Collection<ITransformer> getDelegatedTransformers() {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public void addTransformerExclusion(String name) { }
+
+	@Override
+	public String getSideName() {
+		return FabricLauncherBase.getLauncher().getEnvironmentType().name();
+	}
+
+	@Override
+	public MixinEnvironment.CompatibilityLevel getMinCompatibilityLevel() {
+		return MixinEnvironment.CompatibilityLevel.JAVA_8;
+	}
+
+	@Override
+	public MixinEnvironment.CompatibilityLevel getMaxCompatibilityLevel() {
+		return MixinEnvironment.CompatibilityLevel.JAVA_17;
+	}
+
+	@Override
+	public ILogger getLogger(String name) {
+		return MixinLogger.get(name);
+	}
+
+	static IMixinTransformer getTransformer() {
+		return transformer;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinServiceKnotBootstrap.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinServiceKnotBootstrap.java
new file mode 100644
index 0000000000000000000000000000000000000000..2024e157e956c4fc5357f310e66e53ee4a32b084
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinServiceKnotBootstrap.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import org.spongepowered.asm.service.IMixinServiceBootstrap;
+
+public class MixinServiceKnotBootstrap implements IMixinServiceBootstrap {
+	@Override
+	public String getName() {
+		return "Knot";
+	}
+
+	@Override
+	public String getServiceClassName() {
+		return "net.fabricmc.loader.impl.launch.knot.MixinServiceKnot";
+	}
+
+	@Override
+	public void bootstrap() {
+		// already done in Knot
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinStringPropertyKey.java b/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinStringPropertyKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..a61ac16e60159af4114d52880741261c21c2aee9
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/knot/MixinStringPropertyKey.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.knot;
+
+import org.spongepowered.asm.service.IPropertyKey;
+
+import java.util.Objects;
+
+public class MixinStringPropertyKey implements IPropertyKey {
+	public final String key;
+
+	public MixinStringPropertyKey(String key) {
+		this.key = key;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (!(obj instanceof MixinStringPropertyKey)) {
+			return false;
+		} else {
+			return Objects.equals(this.key, ((MixinStringPropertyKey) obj).key);
+		}
+	}
+
+	@Override
+	public int hashCode() {
+		return this.key.hashCode();
+	}
+
+	@Override
+	public String toString() {
+		return this.key;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/launch/server/FabricServerLauncher.java b/src/main/java/net/fabricmc/loader/impl/launch/server/FabricServerLauncher.java
new file mode 100644
index 0000000000000000000000000000000000000000..5e6c5f14a4bebcfb15d0ba95949d34ebaf93df6a
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/launch/server/FabricServerLauncher.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.launch.server;
+
+import net.fabricmc.loader.impl.launch.knot.KnotServer;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.io.Writer;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.net.URL;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Properties;
+
+public class FabricServerLauncher {
+	private static final ClassLoader parentLoader = FabricServerLauncher.class.getClassLoader();
+	private static String mainClass = KnotServer.class.getName();
+
+	public static void main(String[] args) {
+		URL propUrl = parentLoader.getResource("fabric-server-launch.properties");
+
+		if (propUrl != null) {
+			Properties properties = new Properties();
+
+			try (InputStreamReader reader = new InputStreamReader(propUrl.openStream(), StandardCharsets.UTF_8)) {
+				properties.load(reader);
+			} catch (IOException e) {
+				e.printStackTrace();
+			}
+
+			if (properties.containsKey("launch.mainClass")) {
+				mainClass = properties.getProperty("launch.mainClass");
+			}
+		}
+
+		boolean dev = Boolean.parseBoolean(System.getProperty(SystemProperties.DEVELOPMENT, "false"));
+
+		if (!dev) {
+			try {
+				setup(args);
+			} catch (Exception e) {
+				throw new RuntimeException("Failed to setup Fabric server environment!", e);
+			}
+		}
+
+		try {
+			Class<?> c = Class.forName(mainClass);
+			MethodHandles.lookup().findStatic(c, "main", MethodType.methodType(void.class, String[].class)).invokeExact(args);
+		} catch (Throwable e) {
+			throw new RuntimeException("An exception occurred when launching the server!", e);
+		}
+	}
+
+	private static void setup(String... runArguments) throws IOException {
+		if (System.getProperty(SystemProperties.GAME_JAR_PATH) == null) {
+			System.setProperty(SystemProperties.GAME_JAR_PATH, getServerJarPath());
+		}
+
+		Path serverJar = LoaderUtil.normalizePath(Paths.get(System.getProperty(SystemProperties.GAME_JAR_PATH)));
+
+		if (!Files.exists(serverJar)) {
+			System.err.println("The Minecraft server .JAR is missing (" + serverJar + ")!");
+			System.err.println();
+			System.err.println("Fabric's server-side launcher expects the server .JAR to be provided.");
+			System.err.println("You can edit its location in fabric-server-launcher.properties.");
+			System.err.println();
+			System.err.println("Without the official Minecraft server .JAR, Fabric Loader cannot launch.");
+			throw new RuntimeException("Missing game jar at " + serverJar);
+		}
+	}
+
+	private static String getServerJarPath() throws IOException {
+		// Pre-load "fabric-server-launcher.properties"
+		Path propertiesFile = Paths.get("fabric-server-launcher.properties");
+		Properties properties = new Properties();
+
+		if (Files.exists(propertiesFile)) {
+			try (Reader reader = Files.newBufferedReader(propertiesFile)) {
+				properties.load(reader);
+			}
+		}
+
+		// Most popular Minecraft server hosting platforms do not allow
+		// passing arbitrary arguments to the server .JAR. Meanwhile,
+		// Mojang's default server filename is "server.jar" as of
+		// a few versions... let's use this.
+		if (!properties.containsKey("serverJar")) {
+			properties.put("serverJar", "server.jar");
+
+			try (Writer writer = Files.newBufferedWriter(propertiesFile)) {
+				properties.store(writer, null);
+			}
+		}
+
+		return (String) properties.get("serverJar");
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/lib/gson/JsonReader.java b/src/main/java/net/fabricmc/loader/impl/lib/gson/JsonReader.java
new file mode 100644
index 0000000000000000000000000000000000000000..47f4748a139443f5f921a54f6710ad5f853a2c21
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/lib/gson/JsonReader.java
@@ -0,0 +1,1623 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ * Copyright (c) 2020 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * This file has been modified by the Fabric project (repackage, minor changes).
+ */
+
+package net.fabricmc.loader.impl.lib.gson;
+
+import java.io.Closeable;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.Reader;
+import java.util.Arrays;
+
+/**
+ * Reads a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
+ * encoded value as a stream of tokens. This stream includes both literal
+ * values (strings, numbers, booleans, and nulls) as well as the begin and
+ * end delimiters of objects and arrays. The tokens are traversed in
+ * depth-first order, the same order that they appear in the JSON document.
+ * Within JSON objects, name/value pairs are represented by a single token.
+ *
+ * <h3>Parsing JSON</h3>
+ * To create a recursive descent parser for your own JSON streams, first create
+ * an entry point method that creates a {@code JsonReader}.
+ *
+ * <p>Next, create handler methods for each structure in your JSON text. You'll
+ * need a method for each object type and for each array type.
+ * <ul>
+ *   <li>Within <strong>array handling</strong> methods, first call {@link
+ *       #beginArray} to consume the array's opening bracket. Then create a
+ *       while loop that accumulates values, terminating when {@link #hasNext}
+ *       is false. Finally, read the array's closing bracket by calling {@link
+ *       #endArray}.
+ *   <li>Within <strong>object handling</strong> methods, first call {@link
+ *       #beginObject} to consume the object's opening brace. Then create a
+ *       while loop that assigns values to local variables based on their name.
+ *       This loop should terminate when {@link #hasNext} is false. Finally,
+ *       read the object's closing brace by calling {@link #endObject}.
+ * </ul>
+ * <p>When a nested object or array is encountered, delegate to the
+ * corresponding handler method.
+ *
+ * <p>When an unknown name is encountered, strict parsers should fail with an
+ * exception. Lenient parsers should call {@link #skipValue()} to recursively
+ * skip the value's nested tokens, which may otherwise conflict.
+ *
+ * <p>If a value may be null, you should first check using {@link #peek()}.
+ * Null literals can be consumed using either {@link #nextNull()} or {@link
+ * #skipValue()}.
+ *
+ * <h3>Example</h3>
+ * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code
+ * [
+ *   {
+ *     "id": 912345678901,
+ *     "text": "How do I read a JSON stream in Java?",
+ *     "geo": null,
+ *     "user": {
+ *       "name": "json_newb",
+ *       "followers_count": 41
+ *      }
+ *   },
+ *   {
+ *     "id": 912345678902,
+ *     "text": "@json_newb just use JsonReader!",
+ *     "geo": [50.454722, -104.606667],
+ *     "user": {
+ *       "name": "jesse",
+ *       "followers_count": 2
+ *     }
+ *   }
+ * ]}</pre>
+ * This code implements the parser for the above structure: <pre>   {@code
+ *
+ *   public List<Message> readJsonStream(InputStream in) throws IOException {
+ *     JsonReader reader = new JsonReader(new InputStreamReader(in, "UTF-8"));
+ *     try {
+ *       return readMessagesArray(reader);
+ *     } finally {
+ *       reader.close();
+ *     }
+ *   }
+ *
+ *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {
+ *     List<Message> messages = new ArrayList<Message>();
+ *
+ *     reader.beginArray();
+ *     while (reader.hasNext()) {
+ *       messages.add(readMessage(reader));
+ *     }
+ *     reader.endArray();
+ *     return messages;
+ *   }
+ *
+ *   public Message readMessage(JsonReader reader) throws IOException {
+ *     long id = -1;
+ *     String text = null;
+ *     User user = null;
+ *     List<Double> geo = null;
+ *
+ *     reader.beginObject();
+ *     while (reader.hasNext()) {
+ *       String name = reader.nextName();
+ *       if (name.equals("id")) {
+ *         id = reader.nextLong();
+ *       } else if (name.equals("text")) {
+ *         text = reader.nextString();
+ *       } else if (name.equals("geo") && reader.peek() != JsonToken.NULL) {
+ *         geo = readDoublesArray(reader);
+ *       } else if (name.equals("user")) {
+ *         user = readUser(reader);
+ *       } else {
+ *         reader.skipValue();
+ *       }
+ *     }
+ *     reader.endObject();
+ *     return new Message(id, text, user, geo);
+ *   }
+ *
+ *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {
+ *     List<Double> doubles = new ArrayList<Double>();
+ *
+ *     reader.beginArray();
+ *     while (reader.hasNext()) {
+ *       doubles.add(reader.nextDouble());
+ *     }
+ *     reader.endArray();
+ *     return doubles;
+ *   }
+ *
+ *   public User readUser(JsonReader reader) throws IOException {
+ *     String username = null;
+ *     int followersCount = -1;
+ *
+ *     reader.beginObject();
+ *     while (reader.hasNext()) {
+ *       String name = reader.nextName();
+ *       if (name.equals("name")) {
+ *         username = reader.nextString();
+ *       } else if (name.equals("followers_count")) {
+ *         followersCount = reader.nextInt();
+ *       } else {
+ *         reader.skipValue();
+ *       }
+ *     }
+ *     reader.endObject();
+ *     return new User(username, followersCount);
+ *   }}</pre>
+ *
+ * <h3>Number Handling</h3>
+ * This reader permits numeric values to be read as strings and string values to
+ * be read as numbers. For example, both elements of the JSON array {@code
+ * [1, "1"]} may be read using either {@link #nextInt} or {@link #nextString}.
+ * This behavior is intended to prevent lossy numeric conversions: double is
+ * JavaScript's only numeric type and very large values like {@code
+ * 9007199254740993} cannot be represented exactly on that platform. To minimize
+ * precision loss, extremely large values should be written and read as strings
+ * in JSON.
+ *
+ * <a id="nonexecuteprefix"/><h3>Non-Execute Prefix</h3>
+ * Web servers that serve private data using JSON may be vulnerable to <a
+ * href="http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery">Cross-site
+ * request forgery</a> attacks. In such an attack, a malicious site gains access
+ * to a private JSON file by executing it with an HTML {@code <script>} tag.
+ *
+ * <p>Prefixing JSON files with <code>")]}'\n"</code> makes them non-executable
+ * by {@code <script>} tags, disarming the attack. Since the prefix is malformed
+ * JSON, strict parsing fails when it is encountered. This class permits the
+ * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is
+ * enabled.
+ *
+ * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances
+ * of this class are not thread safe.
+ *
+ * @author Jesse Wilson
+ * @since 1.6
+ */
+public class JsonReader implements Closeable {
+	private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;
+
+	private static final int PEEKED_NONE = 0;
+	private static final int PEEKED_BEGIN_OBJECT = 1;
+	private static final int PEEKED_END_OBJECT = 2;
+	private static final int PEEKED_BEGIN_ARRAY = 3;
+	private static final int PEEKED_END_ARRAY = 4;
+	private static final int PEEKED_TRUE = 5;
+	private static final int PEEKED_FALSE = 6;
+	private static final int PEEKED_NULL = 7;
+	private static final int PEEKED_SINGLE_QUOTED = 8;
+	private static final int PEEKED_DOUBLE_QUOTED = 9;
+	private static final int PEEKED_UNQUOTED = 10;
+	/** When this is returned, the string value is stored in peekedString. */
+	private static final int PEEKED_BUFFERED = 11;
+	private static final int PEEKED_SINGLE_QUOTED_NAME = 12;
+	private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;
+	private static final int PEEKED_UNQUOTED_NAME = 14;
+	/** When this is returned, the integer value is stored in peekedLong. */
+	private static final int PEEKED_LONG = 15;
+	private static final int PEEKED_NUMBER = 16;
+	private static final int PEEKED_EOF = 17;
+
+	/* State machine when parsing numbers */
+	private static final int NUMBER_CHAR_NONE = 0;
+	private static final int NUMBER_CHAR_SIGN = 1;
+	private static final int NUMBER_CHAR_DIGIT = 2;
+	private static final int NUMBER_CHAR_DECIMAL = 3;
+	private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;
+	private static final int NUMBER_CHAR_EXP_E = 5;
+	private static final int NUMBER_CHAR_EXP_SIGN = 6;
+	private static final int NUMBER_CHAR_EXP_DIGIT = 7;
+
+	/** The input JSON. */
+	private final Reader in;
+
+	/** True to accept non-spec compliant JSON */
+	private boolean lenient = false;
+
+	/**
+	 * Use a manual buffer to easily read and unread upcoming characters, and
+	 * also so we can create strings without an intermediate StringBuilder.
+	 * We decode literals directly out of this buffer, so it must be at least as
+	 * long as the longest token that can be reported as a number.
+	 */
+	private char[] buffer = new char[8192]; // Fabric - increase buffer size, remove final for resizing
+	private int pos = 0;
+	private int limit = 0;
+
+	private int lineNumber = 0;
+	private int lineStart = 0;
+
+	int peeked = PEEKED_NONE;
+
+	/**
+	 * A peeked value that was composed entirely of digits with an optional
+	 * leading dash. Positive values may not have a leading 0.
+	 */
+	private long peekedLong;
+
+	/**
+	 * The number of characters in a peeked number literal. Increment 'pos' by
+	 * this after reading a number.
+	 */
+	private int peekedNumberLength;
+
+	/**
+	 * A peeked string that should be parsed on the next double, long or string.
+	 * This is populated before a numeric value is parsed and used if that parsing
+	 * fails.
+	 */
+	private String peekedString;
+
+	/*
+	 * The nesting stack. Using a manual array rather than an ArrayList saves 20%.
+	 */
+	private int[] stack = new int[32];
+	private int stackSize = 0;
+	{
+		stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
+	}
+
+	/*
+	 * The path members. It corresponds directly to stack: At indices where the
+	 * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
+	 * pathNames contains the name at this scope. Where it contains an array
+	 * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
+	 * that array. Otherwise the value is undefined, and we take advantage of that
+	 * by incrementing pathIndices when doing so isn't useful.
+	 */
+	private String[] pathNames = new String[32];
+	private int[] pathIndices = new int[32];
+
+	/**
+	 * Creates a new instance that reads a JSON-encoded stream from {@code in}.
+	 */
+	public JsonReader(Reader in) {
+		if (in == null) {
+			throw new NullPointerException("in == null");
+		}
+		this.in = in;
+	}
+
+	/**
+	 * Configure this parser to be liberal in what it accepts. By default,
+	 * this parser is strict and only accepts JSON as specified by <a
+	 * href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>. Setting the
+	 * parser to lenient causes it to ignore the following syntax errors:
+	 *
+	 * <ul>
+	 *   <li>Streams that start with the <a href="#nonexecuteprefix">non-execute
+	 *       prefix</a>, <code>")]}'\n"</code>.
+	 *   <li>Streams that include multiple top-level values. With strict parsing,
+	 *       each stream must contain exactly one top-level value.
+	 *   <li>Top-level values of any type. With strict parsing, the top-level
+	 *       value must be an object or an array.
+	 *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link
+	 *       Double#isInfinite() infinities}.
+	 *   <li>End of line comments starting with {@code //} or {@code #} and
+	 *       ending with a newline character.
+	 *   <li>C-style comments starting with {@code /*} and ending with
+	 *       {@code *}{@code /}. Such comments may not be nested.
+	 *   <li>Names that are unquoted or {@code 'single quoted'}.
+	 *   <li>Strings that are unquoted or {@code 'single quoted'}.
+	 *   <li>Array elements separated by {@code ;} instead of {@code ,}.
+	 *   <li>Unnecessary array separators. These are interpreted as if null
+	 *       was the omitted value.
+	 *   <li>Names and values separated by {@code =} or {@code =>} instead of
+	 *       {@code :}.
+	 *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.
+	 * </ul>
+	 */
+	public final void setLenient(boolean lenient) {
+		this.lenient = lenient;
+	}
+
+	/**
+	 * Returns true if this parser is liberal in what it accepts.
+	 */
+	public final boolean isLenient() {
+		return lenient;
+	}
+
+	/**
+	 * Consumes the next token from the JSON stream and asserts that it is the
+	 * beginning of a new array.
+	 */
+	public void beginArray() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_BEGIN_ARRAY) {
+			push(JsonScope.EMPTY_ARRAY);
+			pathIndices[stackSize - 1] = 0;
+			peeked = PEEKED_NONE;
+		} else {
+			throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek() + locationString());
+		}
+	}
+
+	/**
+	 * Consumes the next token from the JSON stream and asserts that it is the
+	 * end of the current array.
+	 */
+	public void endArray() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_END_ARRAY) {
+			stackSize--;
+			pathIndices[stackSize - 1]++;
+			peeked = PEEKED_NONE;
+		} else {
+			throw new IllegalStateException("Expected END_ARRAY but was " + peek() + locationString());
+		}
+	}
+
+	/**
+	 * Consumes the next token from the JSON stream and asserts that it is the
+	 * beginning of a new object.
+	 */
+	public void beginObject() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_BEGIN_OBJECT) {
+			push(JsonScope.EMPTY_OBJECT);
+			peeked = PEEKED_NONE;
+		} else {
+			throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek() + locationString());
+		}
+	}
+
+	/**
+	 * Consumes the next token from the JSON stream and asserts that it is the
+	 * end of the current object.
+	 */
+	public void endObject() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_END_OBJECT) {
+			stackSize--;
+			pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
+			pathIndices[stackSize - 1]++;
+			peeked = PEEKED_NONE;
+		} else {
+			throw new IllegalStateException("Expected END_OBJECT but was " + peek() + locationString());
+		}
+	}
+
+	/**
+	 * Returns true if the current array or object has another element.
+	 */
+	public boolean hasNext() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
+	}
+
+	/**
+	 * Returns the type of the next token without consuming it.
+	 */
+	public JsonToken peek() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+
+		switch (p) {
+		case PEEKED_BEGIN_OBJECT:
+			return JsonToken.BEGIN_OBJECT;
+		case PEEKED_END_OBJECT:
+			return JsonToken.END_OBJECT;
+		case PEEKED_BEGIN_ARRAY:
+			return JsonToken.BEGIN_ARRAY;
+		case PEEKED_END_ARRAY:
+			return JsonToken.END_ARRAY;
+		case PEEKED_SINGLE_QUOTED_NAME:
+		case PEEKED_DOUBLE_QUOTED_NAME:
+		case PEEKED_UNQUOTED_NAME:
+			return JsonToken.NAME;
+		case PEEKED_TRUE:
+		case PEEKED_FALSE:
+			return JsonToken.BOOLEAN;
+		case PEEKED_NULL:
+			return JsonToken.NULL;
+		case PEEKED_SINGLE_QUOTED:
+		case PEEKED_DOUBLE_QUOTED:
+		case PEEKED_UNQUOTED:
+		case PEEKED_BUFFERED:
+			return JsonToken.STRING;
+		case PEEKED_LONG:
+		case PEEKED_NUMBER:
+			return JsonToken.NUMBER;
+		case PEEKED_EOF:
+			return JsonToken.END_DOCUMENT;
+		default:
+			throw new AssertionError();
+		}
+	}
+
+	int doPeek() throws IOException {
+		int peekStack = stack[stackSize - 1];
+		if (peekStack == JsonScope.EMPTY_ARRAY) {
+			stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
+		} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
+			// Look for a comma before the next element.
+			int c = nextNonWhitespace(true);
+			switch (c) {
+			case ']':
+				return peeked = PEEKED_END_ARRAY;
+			case ';':
+				checkLenient(); // fall-through
+			case ',':
+				break;
+			default:
+				throw syntaxError("Unterminated array");
+			}
+		} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
+			stack[stackSize - 1] = JsonScope.DANGLING_NAME;
+			// Look for a comma before the next element.
+			if (peekStack == JsonScope.NONEMPTY_OBJECT) {
+				int c = nextNonWhitespace(true);
+				switch (c) {
+				case '}':
+					return peeked = PEEKED_END_OBJECT;
+				case ';':
+					checkLenient(); // fall-through
+				case ',':
+					break;
+				default:
+					throw syntaxError("Unterminated object");
+				}
+			}
+			int c = nextNonWhitespace(true);
+			switch (c) {
+			case '"':
+				return peeked = PEEKED_DOUBLE_QUOTED_NAME;
+			case '\'':
+				checkLenient();
+				return peeked = PEEKED_SINGLE_QUOTED_NAME;
+			case '}':
+				if (peekStack != JsonScope.NONEMPTY_OBJECT) {
+					return peeked = PEEKED_END_OBJECT;
+				} else {
+					throw syntaxError("Expected name");
+				}
+			default:
+				checkLenient();
+				pos--; // Don't consume the first character in an unquoted string.
+				if (isLiteral((char) c)) {
+					return peeked = PEEKED_UNQUOTED_NAME;
+				} else {
+					throw syntaxError("Expected name");
+				}
+			}
+		} else if (peekStack == JsonScope.DANGLING_NAME) {
+			stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
+			// Look for a colon before the value.
+			int c = nextNonWhitespace(true);
+			switch (c) {
+			case ':':
+				break;
+			case '=':
+				checkLenient();
+				if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {
+					pos++;
+				}
+				break;
+			default:
+				throw syntaxError("Expected ':'");
+			}
+		} else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
+			if (lenient) {
+				consumeNonExecutePrefix();
+			}
+			stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
+		} else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
+			int c = nextNonWhitespace(false);
+			if (c == -1) {
+				return peeked = PEEKED_EOF;
+			} else {
+				checkLenient();
+				pos--;
+			}
+		} else if (peekStack == JsonScope.CLOSED) {
+			throw new IllegalStateException("JsonReader is closed");
+		}
+
+		int c = nextNonWhitespace(true);
+		switch (c) {
+		case ']':
+			if (peekStack == JsonScope.EMPTY_ARRAY) {
+				return peeked = PEEKED_END_ARRAY;
+			}
+			// fall-through to handle ",]"
+		case ';':
+		case ',':
+			// In lenient mode, a 0-length literal in an array means 'null'.
+			if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
+				checkLenient();
+				pos--;
+				return peeked = PEEKED_NULL;
+			} else {
+				throw syntaxError("Unexpected value");
+			}
+		case '\'':
+			checkLenient();
+			return peeked = PEEKED_SINGLE_QUOTED;
+		case '"':
+			return peeked = PEEKED_DOUBLE_QUOTED;
+		case '[':
+			return peeked = PEEKED_BEGIN_ARRAY;
+		case '{':
+			return peeked = PEEKED_BEGIN_OBJECT;
+		default:
+			pos--; // Don't consume the first character in a literal value.
+		}
+
+		int result = peekKeyword();
+		if (result != PEEKED_NONE) {
+			return result;
+		}
+
+		result = peekNumber();
+		if (result != PEEKED_NONE) {
+			return result;
+		}
+
+		if (!isLiteral(buffer[pos])) {
+			throw syntaxError("Expected value");
+		}
+
+		checkLenient();
+		return peeked = PEEKED_UNQUOTED;
+	}
+
+	private int peekKeyword() throws IOException {
+		// Figure out which keyword we're matching against by its first character.
+		char c = buffer[pos];
+		String keyword;
+		String keywordUpper;
+		int peeking;
+		if (c == 't' || c == 'T') {
+			keyword = "true";
+			keywordUpper = "TRUE";
+			peeking = PEEKED_TRUE;
+		} else if (c == 'f' || c == 'F') {
+			keyword = "false";
+			keywordUpper = "FALSE";
+			peeking = PEEKED_FALSE;
+		} else if (c == 'n' || c == 'N') {
+			keyword = "null";
+			keywordUpper = "NULL";
+			peeking = PEEKED_NULL;
+		} else {
+			return PEEKED_NONE;
+		}
+
+		// Confirm that chars [1..length) match the keyword.
+		int length = keyword.length();
+		for (int i = 1; i < length; i++) {
+			if (pos + i >= limit && !fillBuffer(i + 1)) {
+				return PEEKED_NONE;
+			}
+			c = buffer[pos + i];
+			if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {
+				return PEEKED_NONE;
+			}
+		}
+
+		if ((pos + length < limit || fillBuffer(length + 1))
+				&& isLiteral(buffer[pos + length])) {
+			return PEEKED_NONE; // Don't match trues, falsey or nullsoft!
+		}
+
+		// We've found the keyword followed either by EOF or by a non-literal character.
+		pos += length;
+		return peeked = peeking;
+	}
+
+	private int peekNumber() throws IOException {
+		// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
+		char[] buffer = this.buffer;
+		int p = pos;
+		int l = limit;
+
+		long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.
+		boolean negative = false;
+		boolean fitsInLong = true;
+		int last = NUMBER_CHAR_NONE;
+
+		int i = 0;
+
+		charactersOfNumber:
+		for (; true; i++) {
+			if (p + i == l) {
+				if (i == buffer.length) {
+					// Though this looks like a well-formed number, it's too long to continue reading. Give up
+					// and let the application handle this as an unquoted literal.
+					return PEEKED_NONE;
+				}
+				if (!fillBuffer(i + 1)) {
+					break;
+				}
+				p = pos;
+				l = limit;
+			}
+
+			char c = buffer[p + i];
+			switch (c) {
+			case '-':
+				if (last == NUMBER_CHAR_NONE) {
+					negative = true;
+					last = NUMBER_CHAR_SIGN;
+					continue;
+				} else if (last == NUMBER_CHAR_EXP_E) {
+					last = NUMBER_CHAR_EXP_SIGN;
+					continue;
+				}
+				return PEEKED_NONE;
+
+			case '+':
+				if (last == NUMBER_CHAR_EXP_E) {
+					last = NUMBER_CHAR_EXP_SIGN;
+					continue;
+				}
+				return PEEKED_NONE;
+
+			case 'e':
+			case 'E':
+				if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {
+					last = NUMBER_CHAR_EXP_E;
+					continue;
+				}
+				return PEEKED_NONE;
+
+			case '.':
+				if (last == NUMBER_CHAR_DIGIT) {
+					last = NUMBER_CHAR_DECIMAL;
+					continue;
+				}
+				return PEEKED_NONE;
+
+			default:
+				if (c < '0' || c > '9') {
+					if (!isLiteral(c)) {
+						break charactersOfNumber;
+					}
+					return PEEKED_NONE;
+				}
+				if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {
+					value = -(c - '0');
+					last = NUMBER_CHAR_DIGIT;
+				} else if (last == NUMBER_CHAR_DIGIT) {
+					if (value == 0) {
+						return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).
+					}
+					long newValue = value * 10 - (c - '0');
+					fitsInLong &= value > MIN_INCOMPLETE_INTEGER
+							|| (value == MIN_INCOMPLETE_INTEGER && newValue < value);
+					value = newValue;
+				} else if (last == NUMBER_CHAR_DECIMAL) {
+					last = NUMBER_CHAR_FRACTION_DIGIT;
+				} else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {
+					last = NUMBER_CHAR_EXP_DIGIT;
+				}
+			}
+		}
+
+		// We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
+		if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {
+			peekedLong = negative ? value : -value;
+			pos += i;
+			return peeked = PEEKED_LONG;
+		} else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT
+				|| last == NUMBER_CHAR_EXP_DIGIT) {
+			peekedNumberLength = i;
+			return peeked = PEEKED_NUMBER;
+		} else {
+			return PEEKED_NONE;
+		}
+	}
+
+	private boolean isLiteral(char c) throws IOException {
+		switch (c) {
+		case '/':
+		case '\\':
+		case ';':
+		case '#':
+		case '=':
+			checkLenient(); // fall-through
+		case '{':
+		case '}':
+		case '[':
+		case ']':
+		case ':':
+		case ',':
+		case ' ':
+		case '\t':
+		case '\f':
+		case '\r':
+		case '\n':
+			return false;
+		default:
+			return true;
+		}
+	}
+
+	/**
+	 * Returns the next token, a {@link JsonToken#NAME property name}, and
+	 * consumes it.
+	 *
+	 * @throws IOException if the next token in the stream is not a property
+	 *     name.
+	 */
+	public String nextName() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		String result;
+		if (p == PEEKED_UNQUOTED_NAME) {
+			result = nextUnquotedValue();
+		} else if (p == PEEKED_SINGLE_QUOTED_NAME) {
+			result = nextQuotedValue('\'');
+		} else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
+			result = nextQuotedValue('"');
+		} else {
+			throw new IllegalStateException("Expected a name but was " + peek() + locationString());
+		}
+		peeked = PEEKED_NONE;
+		pathNames[stackSize - 1] = result;
+		return result;
+	}
+
+	/**
+	 * Returns the {@link JsonToken#STRING string} value of the next token,
+	 * consuming it. If the next token is a number, this method will return its
+	 * string form.
+	 *
+	 * @throws IllegalStateException if the next token is not a string or if
+	 *     this reader is closed.
+	 */
+	public String nextString() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		String result;
+		if (p == PEEKED_UNQUOTED) {
+			result = nextUnquotedValue();
+		} else if (p == PEEKED_SINGLE_QUOTED) {
+			result = nextQuotedValue('\'');
+		} else if (p == PEEKED_DOUBLE_QUOTED) {
+			result = nextQuotedValue('"');
+		} else if (p == PEEKED_BUFFERED) {
+			result = peekedString;
+			peekedString = null;
+		} else if (p == PEEKED_LONG) {
+			result = Long.toString(peekedLong);
+		} else if (p == PEEKED_NUMBER) {
+			result = new String(buffer, pos, peekedNumberLength);
+			pos += peekedNumberLength;
+		} else {
+			throw new IllegalStateException("Expected a string but was " + peek() + locationString());
+		}
+		peeked = PEEKED_NONE;
+		pathIndices[stackSize - 1]++;
+		return result;
+	}
+
+	/**
+	 * Returns the {@link JsonToken#BOOLEAN boolean} value of the next token,
+	 * consuming it.
+	 *
+	 * @throws IllegalStateException if the next token is not a boolean or if
+	 *     this reader is closed.
+	 */
+	public boolean nextBoolean() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_TRUE) {
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+			return true;
+		} else if (p == PEEKED_FALSE) {
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+			return false;
+		}
+		throw new IllegalStateException("Expected a boolean but was " + peek() + locationString());
+	}
+
+	/**
+	 * Consumes the next token from the JSON stream and asserts that it is a
+	 * literal null.
+	 *
+	 * @throws IllegalStateException if the next token is not null or if this
+	 *     reader is closed.
+	 */
+	public void nextNull() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+		if (p == PEEKED_NULL) {
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+		} else {
+			throw new IllegalStateException("Expected null but was " + peek() + locationString());
+		}
+	}
+
+	/**
+	 * Returns the {@link JsonToken#NUMBER double} value of the next token,
+	 * consuming it. If the next token is a string, this method will attempt to
+	 * parse it as a double using {@link Double#parseDouble(String)}.
+	 *
+	 * @throws IllegalStateException if the next token is not a literal value.
+	 * @throws NumberFormatException if the next literal value cannot be parsed
+	 *     as a double, or is non-finite.
+	 */
+	public double nextDouble() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+
+		if (p == PEEKED_LONG) {
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+			return (double) peekedLong;
+		}
+
+		if (p == PEEKED_NUMBER) {
+			peekedString = new String(buffer, pos, peekedNumberLength);
+			pos += peekedNumberLength;
+		} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {
+			peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+		} else if (p == PEEKED_UNQUOTED) {
+			peekedString = nextUnquotedValue();
+		} else if (p != PEEKED_BUFFERED) {
+			throw new IllegalStateException("Expected a double but was " + peek() + locationString());
+		}
+
+		peeked = PEEKED_BUFFERED;
+		double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+		if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
+			throw new MalformedJsonException(
+					"JSON forbids NaN and infinities: " + result + locationString());
+		}
+		peekedString = null;
+		peeked = PEEKED_NONE;
+		pathIndices[stackSize - 1]++;
+		return result;
+	}
+
+	/**
+	 * Returns the {@link JsonToken#NUMBER long} value of the next token,
+	 * consuming it. If the next token is a string, this method will attempt to
+	 * parse it as a long. If the next token's numeric value cannot be exactly
+	 * represented by a Java {@code long}, this method throws.
+	 *
+	 * @throws IllegalStateException if the next token is not a literal value.
+	 * @throws NumberFormatException if the next literal value cannot be parsed
+	 *     as a number, or exactly represented as a long.
+	 */
+	public long nextLong() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+
+		if (p == PEEKED_LONG) {
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+			return peekedLong;
+		}
+
+		if (p == PEEKED_NUMBER) {
+			peekedString = new String(buffer, pos, peekedNumberLength);
+			pos += peekedNumberLength;
+		} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
+			if (p == PEEKED_UNQUOTED) {
+				peekedString = nextUnquotedValue();
+			} else {
+				peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+			}
+			try {
+				long result = Long.parseLong(peekedString);
+				peeked = PEEKED_NONE;
+				pathIndices[stackSize - 1]++;
+				return result;
+			} catch (NumberFormatException ignored) {
+				// Fall back to parse as a double below.
+			}
+		} else {
+			throw new IllegalStateException("Expected a long but was " + peek() + locationString());
+		}
+
+		peeked = PEEKED_BUFFERED;
+		double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+		long result = (long) asDouble;
+		if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
+			throw new NumberFormatException("Expected a long but was " + peekedString + locationString());
+		}
+		peekedString = null;
+		peeked = PEEKED_NONE;
+		pathIndices[stackSize - 1]++;
+		return result;
+	}
+
+	/**
+	 * Returns the string up to but not including {@code quote}, unescaping any
+	 * character escape sequences encountered along the way. The opening quote
+	 * should have already been read. This consumes the closing quote, but does
+	 * not include it in the returned string.
+	 *
+	 * @param quote either ' or ".
+	 * @throws NumberFormatException if any unicode escape sequences are
+	 *     malformed.
+	 */
+	private String nextQuotedValue(char quote) throws IOException {
+		// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
+		char[] buffer = this.buffer;
+		StringBuilder builder = null;
+		while (true) {
+			int p = pos;
+			int l = limit;
+			/* the index of the first character not yet appended to the builder. */
+			int start = p;
+			while (p < l) {
+				int c = buffer[p++];
+
+				if (c == quote) {
+					pos = p;
+					int len = p - start - 1;
+					if (builder == null) {
+						return new String(buffer, start, len);
+					} else {
+						builder.append(buffer, start, len);
+						return builder.toString();
+					}
+				} else if (c == '\\') {
+					pos = p;
+					int len = p - start - 1;
+					if (builder == null) {
+						int estimatedLength = (len + 1) * 2;
+						builder = new StringBuilder(Math.max(estimatedLength, 16));
+					}
+					builder.append(buffer, start, len);
+					builder.append(readEscapeCharacter());
+					p = pos;
+					l = limit;
+					start = p;
+				} else if (c == '\n') {
+					lineNumber++;
+					lineStart = p;
+				}
+			}
+
+			if (builder == null) {
+				int estimatedLength = (p - start) * 2;
+				builder = new StringBuilder(Math.max(estimatedLength, 16));
+			}
+			builder.append(buffer, start, p - start);
+			pos = p;
+			if (!fillBuffer(1)) {
+				throw syntaxError("Unterminated string");
+			}
+		}
+	}
+
+	/**
+	 * Returns an unquoted value as a string.
+	 */
+	@SuppressWarnings("fallthrough")
+	private String nextUnquotedValue() throws IOException {
+		StringBuilder builder = null;
+		int i = 0;
+
+		findNonLiteralCharacter:
+		while (true) {
+			for (; pos + i < limit; i++) {
+				switch (buffer[pos + i]) {
+				case '/':
+				case '\\':
+				case ';':
+				case '#':
+				case '=':
+					checkLenient(); // fall-through
+				case '{':
+				case '}':
+				case '[':
+				case ']':
+				case ':':
+				case ',':
+				case ' ':
+				case '\t':
+				case '\f':
+				case '\r':
+				case '\n':
+					break findNonLiteralCharacter;
+				}
+			}
+
+			// Attempt to load the entire literal into the buffer at once.
+			if (i < buffer.length) {
+				if (fillBuffer(i + 1)) {
+					continue;
+				} else {
+					break;
+				}
+			}
+
+			// use a StringBuilder when the value is too long. This is too long to be a number!
+			if (builder == null) {
+				builder = new StringBuilder(Math.max(i,16));
+			}
+			builder.append(buffer, pos, i);
+			pos += i;
+			i = 0;
+			if (!fillBuffer(1)) {
+				break;
+			}
+		}
+
+		String result = (null == builder) ? new String(buffer, pos, i) : builder.append(buffer, pos, i).toString();
+		pos += i;
+		return result;
+	}
+
+	private void skipQuotedValue(char quote) throws IOException {
+		// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.
+		char[] buffer = this.buffer;
+		do {
+			int p = pos;
+			int l = limit;
+			/* the index of the first character not yet appended to the builder. */
+			while (p < l) {
+				int c = buffer[p++];
+				if (c == quote) {
+					pos = p;
+					return;
+				} else if (c == '\\') {
+					pos = p;
+					readEscapeCharacter();
+					p = pos;
+					l = limit;
+				} else if (c == '\n') {
+					lineNumber++;
+					lineStart = p;
+				}
+			}
+			pos = p;
+		} while (fillBuffer(1));
+		throw syntaxError("Unterminated string");
+	}
+
+	private void skipUnquotedValue() throws IOException {
+		do {
+			int i = 0;
+			for (; pos + i < limit; i++) {
+				switch (buffer[pos + i]) {
+				case '/':
+				case '\\':
+				case ';':
+				case '#':
+				case '=':
+					checkLenient(); // fall-through
+				case '{':
+				case '}':
+				case '[':
+				case ']':
+				case ':':
+				case ',':
+				case ' ':
+				case '\t':
+				case '\f':
+				case '\r':
+				case '\n':
+					pos += i;
+					return;
+				}
+			}
+			pos += i;
+		} while (fillBuffer(1));
+	}
+
+	/**
+	 * Returns the {@link JsonToken#NUMBER int} value of the next token,
+	 * consuming it. If the next token is a string, this method will attempt to
+	 * parse it as an int. If the next token's numeric value cannot be exactly
+	 * represented by a Java {@code int}, this method throws.
+	 *
+	 * @throws IllegalStateException if the next token is not a literal value.
+	 * @throws NumberFormatException if the next literal value cannot be parsed
+	 *     as a number, or exactly represented as an int.
+	 */
+	public int nextInt() throws IOException {
+		int p = peeked;
+		if (p == PEEKED_NONE) {
+			p = doPeek();
+		}
+
+		int result;
+		if (p == PEEKED_LONG) {
+			result = (int) peekedLong;
+			if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
+				throw new NumberFormatException("Expected an int but was " + peekedLong + locationString());
+			}
+			peeked = PEEKED_NONE;
+			pathIndices[stackSize - 1]++;
+			return result;
+		}
+
+		if (p == PEEKED_NUMBER) {
+			peekedString = new String(buffer, pos, peekedNumberLength);
+			pos += peekedNumberLength;
+		} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {
+			if (p == PEEKED_UNQUOTED) {
+				peekedString = nextUnquotedValue();
+			} else {
+				peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\'' : '"');
+			}
+			try {
+				result = Integer.parseInt(peekedString);
+				peeked = PEEKED_NONE;
+				pathIndices[stackSize - 1]++;
+				return result;
+			} catch (NumberFormatException ignored) {
+				// Fall back to parse as a double below.
+			}
+		} else {
+			throw new IllegalStateException("Expected an int but was " + peek() + locationString());
+		}
+
+		peeked = PEEKED_BUFFERED;
+		double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+		result = (int) asDouble;
+		if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
+			throw new NumberFormatException("Expected an int but was " + peekedString + locationString());
+		}
+		peekedString = null;
+		peeked = PEEKED_NONE;
+		pathIndices[stackSize - 1]++;
+		return result;
+	}
+
+	/**
+	 * Closes this JSON reader and the underlying {@link Reader}.
+	 */
+	public void close() throws IOException {
+		peeked = PEEKED_NONE;
+		stack[0] = JsonScope.CLOSED;
+		stackSize = 1;
+		in.close();
+	}
+
+	/**
+	 * Skips the next value recursively. If it is an object or array, all nested
+	 * elements are skipped. This method is intended for use when the JSON token
+	 * stream contains unrecognized or unhandled values.
+	 */
+	public void skipValue() throws IOException {
+		int count = 0;
+		do {
+			int p = peeked;
+			if (p == PEEKED_NONE) {
+				p = doPeek();
+			}
+
+			if (p == PEEKED_BEGIN_ARRAY) {
+				push(JsonScope.EMPTY_ARRAY);
+				count++;
+			} else if (p == PEEKED_BEGIN_OBJECT) {
+				push(JsonScope.EMPTY_OBJECT);
+				count++;
+			} else if (p == PEEKED_END_ARRAY) {
+				stackSize--;
+				count--;
+			} else if (p == PEEKED_END_OBJECT) {
+				stackSize--;
+				count--;
+			} else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
+				skipUnquotedValue();
+			} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
+				skipQuotedValue('\'');
+			} else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
+				skipQuotedValue('"');
+			} else if (p == PEEKED_NUMBER) {
+				pos += peekedNumberLength;
+			}
+			peeked = PEEKED_NONE;
+		} while (count != 0);
+
+		pathIndices[stackSize - 1]++;
+		pathNames[stackSize - 1] = "null";
+	}
+
+	private void push(int newTop) {
+		if (stackSize == stack.length) {
+			int newLength = stackSize * 2;
+			stack = Arrays.copyOf(stack, newLength);
+			pathIndices = Arrays.copyOf(pathIndices, newLength);
+			pathNames = Arrays.copyOf(pathNames, newLength);
+		}
+		stack[stackSize++] = newTop;
+	}
+
+	/**
+	 * Returns true once {@code limit - pos >= minimum}. If the data is
+	 * exhausted before that many characters are available, this returns
+	 * false.
+	 */
+	private boolean fillBuffer(int minimum) throws IOException {
+		char[] buffer = this.buffer;
+
+		if (!rewindEnabled) { // Fabric - preserve data for rewinding by expanding the buffer instead of compacting 
+			lineStart -= pos;
+			if (limit != pos) {
+				limit -= pos;
+				System.arraycopy(buffer, pos, buffer, 0, limit);
+			} else {
+				limit = 0;
+			}
+
+			pos = 0;
+		} else if (buffer.length - limit < minimum) {
+			buffer = Arrays.copyOf(buffer, buffer.length + Math.max(buffer.length, minimum));
+		}
+
+		int total;
+		while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {
+			limit += total;
+
+			// if this is the first read, consume an optional byte order mark (BOM) if it exists
+			if (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\ufeff') {
+				pos++;
+				lineStart++;
+				minimum++;
+			}
+
+			if (limit >= minimum) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	 * Returns the next character in the stream that is neither whitespace nor a
+	 * part of a comment. When this returns, the returned character is always at
+	 * {@code buffer[pos-1]}; this means the caller can always push back the
+	 * returned character by decrementing {@code pos}.
+	 */
+	private int nextNonWhitespace(boolean throwOnEof) throws IOException {
+		/*
+		 * This code uses ugly local variables 'p' and 'l' representing the 'pos'
+		 * and 'limit' fields respectively. Using locals rather than fields saves
+		 * a few field reads for each whitespace character in a pretty-printed
+		 * document, resulting in a 5% speedup. We need to flush 'p' to its field
+		 * before any (potentially indirect) call to fillBuffer() and reread both
+		 * 'p' and 'l' after any (potentially indirect) call to the same method.
+		 */
+		char[] buffer = this.buffer;
+		int p = pos;
+		int l = limit;
+		while (true) {
+			if (p == l) {
+				pos = p;
+				if (!fillBuffer(1)) {
+					break;
+				}
+				p = pos;
+				l = limit;
+			}
+
+			int c = buffer[p++];
+			if (c == '\n') {
+				lineNumber++;
+				lineStart = p;
+				continue;
+			} else if (c == ' ' || c == '\r' || c == '\t') {
+				continue;
+			}
+
+			if (c == '/') {
+				pos = p;
+				if (p == l) {
+					pos--; // push back '/' so it's still in the buffer when this method returns
+					boolean charsLoaded = fillBuffer(2);
+					pos++; // consume the '/' again
+					if (!charsLoaded) {
+						return c;
+					}
+				}
+
+				checkLenient();
+				char peek = buffer[pos];
+				switch (peek) {
+				case '*':
+					// skip a /* c-style comment */
+					pos++;
+					if (!skipTo("*/")) {
+						throw syntaxError("Unterminated comment");
+					}
+					p = pos + 2;
+					l = limit;
+					continue;
+
+				case '/':
+					// skip a // end-of-line comment
+					pos++;
+					skipToEndOfLine();
+					p = pos;
+					l = limit;
+					continue;
+
+				default:
+					return c;
+				}
+			} else if (c == '#') {
+				pos = p;
+				/*
+				 * Skip a # hash end-of-line comment. The JSON RFC doesn't
+				 * specify this behaviour, but it's required to parse
+				 * existing documents. See http://b/2571423.
+				 */
+				checkLenient();
+				skipToEndOfLine();
+				p = pos;
+				l = limit;
+			} else {
+				pos = p;
+				return c;
+			}
+		}
+		if (throwOnEof) {
+			throw new EOFException("End of input" + locationString());
+		} else {
+			return -1;
+		}
+	}
+
+	private void checkLenient() throws IOException {
+		if (!lenient) {
+			throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON");
+		}
+	}
+
+	/**
+	 * Advances the position until after the next newline character. If the line
+	 * is terminated by "\r\n", the '\n' must be consumed as whitespace by the
+	 * caller.
+	 */
+	private void skipToEndOfLine() throws IOException {
+		while (pos < limit || fillBuffer(1)) {
+			char c = buffer[pos++];
+			if (c == '\n') {
+				lineNumber++;
+				lineStart = pos;
+				break;
+			} else if (c == '\r') {
+				break;
+			}
+		}
+	}
+
+	/**
+	 * @param toFind a string to search for. Must not contain a newline.
+	 */
+	private boolean skipTo(String toFind) throws IOException {
+		int length = toFind.length();
+		outer:
+		for (; pos + length <= limit || fillBuffer(length); pos++) {
+			if (buffer[pos] == '\n') {
+				lineNumber++;
+				lineStart = pos + 1;
+				continue;
+			}
+			for (int c = 0; c < length; c++) {
+				if (buffer[pos + c] != toFind.charAt(c)) {
+					continue outer;
+				}
+			}
+			return true;
+		}
+		return false;
+	}
+
+	@Override public String toString() {
+		return getClass().getSimpleName() + locationString();
+	}
+
+	// Fabric - Make location string public for error context
+	public String locationString() {
+		int line = lineNumber + 1;
+		int column = pos - lineStart + 1;
+		return " at line " + line + " column " + column + " path " + getPath();
+	}
+
+	/**
+	 * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
+	 * the current location in the JSON value.
+	 */
+	public String getPath() {
+		StringBuilder result = new StringBuilder().append('$');
+		for (int i = 0, size = stackSize; i < size; i++) {
+			switch (stack[i]) {
+			case JsonScope.EMPTY_ARRAY:
+			case JsonScope.NONEMPTY_ARRAY:
+				result.append('[').append(pathIndices[i]).append(']');
+				break;
+
+			case JsonScope.EMPTY_OBJECT:
+			case JsonScope.DANGLING_NAME:
+			case JsonScope.NONEMPTY_OBJECT:
+				result.append('.');
+				if (pathNames[i] != null) {
+					result.append(pathNames[i]);
+				}
+				break;
+
+			case JsonScope.NONEMPTY_DOCUMENT:
+			case JsonScope.EMPTY_DOCUMENT:
+			case JsonScope.CLOSED:
+				break;
+			}
+		}
+		return result.toString();
+	}
+
+	/**
+	 * Unescapes the character identified by the character or characters that
+	 * immediately follow a backslash. The backslash '\' should have already
+	 * been read. This supports both unicode escapes "u000A" and two-character
+	 * escapes "\n".
+	 *
+	 * @throws NumberFormatException if any unicode escape sequences are
+	 *     malformed.
+	 */
+	private char readEscapeCharacter() throws IOException {
+		if (pos == limit && !fillBuffer(1)) {
+			throw syntaxError("Unterminated escape sequence");
+		}
+
+		char escaped = buffer[pos++];
+		switch (escaped) {
+		case 'u':
+			if (pos + 4 > limit && !fillBuffer(4)) {
+				throw syntaxError("Unterminated escape sequence");
+			}
+			// Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);
+			char result = 0;
+			for (int i = pos, end = i + 4; i < end; i++) {
+				char c = buffer[i];
+				result <<= 4;
+				if (c >= '0' && c <= '9') {
+					result += (c - '0');
+				} else if (c >= 'a' && c <= 'f') {
+					result += (c - 'a' + 10);
+				} else if (c >= 'A' && c <= 'F') {
+					result += (c - 'A' + 10);
+				} else {
+					throw new NumberFormatException("\\u" + new String(buffer, pos, 4));
+				}
+			}
+			pos += 4;
+			return result;
+
+		case 't':
+			return '\t';
+
+		case 'b':
+			return '\b';
+
+		case 'n':
+			return '\n';
+
+		case 'r':
+			return '\r';
+
+		case 'f':
+			return '\f';
+
+		case '\n':
+			lineNumber++;
+			lineStart = pos;
+			// fall-through
+
+		case '\'':
+		case '"':
+		case '\\':
+		case '/':
+			return escaped;
+		default:
+			// throw error when none of the above cases are matched
+			throw syntaxError("Invalid escape sequence");
+		}
+	}
+
+	/**
+	 * Throws a new IO exception with the given message and a context snippet
+	 * with this reader's content.
+	 */
+	private IOException syntaxError(String message) throws IOException {
+		throw new MalformedJsonException(message + locationString());
+	}
+
+	/**
+	 * Consumes the non-execute prefix if it exists.
+	 */
+	private void consumeNonExecutePrefix() throws IOException {
+		// fast forward through the leading whitespace
+		nextNonWhitespace(true);
+		pos--;
+
+		int p = pos;
+		if (p + 5 > limit && !fillBuffer(5)) {
+			return;
+		}
+
+		char[] buf = buffer;
+		if(buf[p] != ')' || buf[p + 1] != ']' || buf[p + 2] != '}' || buf[p + 3] != '\'' || buf[p + 4] != '\n') {
+			return; // not a security token!
+		}
+
+		// we consumed a security token!
+		pos += 5;
+	}
+
+	// Fabric - added methods for warning messages and rewinding
+
+	public int getLineNumber() {
+		return this.lineNumber + 1;
+	}
+
+	public int getColumn() {
+		return this.pos - this.lineStart + 1;
+	}
+
+	private boolean rewindEnabled;
+
+	public void rewind() {
+		if (!rewindEnabled) throw new IllegalStateException("rewind disabled");
+
+		pos = 0;
+		lineNumber = 0;
+		lineStart = 0;
+		peeked = PEEKED_NONE;
+		stackSize = 1;
+		stack[0] = JsonScope.EMPTY_DOCUMENT;
+	}
+
+	public void setRewindEnabled(boolean value) {
+		if (value && (pos > 0 || lineNumber > 0)) throw new IllegalStateException("already read some data");
+
+		rewindEnabled = value;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/lib/gson/JsonScope.java b/src/main/java/net/fabricmc/loader/impl/lib/gson/JsonScope.java
new file mode 100644
index 0000000000000000000000000000000000000000..24add7b67d772a694cd3a7fd93a9c1344d287ff9
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/lib/gson/JsonScope.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ * Copyright (c) 2020 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * This file has been modified by the Fabric project (repackage, minor changes).
+ */
+
+package net.fabricmc.loader.impl.lib.gson;
+
+/**
+ * Lexical scoping elements within a JSON reader or writer.
+ *
+ * @author Jesse Wilson
+ * @since 1.6
+ */
+final class JsonScope {
+
+	/**
+	 * An array with no elements requires no separators or newlines before
+	 * it is closed.
+	 */
+	static final int EMPTY_ARRAY = 1;
+
+	/**
+	 * A array with at least one value requires a comma and newline before
+	 * the next element.
+	 */
+	static final int NONEMPTY_ARRAY = 2;
+
+	/**
+	 * An object with no name/value pairs requires no separators or newlines
+	 * before it is closed.
+	 */
+	static final int EMPTY_OBJECT = 3;
+
+	/**
+	 * An object whose most recent element is a key. The next element must
+	 * be a value.
+	 */
+	static final int DANGLING_NAME = 4;
+
+	/**
+	 * An object with at least one name/value pair requires a comma and
+	 * newline before the next element.
+	 */
+	static final int NONEMPTY_OBJECT = 5;
+
+	/**
+	 * No object or array has been started.
+	 */
+	static final int EMPTY_DOCUMENT = 6;
+
+	/**
+	 * A document with at an array or object.
+	 */
+	static final int NONEMPTY_DOCUMENT = 7;
+
+	/**
+	 * A document that's been closed and cannot be accessed.
+	 */
+	static final int CLOSED = 8;
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/lib/gson/JsonToken.java b/src/main/java/net/fabricmc/loader/impl/lib/gson/JsonToken.java
new file mode 100644
index 0000000000000000000000000000000000000000..377517de0b157f752b9bcae20014572eaad0c4aa
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/lib/gson/JsonToken.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ * Copyright (c) 2020 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * This file has been modified by the Fabric project (repackage, minor changes).
+ */
+
+package net.fabricmc.loader.impl.lib.gson;
+
+/**
+ * A structure, name or value type in a JSON-encoded string.
+ *
+ * @author Jesse Wilson
+ * @since 1.6
+ */
+public enum JsonToken {
+
+	/**
+	 * The opening of a JSON array. Written using {@link JsonWriter#beginArray}
+	 * and read using {@link JsonReader#beginArray}.
+	 */
+	BEGIN_ARRAY,
+
+	/**
+	 * The closing of a JSON array. Written using {@link JsonWriter#endArray}
+	 * and read using {@link JsonReader#endArray}.
+	 */
+	END_ARRAY,
+
+	/**
+	 * The opening of a JSON object. Written using {@link JsonWriter#beginObject}
+	 * and read using {@link JsonReader#beginObject}.
+	 */
+	BEGIN_OBJECT,
+
+	/**
+	 * The closing of a JSON object. Written using {@link JsonWriter#endObject}
+	 * and read using {@link JsonReader#endObject}.
+	 */
+	END_OBJECT,
+
+	/**
+	 * A JSON property name. Within objects, tokens alternate between names and
+	 * their values. Written using {@link JsonWriter#name} and read using {@link
+	 * JsonReader#nextName}
+	 */
+	NAME,
+
+	/**
+	 * A JSON string.
+	 */
+	STRING,
+
+	/**
+	 * A JSON number represented in this API by a Java {@code double}, {@code
+	 * long}, or {@code int}.
+	 */
+	NUMBER,
+
+	/**
+	 * A JSON {@code true} or {@code false}.
+	 */
+	BOOLEAN,
+
+	/**
+	 * A JSON {@code null}.
+	 */
+	NULL,
+
+	/**
+	 * The end of the JSON stream. This sentinel value is returned by {@link
+	 * JsonReader#peek()} to signal that the JSON-encoded value has no more
+	 * tokens.
+	 */
+	END_DOCUMENT
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/lib/gson/MalformedJsonException.java b/src/main/java/net/fabricmc/loader/impl/lib/gson/MalformedJsonException.java
new file mode 100644
index 0000000000000000000000000000000000000000..74327d2df2c8f42082f069032cf55ee192d1ced2
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/lib/gson/MalformedJsonException.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ * Copyright (c) 2020 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * This file has been modified by the Fabric project (repackage, minor changes).
+ */
+
+package net.fabricmc.loader.impl.lib.gson;
+
+import java.io.IOException;
+
+/**
+ * Thrown when a reader encounters malformed JSON. Some syntax errors can be
+ * ignored by calling {@link JsonReader#setLenient(boolean)}.
+ */
+public final class MalformedJsonException extends IOException {
+	private static final long serialVersionUID = 1L;
+
+	public MalformedJsonException(String msg) {
+		super(msg);
+	}
+
+	public MalformedJsonException(String msg, Throwable throwable) {
+		super(msg);
+		// Using initCause() instead of calling super() because Java 1.5 didn't retrofit IOException
+		// with a constructor with Throwable. This was done in Java 1.6
+		initCause(throwable);
+	}
+
+	public MalformedJsonException(Throwable throwable) {
+		// Using initCause() instead of calling super() because Java 1.5 didn't retrofit IOException
+		// with a constructor with Throwable. This was done in Java 1.6
+		initCause(throwable);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/AbstractModMetadata.java b/src/main/java/net/fabricmc/loader/impl/metadata/AbstractModMetadata.java
new file mode 100644
index 0000000000000000000000000000000000000000..fdf535752128baeddda3860c4888c32a6cefec7c
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/AbstractModMetadata.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.metadata.CustomValue;
+import net.fabricmc.loader.api.metadata.ModMetadata;
+
+public abstract class AbstractModMetadata implements ModMetadata {
+	public static final String TYPE_BUILTIN = "builtin";
+	public static final String TYPE_FABRIC_MOD = "fabric";
+
+	@Override
+	public boolean containsCustomElement(String key) {
+		return containsCustomValue(key);
+	}
+
+	@Override
+	public boolean containsCustomValue(String key) {
+		return getCustomValues().containsKey(key);
+	}
+
+	@Override
+	public CustomValue getCustomValue(String key) {
+		return getCustomValues().get(key);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/BuiltinModMetadata.java b/src/main/java/net/fabricmc/loader/impl/metadata/BuiltinModMetadata.java
new file mode 100644
index 0000000000000000000000000000000000000000..ca3f8742dc6f18957c12a5cb943b10d250b98e22
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/BuiltinModMetadata.java
@@ -0,0 +1,235 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.api.metadata.*;
+import net.fabricmc.loader.impl.util.version.VersionParser;
+
+import java.util.*;
+import java.util.Map.Entry;
+
+public final class BuiltinModMetadata extends AbstractModMetadata {
+	private final String id;
+	private final Version version;
+	private final ModEnvironment environment;
+	private final String name;
+	private final String description;
+	private final Collection<Person> authors;
+	private final Collection<Person> contributors;
+	private final ContactInformation contact;
+	private final Collection<String> license;
+	private final NavigableMap<Integer, String> icons;
+	private final Collection<ModDependency> dependencies;
+
+	private BuiltinModMetadata(String id, Version version,
+			ModEnvironment environment,
+			String name, String description,
+			Collection<Person> authors, Collection<Person> contributors,
+			ContactInformation contact,
+			Collection<String> license,
+			NavigableMap<Integer, String> icons,
+			Collection<ModDependency> dependencies) {
+		this.id = id;
+		this.version = version;
+		this.environment = environment;
+		this.name = name;
+		this.description = description;
+		this.authors = Collections.unmodifiableCollection(authors);
+		this.contributors = Collections.unmodifiableCollection(contributors);
+		this.contact = contact;
+		this.license = Collections.unmodifiableCollection(license);
+		this.icons = icons;
+		this.dependencies = Collections.unmodifiableCollection(dependencies);
+	}
+
+	@Override
+	public String getType() {
+		return TYPE_BUILTIN;
+	}
+
+	@Override
+	public String getId() {
+		return id;
+	}
+
+	@Override
+	public Collection<String> getProvides() {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public Version getVersion() {
+		return version;
+	}
+
+	@Override
+	public ModEnvironment getEnvironment() {
+		return environment;
+	}
+
+	@Override
+	public String getName() {
+		return name;
+	}
+
+	@Override
+	public String getDescription() {
+		return description;
+	}
+
+	@Override
+	public Collection<Person> getAuthors() {
+		return authors;
+	}
+
+	@Override
+	public Collection<Person> getContributors() {
+		return contributors;
+	}
+
+	@Override
+	public ContactInformation getContact() {
+		return contact;
+	}
+
+	@Override
+	public Collection<String> getLicense() {
+		return license;
+	}
+
+	@Override
+	public Optional<String> getIconPath(int size) {
+		if (icons.isEmpty()) return Optional.empty();
+
+		Integer key = size;
+		Entry<Integer, String> ret = icons.ceilingEntry(key);
+		if (ret == null) ret = icons.lastEntry();
+
+		return Optional.of(ret.getValue());
+	}
+
+	@Override
+	public Collection<ModDependency> getDependencies() {
+		return dependencies;
+	}
+
+	@Override
+	public boolean containsCustomValue(String key) {
+		return false;
+	}
+
+	@Override
+	public CustomValue getCustomValue(String key) {
+		return null;
+	}
+
+	@Override
+	public Map<String, CustomValue> getCustomValues() {
+		return Collections.emptyMap();
+	}
+
+	public static class Builder {
+		private final String id;
+		private final Version version;
+		private ModEnvironment environment = ModEnvironment.UNIVERSAL;
+		private String name;
+		private String description = "";
+		private final Collection<Person> authors = new ArrayList<>();
+		private final Collection<Person> contributors = new ArrayList<>();
+		private ContactInformation contact = ContactInformation.EMPTY;
+		private final Collection<String> license = new ArrayList<>();
+		private final NavigableMap<Integer, String> icons = new TreeMap<>();
+		private final Collection<ModDependency> dependencies = new ArrayList<>();
+
+		public Builder(String id, String version) {
+			this.name = this.id = id;
+
+			try {
+				this.version = VersionParser.parseSemantic(version);
+			} catch (Exception e) {
+				throw new RuntimeException(e);
+			}
+		}
+
+		public Builder setEnvironment(ModEnvironment environment) {
+			this.environment = environment;
+			return this;
+		}
+
+		public Builder setName(String name) {
+			this.name = name;
+			return this;
+		}
+
+		public Builder setDescription(String description) {
+			this.description = description;
+			return this;
+		}
+
+		public Builder addAuthor(String name, Map<String, String> contactMap) {
+			this.authors.add(createPerson(name, contactMap));
+			return this;
+		}
+
+		public Builder addContributor(String name, Map<String, String> contactMap) {
+			this.contributors.add(createPerson(name, contactMap));
+			return this;
+		}
+
+		public Builder setContact(ContactInformation contact) {
+			this.contact = contact;
+			return this;
+		}
+
+		public Builder addLicense(String license) {
+			this.license.add(license);
+			return this;
+		}
+
+		public Builder addIcon(int size, String path) {
+			this.icons.put(size, path);
+			return this;
+		}
+
+		public Builder addDependency(ModDependency dependency) {
+			this.dependencies.add(dependency);
+			return this;
+		}
+
+		public ModMetadata build() {
+			return new BuiltinModMetadata(id, version, environment, name, description, authors, contributors, contact, license, icons, dependencies);
+		}
+
+		private static Person createPerson(String name, Map<String, String> contactMap) {
+			return new Person() {
+				@Override
+				public String getName() {
+					return name;
+				}
+
+				@Override
+				public ContactInformation getContact() {
+					return contact;
+				}
+
+				private final ContactInformation contact = contactMap.isEmpty() ? ContactInformation.EMPTY : new ContactInformationImpl(contactMap);
+			};
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/ContactInfoBackedPerson.java b/src/main/java/net/fabricmc/loader/impl/metadata/ContactInfoBackedPerson.java
new file mode 100644
index 0000000000000000000000000000000000000000..dda26c13d8d60056f1372ffc4b88080fbf69f05e
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/ContactInfoBackedPerson.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.metadata.ContactInformation;
+
+final class ContactInfoBackedPerson extends SimplePerson {
+	private final ContactInformation contact;
+
+	ContactInfoBackedPerson(String name, ContactInformation contact) {
+		super(name);
+		this.contact = contact;
+	}
+
+	@Override
+	public ContactInformation getContact() {
+		return this.contact;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/ContactInformationImpl.java b/src/main/java/net/fabricmc/loader/impl/metadata/ContactInformationImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..97b10859b925de8774500685a7f475b8f812e72f
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/ContactInformationImpl.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.metadata.ContactInformation;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Optional;
+
+public class ContactInformationImpl implements ContactInformation {
+	private final Map<String, String> map;
+
+	public ContactInformationImpl(Map<String, String> map) {
+		this.map = Collections.unmodifiableMap(map);
+	}
+
+	@Override
+	public Optional<String> get(String key) {
+		return Optional.ofNullable(map.get(key));
+	}
+
+	@Override
+	public Map<String, String> asMap() {
+		return map;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/CustomValueImpl.java b/src/main/java/net/fabricmc/loader/impl/metadata/CustomValueImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..51e7a16654acaaf2524984e56701fc36445bc715
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/CustomValueImpl.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.metadata.CustomValue;
+import net.fabricmc.loader.impl.lib.gson.JsonReader;
+
+import java.io.IOException;
+import java.util.*;
+import java.util.Map.Entry;
+
+abstract class CustomValueImpl implements CustomValue {
+	static final CustomValue BOOLEAN_TRUE = new BooleanImpl(true);
+	static final CustomValue BOOLEAN_FALSE = new BooleanImpl(false);
+	static final CustomValue NULL = new NullImpl();
+
+	public static CustomValue readCustomValue(JsonReader reader) throws IOException, ParseMetadataException {
+		switch (reader.peek()) {
+		case BEGIN_OBJECT:
+			reader.beginObject();
+
+			// To preserve insertion order
+			final Map<String, CustomValue> values = new LinkedHashMap<>();
+
+			while (reader.hasNext()) {
+				values.put(reader.nextName(), readCustomValue(reader));
+			}
+
+			reader.endObject();
+
+			return new ObjectImpl(values);
+		case BEGIN_ARRAY:
+			reader.beginArray();
+
+			final List<CustomValue> entries = new ArrayList<>();
+
+			while (reader.hasNext()) {
+				entries.add(readCustomValue(reader));
+			}
+
+			reader.endArray();
+
+			return new ArrayImpl(entries);
+		case STRING:
+			return new StringImpl(reader.nextString());
+		case NUMBER:
+			// TODO: Parse this somewhat more smartly?
+			return new NumberImpl(reader.nextDouble());
+		case BOOLEAN:
+			if (reader.nextBoolean()) {
+				return BOOLEAN_TRUE;
+			}
+
+			return BOOLEAN_FALSE;
+		case NULL:
+			reader.nextNull();
+			return NULL;
+		default:
+			throw new ParseMetadataException(Objects.toString(reader.nextName()), reader);
+		}
+	}
+
+	@Override
+	public final CvObject getAsObject() {
+		if (this instanceof ObjectImpl) {
+			return (ObjectImpl) this;
+		} else {
+			throw new ClassCastException("can't convert "+getType().name()+" to Object");
+		}
+	}
+
+	@Override
+	public final CvArray getAsArray() {
+		if (this instanceof ArrayImpl) {
+			return (ArrayImpl) this;
+		} else {
+			throw new ClassCastException("can't convert "+getType().name()+" to Array");
+		}
+	}
+
+	@Override
+	public final String getAsString() {
+		if (this instanceof StringImpl) {
+			return ((StringImpl) this).value;
+		} else {
+			throw new ClassCastException("can't convert "+getType().name()+" to String");
+		}
+	}
+
+	@Override
+	public final Number getAsNumber() {
+		if (this instanceof NumberImpl) {
+			return ((NumberImpl) this).value;
+		} else {
+			throw new ClassCastException("can't convert "+getType().name()+" to Number");
+		}
+	}
+
+	@Override
+	public final boolean getAsBoolean() {
+		if (this instanceof BooleanImpl) {
+			return ((BooleanImpl) this).value;
+		} else {
+			throw new ClassCastException("can't convert "+getType().name()+" to Boolean");
+		}
+	}
+
+	private static final class ObjectImpl extends CustomValueImpl implements CvObject {
+		private final Map<String, CustomValue> entries;
+
+		ObjectImpl(Map<String, CustomValue> entries) {
+			this.entries = Collections.unmodifiableMap(entries);
+		}
+
+		@Override
+		public CvType getType() {
+			return CvType.OBJECT;
+		}
+
+		@Override
+		public int size() {
+			return entries.size();
+		}
+
+		@Override
+		public boolean containsKey(String key) {
+			return entries.containsKey(key);
+		}
+
+		@Override
+		public CustomValue get(String key) {
+			return entries.get(key);
+		}
+
+		@Override
+		public Iterator<Entry<String, CustomValue>> iterator() {
+			return entries.entrySet().iterator();
+		}
+	}
+
+	private static final class ArrayImpl extends CustomValueImpl implements CvArray {
+		private final List<CustomValue> entries;
+
+		ArrayImpl(List<CustomValue> entries) {
+			this.entries = Collections.unmodifiableList(entries);
+		}
+
+		@Override
+		public CvType getType() {
+			return CvType.ARRAY;
+		}
+
+		@Override
+		public int size() {
+			return entries.size();
+		}
+
+		@Override
+		public CustomValue get(int index) {
+			return entries.get(index);
+		}
+
+		@Override
+		public Iterator<CustomValue> iterator() {
+			return entries.iterator();
+		}
+	}
+
+	private static final class StringImpl extends CustomValueImpl {
+		final String value;
+
+		StringImpl(String value) {
+			this.value = value;
+		}
+
+		@Override
+		public CvType getType() {
+			return CvType.STRING;
+		}
+	}
+
+	private static final class NumberImpl extends CustomValueImpl {
+		final Number value;
+
+		NumberImpl(Number value) {
+			this.value = value;
+		}
+
+		@Override
+		public CvType getType() {
+			return CvType.NUMBER;
+		}
+	}
+
+	private static final class BooleanImpl extends CustomValueImpl {
+		final boolean value;
+
+		BooleanImpl(boolean value) {
+			this.value = value;
+		}
+
+		@Override
+		public CvType getType() {
+			return CvType.BOOLEAN;
+		}
+	}
+
+	private static final class NullImpl extends CustomValueImpl {
+		@Override
+		public CvType getType() {
+			return CvType.NULL;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/DependencyOverrides.java b/src/main/java/net/fabricmc/loader/impl/metadata/DependencyOverrides.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab0502b8d9c0fa851bd53d5e6898f55137f5a7ee
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/DependencyOverrides.java
@@ -0,0 +1,271 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.api.metadata.ModDependency;
+import net.fabricmc.loader.impl.FormattedException;
+import net.fabricmc.loader.impl.lib.gson.JsonReader;
+import net.fabricmc.loader.impl.lib.gson.JsonToken;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.stream.Collectors;
+
+public final class DependencyOverrides {
+	private final Map<String, List<Entry>> dependencyOverrides;
+
+	public DependencyOverrides(Path configDir) {
+		Path path = configDir.resolve("fabric_loader_dependencies.json");
+
+		if (!Files.exists(path)) {
+			dependencyOverrides = Collections.emptyMap();
+			return;
+		}
+
+		try (JsonReader reader = new JsonReader(new InputStreamReader(Files.newInputStream(path), StandardCharsets.UTF_8))) {
+			dependencyOverrides = parse(reader);
+		} catch (IOException | ParseMetadataException e) {
+			throw new FormattedException("Error parsing dependency overrides!", "Failed to parse " + LoaderUtil.normalizePath(path), e);
+		}
+	}
+
+	private static Map<String, List<Entry>> parse(JsonReader reader) throws ParseMetadataException, IOException {
+		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+			throw new ParseMetadataException("Root must be an object", reader);
+		}
+
+		Map<String, List<Entry>> ret = new HashMap<>();
+		reader.beginObject();
+
+		if (!reader.nextName().equals("version")) {
+			throw new ParseMetadataException("First key must be \"version\"", reader);
+		}
+
+		if (reader.peek() != JsonToken.NUMBER || reader.nextInt() != 1) {
+			throw new ParseMetadataException("Unsupported \"version\", must be 1", reader);
+		}
+
+		while (reader.hasNext()) {
+			String key = reader.nextName();
+
+			if ("overrides".equals(key)) {
+				reader.beginObject();
+
+				while (reader.hasNext()) {
+					String modId = reader.nextName();
+
+					ret.put(modId, readKeys(reader));
+				}
+
+				reader.endObject();
+			} else {
+				throw new ParseMetadataException("Unsupported root key: " + key, reader);
+			}
+		}
+
+		reader.endObject();
+
+		return ret;
+	}
+
+	private static List<Entry> readKeys(JsonReader reader) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+			throw new ParseMetadataException("Dependency container must be an object!", reader);
+		}
+
+		Map<ModDependency.Kind, Map<Operation, List<ModDependency>>> modOverrides = new EnumMap<>(ModDependency.Kind.class);
+		reader.beginObject();
+
+		while (reader.hasNext()) {
+			String key = reader.nextName();
+			Operation op = null;
+
+			for (Operation o : Operation.VALUES) {
+				if (key.startsWith(o.operator)) {
+					op = o;
+					key = key.substring(o.operator.length());
+					break;
+				}
+			}
+
+			assert op != null; // should always match since REPLACE has an empty operator string
+
+			ModDependency.Kind kind = ModDependency.Kind.parse(key);
+
+			if (kind == null) {
+				throw new ParseMetadataException(String.format("%s is not an allowed dependency key, must be one of: %s",
+						key, Arrays.stream(ModDependency.Kind.values()).map(ModDependency.Kind::getKey).collect(Collectors.joining(", "))),
+						reader);
+			}
+
+			List<ModDependency> deps = readDependencies(reader, kind);
+
+			if (!deps.isEmpty() || op == Operation.REPLACE) {
+				modOverrides.computeIfAbsent(kind, ignore -> new EnumMap<>(Operation.class)).put(op, deps);
+			}
+		}
+
+		reader.endObject();
+
+		List<Entry> ret = new ArrayList<>();
+
+		for (Map.Entry<ModDependency.Kind, Map<Operation, List<ModDependency>>> entry : modOverrides.entrySet()) {
+			ModDependency.Kind kind = entry.getKey();
+			Map<Operation, List<ModDependency>> map = entry.getValue();
+
+			List<ModDependency> values = map.get(Operation.REPLACE);
+
+			if (values != null) {
+				ret.add(new Entry(Operation.REPLACE, kind, values)); // suppresses add+remove
+			} else {
+				values = map.get(Operation.REMOVE);
+				if (values != null) ret.add(new Entry(Operation.REMOVE, kind, values));
+
+				values = map.get(Operation.ADD); // after remove
+				if (values != null) ret.add(new Entry(Operation.ADD, kind, values));
+			}
+		}
+
+		return ret;
+	}
+
+	private static List<ModDependency> readDependencies(JsonReader reader, ModDependency.Kind kind) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+			throw new ParseMetadataException("Dependency container must be an object!", reader);
+		}
+
+		List<ModDependency> ret = new ArrayList<>();
+		reader.beginObject();
+
+		while (reader.hasNext()) {
+			final String modId = reader.nextName();
+			final List<String> matcherStringList = new ArrayList<>();
+
+			switch (reader.peek()) {
+			case STRING:
+				matcherStringList.add(reader.nextString());
+				break;
+			case BEGIN_ARRAY:
+				reader.beginArray();
+
+				while (reader.hasNext()) {
+					if (reader.peek() != JsonToken.STRING) {
+						throw new ParseMetadataException("Dependency version range array must only contain string values", reader);
+					}
+
+					matcherStringList.add(reader.nextString());
+				}
+
+				reader.endArray();
+				break;
+			default:
+				throw new ParseMetadataException("Dependency version range must be a string or string array!", reader);
+			}
+
+			try {
+				ret.add(new ModDependencyImpl(kind, modId, matcherStringList));
+			} catch (Exception e) {
+				throw new ParseMetadataException(e);
+			}
+		}
+
+		reader.endObject();
+
+		return ret;
+	}
+
+	public void apply(LoaderModMetadata metadata) {
+		if (dependencyOverrides.isEmpty()) return;
+
+		List<Entry> modOverrides = dependencyOverrides.get(metadata.getId());
+		if (modOverrides == null) return;
+
+		List<ModDependency> deps = new ArrayList<>(metadata.getDependencies());
+
+		for (Entry entry : modOverrides) {
+			switch (entry.operation) {
+			case REPLACE:
+				for (Iterator<ModDependency> it = deps.iterator(); it.hasNext(); ) {
+					ModDependency dep = it.next();
+
+					if (dep.getKind() == entry.kind) {
+						it.remove();
+					}
+				}
+
+				deps.addAll(entry.values);
+				break;
+			case REMOVE:
+				for (Iterator<ModDependency> it = deps.iterator(); it.hasNext(); ) {
+					ModDependency dep = it.next();
+
+					if (dep.getKind() == entry.kind) {
+						for (ModDependency value : entry.values) {
+							if (value.getModId().equals(dep.getModId())) {
+								it.remove();
+								break;
+							}
+						}
+					}
+				}
+
+				break;
+			case ADD:
+				deps.addAll(entry.values);
+				break;
+			}
+		}
+
+		metadata.setDependencies(deps);
+	}
+
+	public Collection<String> getAffectedModIds() {
+		return dependencyOverrides.keySet();
+	}
+
+	private static final class Entry {
+		final Operation operation;
+		final ModDependency.Kind kind;
+		final List<ModDependency> values;
+
+		Entry(Operation operation, ModDependency.Kind kind, List<ModDependency> values) {
+			this.operation = operation;
+			this.kind = kind;
+			this.values = values;
+		}
+	}
+
+	private enum Operation {
+		ADD("+"),
+		REMOVE("-"),
+		REPLACE(""); // needs to be last to properly match the operator (empty string would match everything)
+
+		static final Operation[] VALUES = values();
+
+		final String operator;
+
+		Operation(String operator) {
+			this.operator = operator;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/EntrypointMetadata.java b/src/main/java/net/fabricmc/loader/impl/metadata/EntrypointMetadata.java
new file mode 100644
index 0000000000000000000000000000000000000000..8fb13b2046f342c1682749b32c5300eb389b006d
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/EntrypointMetadata.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+@SuppressWarnings("deprecation")
+public interface EntrypointMetadata extends net.fabricmc.loader.metadata.EntrypointMetadata {
+	@Override
+	String getAdapter();
+	@Override
+	String getValue();
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/LoaderModMetadata.java b/src/main/java/net/fabricmc/loader/impl/metadata/LoaderModMetadata.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc9ada37cddb59c1e9bbb1f58cbd054e330fb022
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/LoaderModMetadata.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.metadata.ModDependency;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Internal variant of the ModMetadata interface.
+ */
+@SuppressWarnings("deprecation")
+public interface LoaderModMetadata extends net.fabricmc.loader.metadata.LoaderModMetadata {
+	int getSchemaVersion();
+
+	default String getOldStyleLanguageAdapter() {
+		return "net.fabricmc.loader.language.JavaLanguageAdapter";
+	}
+
+	Map<String, String> getLanguageAdapterDefinitions();
+	Collection<NestedJarEntry> getJars();
+	Collection<String> getMixinConfigs(EnvType type);
+	/* @Nullable */
+	String getAccessWidener();
+	@Override
+	boolean loadsInEnvironment(EnvType type);
+
+	Collection<String> getOldInitializers();
+	@Override
+	List<EntrypointMetadata> getEntrypoints(String type);
+	@Override
+	Collection<String> getEntrypointKeys();
+
+	void emitFormatWarnings();
+
+	void setVersion(Version version);
+	void setDependencies(Collection<ModDependency> dependencies);
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/MetadataVerifier.java b/src/main/java/net/fabricmc/loader/impl/metadata/MetadataVerifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..da4f19d11d521d8cd2786d8d828bce55370e7be4
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/MetadataVerifier.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.FabricLoader;
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.discovery.ModCandidate;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.*;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+public final class MetadataVerifier {
+	private static final Pattern MOD_ID_PATTERN = Pattern.compile("[a-z][a-z0-9-_]{1,63}");
+
+	public static ModCandidate verifyIndev(ModCandidate mod) {
+		if (FabricLoaderImpl.INSTANCE.isDevelopmentEnvironment()) {
+			try {
+				MetadataVerifier.verify(mod.getMetadata());
+			} catch (ParseMetadataException e) {
+				e.setModPaths(mod.getLocalPath(), Collections.emptyList());
+				throw new RuntimeException("Invalid mod metadata", e);
+			}
+		}
+
+		return mod;
+	}
+
+	static void verify(LoaderModMetadata metadata) throws ParseMetadataException {
+		checkModId(metadata.getId(), "mod id");
+
+		for (String providesDecl : metadata.getProvides()) {
+			checkModId(providesDecl, "provides declaration");
+		}
+
+		// TODO: verify mod id and version decls in deps
+
+		if (FabricLoader.getInstance().isDevelopmentEnvironment()) {
+			if (metadata.getSchemaVersion() < ModMetadataParser.LATEST_VERSION) {
+				Log.warn(LogCategory.METADATA, "Mod %s uses an outdated schema version: %d < %d", metadata.getId(), metadata.getSchemaVersion(), ModMetadataParser.LATEST_VERSION);
+			}
+		}
+
+		if (!(metadata.getVersion() instanceof SemanticVersion)) {
+			String version = metadata.getVersion().getFriendlyString();
+			Exception exc;
+
+			try {
+				SemanticVersion.parse(version);
+				exc = null;
+			} catch (Exception e) {
+				exc = e;
+			}
+
+			if (exc != null) {
+				Log.warn(LogCategory.METADATA, "Mod %s uses the version %s which isn't compatible with Loader's extended semantic version format (%s), SemVer is recommended for reliably evaluating dependencies and prioritizing newer version",
+						metadata.getId(), version, exc.getMessage());
+			}
+
+			metadata.emitFormatWarnings();
+		}
+	}
+
+	private static void checkModId(String id, String name) throws ParseMetadataException {
+		if (MOD_ID_PATTERN.matcher(id).matches()) return;
+
+		List<String> errorList = new ArrayList<>();
+
+		// A more useful error list for MOD_ID_PATTERN
+		if (id.isEmpty()) {
+			errorList.add("is empty!");
+		} else {
+			if (id.length() == 1) {
+				errorList.add("is only a single character! (It must be at least 2 characters long)!");
+			} else if (id.length() > 64) {
+				errorList.add("has more than 64 characters!");
+			}
+
+			char first = id.charAt(0);
+
+			if (first < 'a' || first > 'z') {
+				errorList.add("starts with an invalid character '" + first + "' (it must be a lowercase a-z - uppercase isn't allowed anywhere in the ID)");
+			}
+
+			Set<Character> invalidChars = null;
+
+			for (int i = 1; i < id.length(); i++) {
+				char c = id.charAt(i);
+
+				if (c == '-' || c == '_' || ('0' <= c && c <= '9') || ('a' <= c && c <= 'z')) {
+					continue;
+				}
+
+				if (invalidChars == null) {
+					invalidChars = new HashSet<>();
+				}
+
+				invalidChars.add(c);
+			}
+
+			if (invalidChars != null) {
+				StringBuilder error = new StringBuilder("contains invalid characters: ");
+				error.append(invalidChars.stream().map(value -> "'" + value + "'").collect(Collectors.joining(", ")));
+				errorList.add(error.append("!").toString());
+			}
+		}
+
+		assert !errorList.isEmpty();
+
+		StringWriter sw = new StringWriter();
+
+		try (PrintWriter pw = new PrintWriter(sw)) {
+			pw.printf("Invalid %s %s:", name, id);
+
+			if (errorList.size() == 1) {
+				pw.printf(" It %s", errorList.get(0));
+			} else {
+				for (String error : errorList) {
+					pw.printf("\n\t- It %s", error);
+				}
+			}
+		}
+
+		throw new ParseMetadataException(sw.toString());
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/ModDependencyImpl.java b/src/main/java/net/fabricmc/loader/impl/metadata/ModDependencyImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd19486d4d291b04c122bae34f56196bd142d655
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/ModDependencyImpl.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.api.metadata.ModDependency;
+import net.fabricmc.loader.api.metadata.version.VersionInterval;
+import net.fabricmc.loader.api.metadata.version.VersionPredicate;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+public final class ModDependencyImpl implements ModDependency {
+	private Kind kind;
+	private final String modId;
+	private final List<String> matcherStringList;
+	private final Collection<VersionPredicate> ranges;
+
+	public ModDependencyImpl(Kind kind, String modId, List<String> matcherStringList) throws Exception {
+		this.kind = kind;
+		this.modId = modId;
+		this.matcherStringList = matcherStringList;
+		this.ranges = VersionPredicate.parse(this.matcherStringList);
+	}
+
+	@Override
+	public Kind getKind() {
+		return kind;
+	}
+
+	public void setKind(Kind kind) {
+		this.kind = kind;
+	}
+
+	@Override
+	public String getModId() {
+		return this.modId;
+	}
+
+	@Override
+	public boolean matches(Version version) {
+		for (VersionPredicate predicate : ranges) {
+			if (predicate.test(version)) return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (!(obj instanceof ModDependency)) return false;
+
+		ModDependency o = (ModDependency) obj;
+
+		return kind == o.getKind()
+				&& modId.equals(o.getModId())
+				&& ranges.equals(o.getVersionRequirements());
+	}
+
+	@Override
+	public int hashCode() {
+		return (kind.ordinal() * 31 + modId.hashCode()) * 257 + ranges.hashCode();
+	}
+
+	@Override
+	public String toString() {
+		final StringBuilder builder = new StringBuilder("{");
+		builder.append(kind.getKey());
+		builder.append(' ');
+		builder.append(this.modId);
+		builder.append(" @ [");
+
+		for (int i = 0; i < matcherStringList.size(); i++) {
+			if (i > 0) {
+				builder.append(" || ");
+			}
+
+			builder.append(matcherStringList.get(i));
+		}
+
+		builder.append("]}");
+		return builder.toString();
+	}
+
+	@Override
+	public Collection<VersionPredicate> getVersionRequirements() {
+		return ranges;
+	}
+
+	@Override
+	public List<VersionInterval> getVersionIntervals() {
+		List<VersionInterval> ret = Collections.emptyList();
+
+		for (VersionPredicate predicate : ranges) {
+			ret = VersionInterval.or(ret, predicate.getInterval());
+		}
+
+		return ret;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/ModMetadataParser.java b/src/main/java/net/fabricmc/loader/impl/metadata/ModMetadataParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..cabee7e624da9fe870a7689b5bb90114013db6a1
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/ModMetadataParser.java
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.FabricLoader;
+import net.fabricmc.loader.impl.lib.gson.JsonReader;
+import net.fabricmc.loader.impl.lib.gson.JsonToken;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+
+public final class ModMetadataParser {
+	public static final int LATEST_VERSION = 1;
+	/**
+	 * Keys that will be ignored by any mod metadata parser.
+	 */
+	public static final Set<String> IGNORED_KEYS = Collections.singleton("$schema");
+
+	// Per the ECMA-404 (www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf), the JSON spec does not prohibit duplicate keys.
+	// For all intents and purposes of replicating the logic of Gson's fromJson before we have migrated to JsonReader, duplicate keys will replace previous entries.
+	public static LoaderModMetadata parseMetadata(InputStream is, String modPath, List<String> modParentPaths,
+			VersionOverrides versionOverrides, DependencyOverrides depOverrides) throws ParseMetadataException {
+		try {
+			LoaderModMetadata ret = readModMetadata(is);
+
+			versionOverrides.apply(ret);
+			depOverrides.apply(ret);
+
+			MetadataVerifier.verify(ret);
+
+			return ret;
+		} catch (ParseMetadataException e) {
+			e.setModPaths(modPath, modParentPaths);
+			throw e;
+		} catch (Throwable t) {
+			ParseMetadataException e = new ParseMetadataException(t);
+			e.setModPaths(modPath, modParentPaths);
+			throw e;
+		}
+	}
+
+	private static LoaderModMetadata readModMetadata(InputStream is) throws IOException, ParseMetadataException {
+		// So some context:
+		// Per the json specification, ordering of fields is not typically enforced.
+		// Furthermore we cannot guarantee the `schemaVersion` is the first field in every `fabric.mod.json`
+		//
+		// To work around this, we do the following:
+		// Try to read first field
+		// If the first field is the schemaVersion, read the file normally.
+		//
+		// If the first field is not the schema version, fallback to a more exhaustive check.
+		// Read the rest of the file, looking for the `schemaVersion` field.
+		// If we find the field, cache the value
+		// If there happens to be another `schemaVersion` that has a differing value, then fail.
+		// At the end, if we find no `schemaVersion` then assume the `schemaVersion` is 0
+		// Re-read the JSON file.
+		int schemaVersion = 0;
+
+		try (JsonReader reader = new JsonReader(new InputStreamReader(is, StandardCharsets.UTF_8))) {
+			reader.setRewindEnabled(true);
+
+			if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+				throw new ParseMetadataException("Root of \"fabric.mod.json\" must be an object", reader);
+			}
+
+			reader.beginObject();
+
+			boolean firstField = true;
+
+			while (reader.hasNext()) {
+				// Try to read the schemaVersion
+				String key = reader.nextName();
+
+				if (key.equals("schemaVersion")) {
+					if (reader.peek() != JsonToken.NUMBER) {
+						throw new ParseMetadataException("\"schemaVersion\" must be a number.", reader);
+					}
+
+					schemaVersion = reader.nextInt();
+
+					if (firstField) {
+						reader.setRewindEnabled(false);
+						// Finish reading the metadata
+						LoaderModMetadata ret = readModMetadata(reader, schemaVersion);
+						reader.endObject();
+
+						return ret;
+					}
+
+					// schemaVersion found, but after some content -> start over to parse all data with the detected version
+					break;
+				} else {
+					reader.skipValue();
+				}
+
+				if (!IGNORED_KEYS.contains(key)) {
+					firstField = false;
+				}
+			}
+
+			// Slow path, schema version wasn't specified early enough, re-read with detected/inferred version
+
+			reader.rewind();
+			reader.setRewindEnabled(false);
+
+			reader.beginObject();
+			LoaderModMetadata ret = readModMetadata(reader, schemaVersion);
+			reader.endObject();
+
+			if (FabricLoader.getInstance().isDevelopmentEnvironment()) {
+				Log.warn(LogCategory.METADATA, "\"fabric.mod.json\" from mod %s did not have \"schemaVersion\" as first field.", ret.getId());
+			}
+
+			return ret;
+		}
+	}
+
+	private static LoaderModMetadata readModMetadata(JsonReader reader, int schemaVersion) throws IOException, ParseMetadataException {
+		switch (schemaVersion) {
+		case 1:
+			return V1ModMetadataParser.parse(reader);
+		case 0:
+			return V0ModMetadataParser.parse(reader);
+		default:
+			if (schemaVersion > 0) {
+				throw new ParseMetadataException(String.format("This version of fabric-loader doesn't support the newer schema version of \"%s\""
+						+ "\nPlease update fabric-loader to be able to read this.", schemaVersion));
+			}
+
+			throw new ParseMetadataException(String.format("Invalid/Unsupported schema version \"%s\" was found", schemaVersion));
+		}
+	}
+
+	static void logWarningMessages(String id, List<ParseWarning> warnings) {
+		if (warnings.isEmpty()) return;
+
+		final StringBuilder message = new StringBuilder();
+
+		message.append(String.format("The mod \"%s\" contains invalid entries in its mod json:", id));
+
+		for (ParseWarning warning : warnings) {
+			message.append(String.format("\n- %s \"%s\" at line %d column %d",
+					warning.getReason(), warning.getKey(), warning.getLine(), warning.getColumn()));
+		}
+
+		Log.warn(LogCategory.METADATA, message.toString());
+	}
+
+	private ModMetadataParser() {
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/ModOriginImpl.java b/src/main/java/net/fabricmc/loader/impl/metadata/ModOriginImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe20652f595b699bb871e2eed35b0acd281cb391
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/ModOriginImpl.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.metadata.ModOrigin;
+
+import java.io.File;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.stream.Collectors;
+
+public final class ModOriginImpl implements ModOrigin {
+	private final Kind kind;
+	private List<Path> paths;
+	private String parentModId;
+	private String parentSubLocation;
+
+	public ModOriginImpl() {
+		this.kind = Kind.UNKNOWN;
+	}
+
+	public ModOriginImpl(List<Path> paths) {
+		this.kind = Kind.PATH;
+		this.paths = paths;
+	}
+
+	public ModOriginImpl(String parentModId, String parentSubLocation) {
+		this.kind = Kind.NESTED;
+		this.parentModId = parentModId;
+		this.parentSubLocation = parentSubLocation;
+	}
+
+	@Override
+	public Kind getKind() {
+		return kind;
+	}
+
+	@Override
+	public List<Path> getPaths() {
+		if (kind != Kind.PATH) throw new UnsupportedOperationException("kind "+kind.name()+" doesn't have paths");
+
+		return paths;
+	}
+
+	@Override
+	public String getParentModId() {
+		if (kind != Kind.NESTED) throw new UnsupportedOperationException("kind "+kind.name()+" doesn't have a parent mod");
+
+		return parentModId;
+	}
+
+	@Override
+	public String getParentSubLocation() {
+		if (kind != Kind.NESTED) throw new UnsupportedOperationException("kind "+kind.name()+" doesn't have a parent sub-location");
+
+		return parentSubLocation;
+	}
+
+	@Override
+	public String toString() {
+		switch (getKind()) {
+		case PATH:
+			return paths.stream().map(Path::toString).collect(Collectors.joining(File.pathSeparator));
+		case NESTED:
+			return String.format("%s:%s", parentModId, parentSubLocation);
+		default:
+			return "unknown";
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/NestedJarEntry.java b/src/main/java/net/fabricmc/loader/impl/metadata/NestedJarEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..fde1a4512801f0b087f66e9710d31b0f5103dedb
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/NestedJarEntry.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+public interface NestedJarEntry {
+	String getFile();
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/ParseMetadataException.java b/src/main/java/net/fabricmc/loader/impl/metadata/ParseMetadataException.java
new file mode 100644
index 0000000000000000000000000000000000000000..3bef9bb492acbb312ce5ae63966a00247ae74aa3
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/ParseMetadataException.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.impl.lib.gson.JsonReader;
+
+import java.util.ArrayList;
+import java.util.List;
+
+@SuppressWarnings("serial")
+public class ParseMetadataException extends Exception {
+	private List<String> modPaths;
+
+	public ParseMetadataException(String message) {
+		super(message);
+	}
+
+	public ParseMetadataException(String message, JsonReader reader) {
+		this(message + " Error was located at: " + reader.locationString());
+	}
+
+	public ParseMetadataException(String message, Throwable throwable) {
+		super(message, throwable);
+	}
+
+	public ParseMetadataException(Throwable t) {
+		super(t);
+	}
+
+	public void setModPaths(String modPath, List<String> modParentPaths) {
+		modPaths = new ArrayList<>(modParentPaths);
+		modPaths.add(modPath);
+	}
+
+	@Override
+	public String getMessage() {
+		String ret = "Error reading fabric.mod.json file for mod at ";
+
+		if (modPaths == null) {
+			ret += "unknown location";
+		} else {
+			ret += String.join(" -> ", modPaths);
+		}
+
+		String msg = super.getMessage();
+
+		if (msg != null) {
+			ret += ": "+msg;
+		}
+
+		return ret;
+	}
+
+	public static class MissingField extends ParseMetadataException {
+		public MissingField(String field) {
+			super(String.format("Missing required field \"%s\".", field));
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/ParseWarning.java b/src/main/java/net/fabricmc/loader/impl/metadata/ParseWarning.java
new file mode 100644
index 0000000000000000000000000000000000000000..035659a39ccbd5c0131da08bc71691b7e09481b2
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/ParseWarning.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+final class ParseWarning {
+	private final int line;
+	private final int column;
+	private final String key;
+	private final String reason;
+
+	ParseWarning(int line, int column, String key) {
+		this(line, column, key, null);
+	}
+
+	ParseWarning(int line, int column, String key, /* @Nullable */ String reason) {
+		this.line = line;
+		this.column = column;
+		this.key = key;
+		this.reason = reason;
+	}
+
+	public int getLine() {
+		return this.line;
+	}
+
+	public int getColumn() {
+		return this.column;
+	}
+
+	public String getKey() {
+		return this.key;
+	}
+
+	public String getReason() {
+		return this.reason;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/SimplePerson.java b/src/main/java/net/fabricmc/loader/impl/metadata/SimplePerson.java
new file mode 100644
index 0000000000000000000000000000000000000000..b183c6c31b31f70208bad890c1394d2107ac893b
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/SimplePerson.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.metadata.ContactInformation;
+import net.fabricmc.loader.api.metadata.Person;
+
+/**
+ * Represents a simple implementation of person which is only identified by name.
+ */
+class SimplePerson implements Person {
+	private final String name;
+
+	SimplePerson(String name) {
+		this.name = name;
+	}
+
+	@Override
+	public String getName() {
+		return this.name;
+	}
+
+	@Override
+	public ContactInformation getContact() {
+		return ContactInformation.EMPTY;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/V0ModMetadata.java b/src/main/java/net/fabricmc/loader/impl/metadata/V0ModMetadata.java
new file mode 100644
index 0000000000000000000000000000000000000000..1a469b064df1237b17466ee0fadd03f90c37e4ea
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/V0ModMetadata.java
@@ -0,0 +1,256 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.metadata.*;
+
+import java.util.*;
+
+final class V0ModMetadata extends AbstractModMetadata implements LoaderModMetadata {
+	private static final Mixins EMPTY_MIXINS = new Mixins(Collections.emptyList(), Collections.emptyList(), Collections.emptyList());
+	// Required
+	private final String id;
+	private Version version;
+
+	// Optional (Environment)
+	private Collection<ModDependency> dependencies;
+	private final String languageAdapter = "net.fabricmc.loader.language.JavaLanguageAdapter"; // TODO: Constants class?
+	private final Mixins mixins;
+	private final ModEnvironment environment; // REMOVEME: Replacing Side in old metadata with this
+	private final String initializer;
+	private final Collection<String> initializers;
+
+	// Optional (metadata)
+	private final String name;
+	private final String description;
+	private final Collection<Person> authors;
+	private final Collection<Person> contributors;
+	private final ContactInformation links;
+	private final String license;
+
+	V0ModMetadata(String id, Version version, Collection<ModDependency> dependencies, Mixins mixins, ModEnvironment environment, String initializer, Collection<String> initializers,
+			String name, String description, Collection<Person> authors, Collection<Person> contributors, ContactInformation links, String license) {
+		this.id = id;
+		this.version = version;
+		this.dependencies = Collections.unmodifiableCollection(dependencies);
+
+		if (mixins == null) {
+			this.mixins = V0ModMetadata.EMPTY_MIXINS;
+		} else {
+			this.mixins = mixins;
+		}
+
+		this.environment = environment;
+		this.initializer = initializer;
+		this.initializers = Collections.unmodifiableCollection(initializers);
+		this.name = name;
+
+		if (description == null) {
+			this.description = "";
+		} else {
+			this.description = description;
+		}
+
+		this.authors = Collections.unmodifiableCollection(authors);
+		this.contributors = Collections.unmodifiableCollection(contributors);
+		this.links = links;
+		this.license = license;
+	}
+
+	@Override
+	public int getSchemaVersion() {
+		return 0;
+	}
+
+	@Override
+	public String getType() {
+		return TYPE_FABRIC_MOD;
+	}
+
+	@Override
+	public String getId() {
+		return this.id;
+	}
+
+	@Override
+	public Collection<String> getProvides() {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public Version getVersion() {
+		return this.version;
+	}
+
+	@Override
+	public void setVersion(Version version) {
+		this.version = version;
+	}
+
+	@Override
+	public ModEnvironment getEnvironment() {
+		return this.environment;
+	}
+
+	@Override
+	public boolean loadsInEnvironment(EnvType type) {
+		return this.environment.matches(type);
+	}
+
+	@Override
+	public Collection<ModDependency> getDependencies() {
+		return dependencies;
+	}
+
+	@Override
+	public void setDependencies(Collection<ModDependency> dependencies) {
+		this.dependencies = Collections.unmodifiableCollection(dependencies);
+	}
+
+	// General metadata
+
+	@Override
+	public String getName() {
+		if (this.name != null && this.name.isEmpty()) {
+			return this.id;
+		}
+
+		return this.name;
+	}
+
+	@Override
+	public String getDescription() {
+		return this.description;
+	}
+
+	@Override
+	public Collection<Person> getAuthors() {
+		return this.authors;
+	}
+
+	@Override
+	public Collection<Person> getContributors() {
+		return this.contributors;
+	}
+
+	@Override
+	public ContactInformation getContact() {
+		return this.links;
+	}
+
+	@Override
+	public Collection<String> getLicense() {
+		return Collections.singleton(this.license);
+	}
+
+	@Override
+	public Optional<String> getIconPath(int size) {
+		// honor Mod Menu's de-facto standard
+		return Optional.of("assets/" + getId() + "/icon.png");
+	}
+
+	@Override
+	public String getOldStyleLanguageAdapter() {
+		return this.languageAdapter;
+	}
+
+	@Override
+	public Map<String, CustomValue> getCustomValues() {
+		return Collections.emptyMap();
+	}
+
+	@Override
+	public boolean containsCustomValue(String key) {
+		return false;
+	}
+
+	@Override
+	public CustomValue getCustomValue(String key) {
+		return null;
+	}
+
+	// Internals
+
+	@Override
+	public Map<String, String> getLanguageAdapterDefinitions() {
+		return Collections.emptyMap();
+	}
+
+	@Override
+	public Collection<NestedJarEntry> getJars() {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public Collection<String> getOldInitializers() {
+		if (this.initializer != null) {
+			return Collections.singletonList(this.initializer);
+		} else if (!this.initializers.isEmpty()) {
+			return this.initializers;
+		} else {
+			return Collections.emptyList();
+		}
+	}
+
+	@Override
+	public List<EntrypointMetadata> getEntrypoints(String type) {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public Collection<String> getEntrypointKeys() {
+		return Collections.emptyList();
+	}
+
+	@Override
+	public void emitFormatWarnings() { }
+
+	@Override
+	public Collection<String> getMixinConfigs(EnvType type) {
+		List<String> mixinConfigs = new ArrayList<>(this.mixins.common);
+
+		switch (type) {
+		case CLIENT:
+			mixinConfigs.addAll(this.mixins.client);
+			break;
+		case SERVER:
+			mixinConfigs.addAll(this.mixins.server);
+			break;
+		}
+
+		return mixinConfigs;
+	}
+
+	@Override
+	public String getAccessWidener() {
+		return null; // intentional null
+	}
+
+	static final class Mixins {
+		final Collection<String> client;
+		final Collection<String> common;
+		final Collection<String> server;
+
+		Mixins(Collection<String> client, Collection<String> common, Collection<String> server) {
+			this.client = Collections.unmodifiableCollection(client);
+			this.common = Collections.unmodifiableCollection(common);
+			this.server = Collections.unmodifiableCollection(server);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/V0ModMetadataParser.java b/src/main/java/net/fabricmc/loader/impl/metadata/V0ModMetadataParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e0c4597e8dfa69b3443b0fb967a64cdb22aafbd
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/V0ModMetadataParser.java
@@ -0,0 +1,458 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.api.metadata.ContactInformation;
+import net.fabricmc.loader.api.metadata.ModDependency;
+import net.fabricmc.loader.api.metadata.ModEnvironment;
+import net.fabricmc.loader.api.metadata.Person;
+import net.fabricmc.loader.impl.lib.gson.JsonReader;
+import net.fabricmc.loader.impl.lib.gson.JsonToken;
+import net.fabricmc.loader.impl.util.version.VersionParser;
+
+import java.io.IOException;
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+final class V0ModMetadataParser {
+	private static final Pattern WEBSITE_PATTERN = Pattern.compile("\\((.+)\\)");
+	private static final Pattern EMAIL_PATTERN = Pattern.compile("<(.+)>");
+
+	public static LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException {
+		List<ParseWarning> warnings = new ArrayList<>();
+
+		// All the values the `fabric.mod.json` may contain:
+		// Required
+		String id = null;
+		Version version = null;
+
+		// Optional (mod loading)
+		List<ModDependency> dependencies = new ArrayList<>();
+		V0ModMetadata.Mixins mixins = null;
+		ModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal
+		String initializer = null;
+		List<String> initializers = new ArrayList<>();
+
+		String name = null;
+		String description = null;
+		List<Person> authors = new ArrayList<>();
+		List<Person> contributors = new ArrayList<>();
+		ContactInformation links = null;
+		String license = null;
+
+		while (reader.hasNext()) {
+			final String key = reader.nextName();
+
+			switch (key) {
+			case "schemaVersion":
+				// Duplicate field, make sure it matches our current schema version
+				if (reader.peek() != JsonToken.NUMBER) {
+					throw new ParseMetadataException("Duplicate \"schemaVersion\" field is not a number", reader);
+				}
+
+				final int read = reader.nextInt();
+
+				if (read != 0) {
+					throw new ParseMetadataException(String.format("Duplicate \"schemaVersion\" field does not match the predicted schema version of 0. Duplicate field value is %s", read), reader);
+				}
+
+				break;
+			case "id":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Mod id must be a non-empty string with a length of 3-64 characters.", reader);
+				}
+
+				id = reader.nextString();
+				break;
+			case "version":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Version must be a non-empty string", reader);
+				}
+
+				final String rawVersion = reader.nextString();
+
+				try {
+					version = VersionParser.parse(rawVersion, false);
+				} catch (Exception e) {
+					throw new ParseMetadataException(String.format("Failed to parse version: %s", rawVersion), e);
+				}
+
+				break;
+			case "requires":
+				readDependenciesContainer(reader, ModDependency.Kind.DEPENDS, dependencies, "requires");
+				break;
+			case "conflicts":
+				readDependenciesContainer(reader, ModDependency.Kind.BREAKS, dependencies, "conflicts");
+				break;
+			case "mixins":
+				mixins = readMixins(warnings, reader);
+				break;
+			case "side":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Side must be a string", reader);
+				}
+
+				final String rawEnvironment = reader.nextString();
+
+				switch (rawEnvironment) {
+				case "universal":
+					environment = ModEnvironment.UNIVERSAL;
+					break;
+				case "client":
+					environment = ModEnvironment.CLIENT;
+					break;
+				case "server":
+					environment = ModEnvironment.SERVER;
+					break;
+				default:
+					warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), rawEnvironment, "Invalid side type"));
+				}
+
+				break;
+			case "initializer":
+				// `initializer` and `initializers` cannot be used at the same time
+				if (!initializers.isEmpty()) {
+					throw new ParseMetadataException("initializer and initializers should not be set at the same time! (mod ID '" + id + "')");
+				}
+
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Initializer must be a non-empty string", reader);
+				}
+
+				initializer = reader.nextString();
+				break;
+			case "initializers":
+				// `initializer` and `initializers` cannot be used at the same time
+				if (initializer != null) {
+					throw new ParseMetadataException("initializer and initializers should not be set at the same time! (mod ID '" + id + "')");
+				}
+
+				if (reader.peek() != JsonToken.BEGIN_ARRAY) {
+					throw new ParseMetadataException("Initializers must be in a list", reader);
+				}
+
+				reader.beginArray();
+
+				while (reader.hasNext()) {
+					if (reader.peek() != JsonToken.STRING) {
+						throw new ParseMetadataException("Initializer in initializers list must be a string", reader);
+					}
+
+					initializers.add(reader.nextString());
+				}
+
+				reader.endArray();
+
+				break;
+			case "name":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Name must be a string", reader);
+				}
+
+				name = reader.nextString();
+				break;
+			case "description":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Mod description must be a string", reader);
+				}
+
+				description = reader.nextString();
+				break;
+			case "recommends":
+				readDependenciesContainer(reader, ModDependency.Kind.SUGGESTS, dependencies, "recommends");
+				break;
+			case "authors":
+				readPeople(warnings, reader, authors);
+				break;
+			case "contributors":
+				readPeople(warnings, reader, contributors);
+				break;
+			case "links":
+				links = readLinks(warnings, reader);
+				break;
+			case "license":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("License name must be a string", reader);
+				}
+
+				license = reader.nextString();
+				break;
+			default:
+				if (!ModMetadataParser.IGNORED_KEYS.contains(key)) {
+					warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), key, "Unsupported root entry"));
+				}
+
+				reader.skipValue();
+				break;
+			}
+		}
+
+		// Validate all required fields are resolved
+		if (id == null) {
+			throw new ParseMetadataException.MissingField("id");
+		}
+
+		if (version == null) {
+			throw new ParseMetadataException.MissingField("version");
+		}
+
+		ModMetadataParser.logWarningMessages(id, warnings);
+
+		// Optional stuff
+		if (links == null) {
+			links = ContactInformation.EMPTY;
+		}
+
+		return new V0ModMetadata(id, version, dependencies, mixins, environment, initializer, initializers, name, description, authors, contributors, links, license);
+	}
+
+	private static ContactInformation readLinks(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {
+		final Map<String, String> contactInfo = new HashMap<>();
+
+		switch (reader.peek()) {
+		case STRING:
+			contactInfo.put("homepage", reader.nextString());
+			break;
+		case BEGIN_OBJECT:
+			reader.beginObject();
+
+			while (reader.hasNext()) {
+				final String key = reader.nextName();
+
+				switch (key) {
+				case "homepage":
+					if (reader.peek() != JsonToken.STRING) {
+						throw new ParseMetadataException("homepage link must be a string", reader);
+					}
+
+					contactInfo.put("homepage", reader.nextString());
+					break;
+				case "issues":
+					if (reader.peek() != JsonToken.STRING) {
+						throw new ParseMetadataException("issues link must be a string", reader);
+					}
+
+					contactInfo.put("issues", reader.nextString());
+					break;
+				case "sources":
+					if (reader.peek() != JsonToken.STRING) {
+						throw new ParseMetadataException("sources link must be a string", reader);
+					}
+
+					contactInfo.put("sources", reader.nextString());
+					break;
+				default:
+					warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), key, "Unsupported links entry"));
+					reader.skipValue();
+				}
+			}
+
+			reader.endObject();
+			break;
+		default:
+			throw new ParseMetadataException("Expected links to be an object or string", reader);
+		}
+
+		return new ContactInformationImpl(contactInfo);
+	}
+
+	private static V0ModMetadata.Mixins readMixins(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {
+		final List<String> client = new ArrayList<>();
+		final List<String> common = new ArrayList<>();
+		final List<String> server = new ArrayList<>();
+
+		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+			throw new ParseMetadataException("Expected mixins to be an object.", reader);
+		}
+
+		reader.beginObject();
+
+		while (reader.hasNext()) {
+			final String environment = reader.nextName();
+
+			switch (environment) {
+			case "client":
+				client.addAll(readStringArray(reader, "client"));
+				break;
+			case "common":
+				common.addAll(readStringArray(reader, "common"));
+				break;
+			case "server":
+				server.addAll(readStringArray(reader, "server"));
+				break;
+			default:
+				warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), environment, "Invalid environment type"));
+				reader.skipValue();
+			}
+		}
+
+		reader.endObject();
+		return new V0ModMetadata.Mixins(client, common, server);
+	}
+
+	private static List<String> readStringArray(JsonReader reader, String key) throws IOException, ParseMetadataException {
+		switch (reader.peek()) {
+		case NULL:
+			reader.nextNull();
+			return Collections.emptyList();
+		case STRING:
+			return Collections.singletonList(reader.nextString());
+		case BEGIN_ARRAY:
+			reader.beginArray();
+			final List<String> list = new ArrayList<>();
+
+			while (reader.hasNext()) {
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException(String.format("Expected entries in %s to be an array of strings", key), reader);
+				}
+
+				list.add(reader.nextString());
+			}
+
+			reader.endArray();
+			return list;
+		default:
+			throw new ParseMetadataException(String.format("Expected %s to be a string or an array of strings", key), reader);
+		}
+	}
+
+	private static void readDependenciesContainer(JsonReader reader, ModDependency.Kind kind, List<ModDependency> dependencies, String name) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+			throw new ParseMetadataException(String.format("%s must be an object containing dependencies.", name), reader);
+		}
+
+		reader.beginObject();
+
+		while (reader.hasNext()) {
+			final String modId = reader.nextName();
+			final List<String> versionMatchers = new ArrayList<>();
+
+			switch (reader.peek()) {
+			case STRING:
+				versionMatchers.add(reader.nextString());
+				break;
+			case BEGIN_ARRAY:
+				reader.beginArray();
+
+				while (reader.hasNext()) {
+					if (reader.peek() != JsonToken.STRING) {
+						throw new ParseMetadataException("List of version requirements must be strings", reader);
+					}
+
+					versionMatchers.add(reader.nextString());
+				}
+
+				reader.endArray();
+				break;
+			default:
+				throw new ParseMetadataException("Expected version to be a string or array", reader);
+			}
+
+			try {
+				dependencies.add(new ModDependencyImpl(kind, modId, versionMatchers));
+			} catch (Exception e) {
+				throw new ParseMetadataException(e);
+			}
+		}
+
+		reader.endObject();
+	}
+
+	private static void readPeople(List<ParseWarning> warnings, JsonReader reader, List<Person> people) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_ARRAY) {
+			throw new ParseMetadataException("List of people must be an array", reader);
+		}
+
+		reader.beginArray();
+
+		while (reader.hasNext()) {
+			people.add(readPerson(warnings, reader));
+		}
+
+		reader.endArray();
+	}
+
+	private static Person readPerson(List<ParseWarning> warnings, JsonReader reader) throws IOException, ParseMetadataException {
+		final HashMap<String, String> contactMap = new HashMap<>();
+		String name = "";
+
+		switch (reader.peek()) {
+		case STRING:
+			final String person = reader.nextString();
+			String[] parts = person.split(" ");
+
+			Matcher websiteMatcher = V0ModMetadataParser.WEBSITE_PATTERN.matcher(parts[parts.length - 1]);
+
+			if (websiteMatcher.matches()) {
+				contactMap.put("website", websiteMatcher.group(1));
+				parts = Arrays.copyOf(parts, parts.length - 1);
+			}
+
+			Matcher emailMatcher = V0ModMetadataParser.EMAIL_PATTERN.matcher(parts[parts.length - 1]);
+
+			if (emailMatcher.matches()) {
+				contactMap.put("email", emailMatcher.group(1));
+				parts = Arrays.copyOf(parts, parts.length - 1);
+			}
+
+			name = String.join(" ", parts);
+
+			return new ContactInfoBackedPerson(name, new ContactInformationImpl(contactMap));
+		case BEGIN_OBJECT:
+			reader.beginObject();
+
+			while (reader.hasNext()) {
+				final String key = reader.nextName();
+
+				switch (key) {
+				case "name":
+					if (reader.peek() != JsonToken.STRING) {
+						break;
+					}
+
+					name = reader.nextString();
+					break;
+				case "email":
+					if (reader.peek() != JsonToken.STRING) {
+						break;
+					}
+
+					contactMap.put("email", reader.nextString());
+					break;
+				case "website":
+					if (reader.peek() != JsonToken.STRING) {
+						break;
+					}
+
+					contactMap.put("website", reader.nextString());
+					break;
+				default:
+					warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), key, "Unsupported contact information entry"));
+					reader.skipValue();
+				}
+			}
+
+			reader.endObject();
+			return new ContactInfoBackedPerson(name, new ContactInformationImpl(contactMap));
+		default:
+			throw new ParseMetadataException("Expected person to be a string or object", reader);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/V1ModMetadata.java b/src/main/java/net/fabricmc/loader/impl/metadata/V1ModMetadata.java
new file mode 100644
index 0000000000000000000000000000000000000000..1147d26d4db8b8de4f8ce19efb4244fe5b346cc3
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/V1ModMetadata.java
@@ -0,0 +1,355 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.metadata.*;
+import net.fabricmc.loader.impl.util.log.Log;
+import net.fabricmc.loader.impl.util.log.LogCategory;
+
+import java.util.*;
+
+final class V1ModMetadata extends AbstractModMetadata implements LoaderModMetadata {
+	static final IconEntry NO_ICON = size -> Optional.empty();
+
+	// Required values
+	private final String id;
+	private Version version;
+
+	// Optional (id provides)
+	private final Collection<String> provides;
+
+	// Optional (mod loading)
+	private final ModEnvironment environment;
+	private final Map<String, List<EntrypointMetadata>> entrypoints;
+	private final Collection<NestedJarEntry> jars;
+	private final Collection<MixinEntry> mixins;
+	/* @Nullable */
+	private final String accessWidener;
+
+	// Optional (dependency resolution)
+	private Collection<ModDependency> dependencies;
+	// Happy little accidents
+	private final boolean hasRequires;
+
+	// Optional (metadata)
+	/* @Nullable */
+	private final String name;
+	private final String description;
+	private final Collection<Person> authors;
+	private final Collection<Person> contributors;
+	private final ContactInformation contact;
+	private final Collection<String> license;
+	private final IconEntry icon;
+
+	// Optional (language adapter providers)
+	private final Map<String, String> languageAdapters;
+
+	// Optional (custom values)
+	private final Map<String, CustomValue> customValues;
+
+	V1ModMetadata(String id, Version version, Collection<String> provides,
+			ModEnvironment environment, Map<String, List<EntrypointMetadata>> entrypoints, Collection<NestedJarEntry> jars,
+			Collection<MixinEntry> mixins, /* @Nullable */ String accessWidener,
+			Collection<ModDependency> dependencies, boolean hasRequires,
+			/* @Nullable */ String name, /* @Nullable */String description,
+			Collection<Person> authors, Collection<Person> contributors, /* @Nullable */ContactInformation contact, Collection<String> license, IconEntry icon,
+			Map<String, String> languageAdapters,
+			Map<String, CustomValue> customValues) {
+		this.id = id;
+		this.version = version;
+		this.provides = Collections.unmodifiableCollection(provides);
+		this.environment = environment;
+		this.entrypoints = Collections.unmodifiableMap(entrypoints);
+		this.jars = Collections.unmodifiableCollection(jars);
+		this.mixins = Collections.unmodifiableCollection(mixins);
+		this.accessWidener = accessWidener;
+		this.dependencies = Collections.unmodifiableCollection(dependencies);
+		this.hasRequires = hasRequires;
+		this.name = name;
+
+		// Empty description if not specified
+		if (description != null) {
+			this.description = description;
+		} else {
+			this.description = "";
+		}
+
+		this.authors = Collections.unmodifiableCollection(authors);
+		this.contributors = Collections.unmodifiableCollection(contributors);
+
+		if (contact != null) {
+			this.contact = contact;
+		} else {
+			this.contact = ContactInformation.EMPTY;
+		}
+
+		this.license = Collections.unmodifiableCollection(license);
+
+		if (icon != null) {
+			this.icon = icon;
+		} else {
+			this.icon = V1ModMetadata.NO_ICON;
+		}
+
+		this.languageAdapters = Collections.unmodifiableMap(languageAdapters);
+		this.customValues = Collections.unmodifiableMap(customValues);
+	}
+
+	@Override
+	public int getSchemaVersion() {
+		return 1;
+	}
+
+	@Override
+	public String getType() {
+		return TYPE_FABRIC_MOD; // Fabric Mod
+	}
+
+	@Override
+	public String getId() {
+		return this.id;
+	}
+
+	@Override
+	public Collection<String> getProvides() {
+		return this.provides;
+	}
+
+	@Override
+	public Version getVersion() {
+		return this.version;
+	}
+
+	@Override
+	public void setVersion(Version version) {
+		this.version = version;
+	}
+
+	@Override
+	public ModEnvironment getEnvironment() {
+		return this.environment;
+	}
+
+	@Override
+	public boolean loadsInEnvironment(EnvType type) {
+		return this.environment.matches(type);
+	}
+
+	@Override
+	public Collection<ModDependency> getDependencies() {
+		return dependencies;
+	}
+
+	@Override
+	public void setDependencies(Collection<ModDependency> dependencies) {
+		this.dependencies = Collections.unmodifiableCollection(dependencies);
+	}
+
+	// General metadata
+
+	@Override
+	public String getName() {
+		if (this.name == null || this.name.isEmpty()) {
+			return this.id;
+		}
+
+		return this.name;
+	}
+
+	@Override
+	public String getDescription() {
+		return this.description;
+	}
+
+	@Override
+	public Collection<Person> getAuthors() {
+		return this.authors;
+	}
+
+	@Override
+	public Collection<Person> getContributors() {
+		return this.contributors;
+	}
+
+	@Override
+	public ContactInformation getContact() {
+		return this.contact;
+	}
+
+	@Override
+	public Collection<String> getLicense() {
+		return this.license;
+	}
+
+	@Override
+	public Optional<String> getIconPath(int size) {
+		return this.icon.getIconPath(size);
+	}
+
+	@Override
+	public Map<String, CustomValue> getCustomValues() {
+		return this.customValues;
+	}
+
+	// Internal stuff
+
+	@Override
+	public Map<String, String> getLanguageAdapterDefinitions() {
+		return this.languageAdapters;
+	}
+
+	@Override
+	public Collection<NestedJarEntry> getJars() {
+		return this.jars;
+	}
+
+	@Override
+	public Collection<String> getMixinConfigs(EnvType type) {
+		final List<String> mixinConfigs = new ArrayList<>();
+
+		// This is only ever called once, so no need to store the result of this.
+		for (MixinEntry mixin : this.mixins) {
+			if (mixin.environment.matches(type)) {
+				mixinConfigs.add(mixin.config);
+			}
+		}
+
+		return mixinConfigs;
+	}
+
+	@Override
+	public String getAccessWidener() {
+		return this.accessWidener;
+	}
+
+	@Override
+	public Collection<String> getOldInitializers() {
+		return Collections.emptyList(); // Not applicable in V1
+	}
+
+	@Override
+	public List<EntrypointMetadata> getEntrypoints(String type) {
+		if (type == null) {
+			return Collections.emptyList();
+		}
+
+		final List<EntrypointMetadata> entrypoints = this.entrypoints.get(type);
+
+		if (entrypoints != null) {
+			return entrypoints;
+		}
+
+		return Collections.emptyList();
+	}
+
+	@Override
+	public Collection<String> getEntrypointKeys() {
+		return this.entrypoints.keySet();
+	}
+
+	@Override
+	public void emitFormatWarnings() {
+		if (hasRequires) {
+			Log.warn(LogCategory.METADATA, "Mod `%s` (%s) uses 'requires' key in fabric.mod.json, which is not supported - use 'depends'", this.id, this.version);
+		}
+	}
+
+	static final class EntrypointMetadataImpl implements EntrypointMetadata {
+		private final String adapter;
+		private final String value;
+
+		EntrypointMetadataImpl(String adapter, String value) {
+			this.adapter = adapter;
+			this.value = value;
+		}
+
+		@Override
+		public String getAdapter() {
+			return this.adapter;
+		}
+
+		@Override
+		public String getValue() {
+			return this.value;
+		}
+	}
+
+	static final class JarEntry implements NestedJarEntry {
+		private final String file;
+
+		JarEntry(String file) {
+			this.file = file;
+		}
+
+		@Override
+		public String getFile() {
+			return this.file;
+		}
+	}
+
+	static final class MixinEntry {
+		private final String config;
+		private final ModEnvironment environment;
+
+		MixinEntry(String config, ModEnvironment environment) {
+			this.config = config;
+			this.environment = environment;
+		}
+	}
+
+	interface IconEntry {
+		Optional<String> getIconPath(int size);
+	}
+
+	static final class Single implements IconEntry {
+		private final String icon;
+
+		Single(String icon) {
+			this.icon = icon;
+		}
+
+		@Override
+		public Optional<String> getIconPath(int size) {
+			return Optional.of(this.icon);
+		}
+	}
+
+	static final class MapEntry implements IconEntry {
+		private final SortedMap<Integer, String> icons;
+
+		MapEntry(SortedMap<Integer, String> icons) {
+			this.icons = icons;
+		}
+
+		@Override
+		public Optional<String> getIconPath(int size) {
+			int iconValue = -1;
+
+			for (int i : icons.keySet()) {
+				iconValue = i;
+
+				if (iconValue >= size) {
+					break;
+				}
+			}
+
+			return Optional.of(icons.get(iconValue));
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/V1ModMetadataParser.java b/src/main/java/net/fabricmc/loader/impl/metadata/V1ModMetadataParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..45bf6eaaebdeba02561f46fb113ffae78f977a74
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/V1ModMetadataParser.java
@@ -0,0 +1,653 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.api.metadata.*;
+import net.fabricmc.loader.impl.lib.gson.JsonReader;
+import net.fabricmc.loader.impl.lib.gson.JsonToken;
+import net.fabricmc.loader.impl.util.version.VersionParser;
+
+import java.io.IOException;
+import java.util.*;
+
+final class V1ModMetadataParser {
+	/**
+	 * Reads a {@code fabric.mod.json} file of schema version {@code 1}.
+	 *
+	 * @param reader the json reader to read the file with
+	 * @return the metadata of this file, null if the file could not be parsed
+	 * @throws IOException         if there was any issue reading the file
+	 */
+	static LoaderModMetadata parse(JsonReader reader) throws IOException, ParseMetadataException {
+		List<ParseWarning> warnings = new ArrayList<>();
+
+		// All the values the `fabric.mod.json` may contain:
+		// Required
+		String id = null;
+		Version version = null;
+
+		// Optional (id provides)
+		List<String> provides = new ArrayList<>();
+
+		// Optional (mod loading)
+		ModEnvironment environment = ModEnvironment.UNIVERSAL; // Default is always universal
+		Map<String, List<EntrypointMetadata>> entrypoints = new HashMap<>();
+		List<NestedJarEntry> jars = new ArrayList<>();
+		List<V1ModMetadata.MixinEntry> mixins = new ArrayList<>();
+		String accessWidener = null;
+
+		// Optional (dependency resolution)
+		List<ModDependency> dependencies = new ArrayList<>();
+		// Happy little accidents
+		boolean hasRequires = false;
+
+		// Optional (metadata)
+		String name = null;
+		String description = null;
+		List<Person> authors = new ArrayList<>();
+		List<Person> contributors = new ArrayList<>();
+		ContactInformation contact = null;
+		List<String> license = new ArrayList<>();
+		V1ModMetadata.IconEntry icon = null;
+
+		// Optional (language adapter providers)
+		Map<String, String> languageAdapters = new HashMap<>();
+
+		// Optional (custom values)
+		Map<String, CustomValue> customValues = new HashMap<>();
+
+		while (reader.hasNext()) {
+			final String key = reader.nextName();
+
+			// Work our way from required to entirely optional
+			switch (key) {
+			case "schemaVersion":
+				// Duplicate field, make sure it matches our current schema version
+				if (reader.peek() != JsonToken.NUMBER) {
+					throw new ParseMetadataException("Duplicate \"schemaVersion\" field is not a number", reader);
+				}
+
+				final int read = reader.nextInt();
+
+				if (read != 1) {
+					throw new ParseMetadataException(String.format("Duplicate \"schemaVersion\" field does not match the predicted schema version of 1. Duplicate field value is %s", read), reader);
+				}
+
+				break;
+			case "id":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Mod id must be a non-empty string with a length of 3-64 characters.", reader);
+				}
+
+				id = reader.nextString();
+				break;
+			case "version":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Version must be a non-empty string", reader);
+				}
+
+				try {
+					version = VersionParser.parse(reader.nextString(), false);
+				} catch (Exception e) {
+					throw new ParseMetadataException("Failed to parse version", e);
+				}
+
+				break;
+			case "provides":
+				readProvides(reader, provides);
+				break;
+			case "environment":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Environment must be a string", reader);
+				}
+
+				environment = readEnvironment(reader);
+				break;
+			case "entrypoints":
+				readEntrypoints(warnings, reader, entrypoints);
+				break;
+			case "jars":
+				readNestedJarEntries(warnings, reader, jars);
+				break;
+			case "mixins":
+				readMixinConfigs(warnings, reader, mixins);
+				break;
+			case "accessWidener":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Access Widener file must be a string", reader);
+				}
+
+				accessWidener = reader.nextString();
+				break;
+			case "depends":
+				readDependenciesContainer(reader, ModDependency.Kind.DEPENDS, dependencies);
+				break;
+			case "recommends":
+				readDependenciesContainer(reader, ModDependency.Kind.RECOMMENDS, dependencies);
+				break;
+			case "suggests":
+				readDependenciesContainer(reader, ModDependency.Kind.SUGGESTS, dependencies);
+				break;
+			case "conflicts":
+				readDependenciesContainer(reader, ModDependency.Kind.CONFLICTS, dependencies);
+				break;
+			case "breaks":
+				readDependenciesContainer(reader, ModDependency.Kind.BREAKS, dependencies);
+				break;
+			case "requires":
+				hasRequires = true;
+				reader.skipValue();
+				break;
+			case "name":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Mod name must be a string", reader);
+				}
+
+				name = reader.nextString();
+				break;
+			case "description":
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Mod description must be a string", reader);
+				}
+
+				description = reader.nextString();
+				break;
+			case "authors":
+				readPeople(warnings, reader, authors);
+				break;
+			case "contributors":
+				readPeople(warnings, reader, contributors);
+				break;
+			case "contact":
+				contact = readContactInfo(reader);
+				break;
+			case "license":
+				readLicense(reader, license);
+				break;
+			case "icon":
+				icon = readIcon(reader);
+				break;
+			case "languageAdapters":
+				readLanguageAdapters(reader, languageAdapters);
+				break;
+			case "custom":
+				readCustomValues(reader, customValues);
+				break;
+			default:
+				if (!ModMetadataParser.IGNORED_KEYS.contains(key)) {
+					warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), key, "Unsupported root entry"));
+				}
+
+				reader.skipValue();
+				break;
+			}
+		}
+
+		// Validate all required fields are resolved
+		if (id == null) {
+			throw new ParseMetadataException.MissingField("id");
+		}
+
+		if (version == null) {
+			throw new ParseMetadataException.MissingField("version");
+		}
+
+		ModMetadataParser.logWarningMessages(id, warnings);
+
+		return new V1ModMetadata(id, version, provides,
+				environment, entrypoints, jars, mixins, accessWidener,
+				dependencies, hasRequires,
+				name, description, authors, contributors, contact, license, icon, languageAdapters, customValues);
+	}
+
+	private static void readProvides(JsonReader reader, List<String> provides) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_ARRAY) {
+			throw new ParseMetadataException("Provides must be an array");
+		}
+
+		reader.beginArray();
+
+		while (reader.hasNext()) {
+			if (reader.peek() != JsonToken.STRING) {
+				throw new ParseMetadataException("Provided id must be a string", reader);
+			}
+
+			provides.add(reader.nextString());
+		}
+
+		reader.endArray();
+	}
+
+	private static ModEnvironment readEnvironment(JsonReader reader) throws ParseMetadataException, IOException {
+		final String environment = reader.nextString().toLowerCase(Locale.ROOT);
+
+		if (environment.isEmpty() || environment.equals("*")) {
+			return ModEnvironment.UNIVERSAL;
+		} else if (environment.equals("client")) {
+			return ModEnvironment.CLIENT;
+		} else if (environment.equals("server")) {
+			return ModEnvironment.SERVER;
+		} else {
+			throw new ParseMetadataException("Invalid environment type: " + environment + "!", reader);
+		}
+	}
+
+	private static void readEntrypoints(List<ParseWarning> warnings, JsonReader reader, Map<String, List<EntrypointMetadata>> entrypoints) throws IOException, ParseMetadataException {
+		// Entrypoints must be an object
+		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+			throw new ParseMetadataException("Entrypoints must be an object", reader);
+		}
+
+		reader.beginObject();
+
+		while (reader.hasNext()) {
+			final String key = reader.nextName();
+
+			List<EntrypointMetadata> metadata = new ArrayList<>();
+
+			if (reader.peek() != JsonToken.BEGIN_ARRAY) {
+				throw new ParseMetadataException("Entrypoint list must be an array!", reader);
+			}
+
+			reader.beginArray();
+
+			while (reader.hasNext()) {
+				String adapter = "default";
+				String value = null;
+
+				// Entrypoints may be specified directly as a string or as an object to allow specification of the language adapter to use.
+				switch (reader.peek()) {
+				case STRING:
+					value = reader.nextString();
+					break;
+				case BEGIN_OBJECT:
+					reader.beginObject();
+
+					while (reader.hasNext()) {
+						final String entryKey = reader.nextName();
+						switch (entryKey) {
+						case "adapter":
+							adapter = reader.nextString();
+							break;
+						case "value":
+							value = reader.nextString();
+							break;
+						default:
+							warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), entryKey, "Invalid entry in entrypoint metadata"));
+							reader.skipValue();
+							break;
+						}
+					}
+
+					reader.endObject();
+					break;
+				default:
+					throw new ParseMetadataException("Entrypoint must be a string or object with \"value\" field", reader);
+				}
+
+				if (value == null) {
+					throw new ParseMetadataException.MissingField("Entrypoint value must be present");
+				}
+
+				metadata.add(new V1ModMetadata.EntrypointMetadataImpl(adapter, value));
+			}
+
+			reader.endArray();
+
+			// Empty arrays are acceptable, do not check if the List of metadata is empty
+			entrypoints.put(key, metadata);
+		}
+
+		reader.endObject();
+	}
+
+	private static void readNestedJarEntries(List<ParseWarning> warnings, JsonReader reader, List<NestedJarEntry> jars) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_ARRAY) {
+			throw new ParseMetadataException("Jar entries must be in an array", reader);
+		}
+
+		reader.beginArray();
+
+		while (reader.hasNext()) {
+			if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+				throw new ParseMetadataException("Invalid type for JAR entry!", reader);
+			}
+
+			reader.beginObject();
+			String file = null;
+
+			while (reader.hasNext()) {
+				final String key = reader.nextName();
+
+				if (key.equals("file")) {
+					if (reader.peek() != JsonToken.STRING) {
+						throw new ParseMetadataException("\"file\" entry in jar object must be a string", reader);
+					}
+
+					file = reader.nextString();
+				} else {
+					warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), key, "Invalid entry in jar entry"));
+					reader.skipValue();
+				}
+			}
+
+			reader.endObject();
+
+			if (file == null) {
+				throw new ParseMetadataException("Missing mandatory key 'file' in JAR entry!", reader);
+			}
+
+			jars.add(new V1ModMetadata.JarEntry(file));
+		}
+
+		reader.endArray();
+	}
+
+	private static void readMixinConfigs(List<ParseWarning> warnings, JsonReader reader, List<V1ModMetadata.MixinEntry> mixins) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_ARRAY) {
+			throw new ParseMetadataException("Mixin configs must be in an array", reader);
+		}
+
+		reader.beginArray();
+
+		while (reader.hasNext()) {
+			switch (reader.peek()) {
+			case STRING:
+				// All mixin configs specified via string are assumed to be universal
+				mixins.add(new V1ModMetadata.MixinEntry(reader.nextString(), ModEnvironment.UNIVERSAL));
+				break;
+			case BEGIN_OBJECT:
+				reader.beginObject();
+
+				String config = null;
+				ModEnvironment environment = null;
+
+				while (reader.hasNext()) {
+					final String key = reader.nextName();
+
+					switch (key) {
+					// Environment is optional
+					case "environment":
+						environment = V1ModMetadataParser.readEnvironment(reader);
+						break;
+					case "config":
+						if (reader.peek() != JsonToken.STRING) {
+							throw new ParseMetadataException("Value of \"config\" must be a string", reader);
+						}
+
+						config = reader.nextString();
+						break;
+					default:
+						warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), key, "Invalid entry in mixin config entry"));
+						reader.skipValue();
+					}
+				}
+
+				reader.endObject();
+
+				if (environment == null) {
+					environment = ModEnvironment.UNIVERSAL; // Default to universal
+				}
+
+				if (config == null) {
+					throw new ParseMetadataException.MissingField("Missing mandatory key 'config' in mixin entry!");
+				}
+
+				mixins.add(new V1ModMetadata.MixinEntry(config, environment));
+				break;
+			default:
+				warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), "Invalid mixin entry type"));
+				reader.skipValue();
+				break;
+			}
+		}
+
+		reader.endArray();
+	}
+
+	private static void readDependenciesContainer(JsonReader reader, ModDependency.Kind kind, List<ModDependency> out) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+			throw new ParseMetadataException("Dependency container must be an object!", reader);
+		}
+
+		reader.beginObject();
+
+		while (reader.hasNext()) {
+			final String modId = reader.nextName();
+			final List<String> matcherStringList = new ArrayList<>();
+
+			switch (reader.peek()) {
+			case STRING:
+				matcherStringList.add(reader.nextString());
+				break;
+			case BEGIN_ARRAY:
+				reader.beginArray();
+
+				while (reader.hasNext()) {
+					if (reader.peek() != JsonToken.STRING) {
+						throw new ParseMetadataException("Dependency version range array must only contain string values", reader);
+					}
+
+					matcherStringList.add(reader.nextString());
+				}
+
+				reader.endArray();
+				break;
+			default:
+				throw new ParseMetadataException("Dependency version range must be a string or string array!", reader);
+			}
+
+			try {
+				out.add(new ModDependencyImpl(kind, modId, matcherStringList));
+			} catch (Exception e) {
+				throw new ParseMetadataException(e);
+			}
+		}
+
+		reader.endObject();
+	}
+
+	private static void readPeople(List<ParseWarning> warnings, JsonReader reader, List<Person> people) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_ARRAY) {
+			throw new ParseMetadataException("List of people must be an array", reader);
+		}
+
+		reader.beginArray();
+
+		while (reader.hasNext()) {
+			switch (reader.peek()) {
+			case STRING:
+				// Just a name
+				people.add(new SimplePerson(reader.nextString()));
+				break;
+			case BEGIN_OBJECT:
+				// Map-backed impl
+				reader.beginObject();
+				// Name is required
+				String personName = null;
+				ContactInformation contactInformation = null;
+
+				while (reader.hasNext()) {
+					final String key = reader.nextName();
+
+					switch (key) {
+					case "name":
+						if (reader.peek() != JsonToken.STRING) {
+							throw new ParseMetadataException("Name of person in dependency container must be a string", reader);
+						}
+
+						personName = reader.nextString();
+						break;
+						// Effectively optional
+					case "contact":
+						contactInformation = V1ModMetadataParser.readContactInfo(reader);
+						break;
+					default:
+						// Ignore unsupported keys
+						warnings.add(new ParseWarning(reader.getLineNumber(), reader.getColumn(), key, "Invalid entry in person"));
+						reader.skipValue();
+					}
+				}
+
+				reader.endObject();
+
+				if (personName == null) {
+					throw new ParseMetadataException.MissingField("Person object must have a 'name' field!");
+				}
+
+				if (contactInformation == null) {
+					contactInformation = ContactInformation.EMPTY; // Empty if not specified
+				}
+
+				people.add(new ContactInfoBackedPerson(personName, contactInformation));
+				break;
+			default:
+				throw new ParseMetadataException("Person type must be an object or string!", reader);
+			}
+		}
+
+		reader.endArray();
+	}
+
+	private static ContactInformation readContactInfo(JsonReader reader) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+			throw new ParseMetadataException("Contact info must in an object", reader);
+		}
+
+		reader.beginObject();
+
+		final Map<String, String> map = new HashMap<>();
+
+		while (reader.hasNext()) {
+			final String key = reader.nextName();
+
+			if (reader.peek() != JsonToken.STRING) {
+				throw new ParseMetadataException("Contact information entries must be a string", reader);
+			}
+
+			map.put(key, reader.nextString());
+		}
+
+		reader.endObject();
+
+		// Map is wrapped as unmodifiable in the contact info impl
+		return new ContactInformationImpl(map);
+	}
+
+	private static void readLicense(JsonReader reader, List<String> license) throws IOException, ParseMetadataException {
+		switch (reader.peek()) {
+		case STRING:
+			license.add(reader.nextString());
+			break;
+		case BEGIN_ARRAY:
+			reader.beginArray();
+
+			while (reader.hasNext()) {
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("List of licenses must only contain strings", reader);
+				}
+
+				license.add(reader.nextString());
+			}
+
+			reader.endArray();
+			break;
+		default:
+			throw new ParseMetadataException("License must be a string or array of strings!", reader);
+		}
+	}
+
+	private static V1ModMetadata.IconEntry readIcon(JsonReader reader) throws IOException, ParseMetadataException {
+		switch (reader.peek()) {
+		case STRING:
+			return new V1ModMetadata.Single(reader.nextString());
+		case BEGIN_OBJECT:
+			reader.beginObject();
+
+			final SortedMap<Integer, String> iconMap = new TreeMap<>(Comparator.naturalOrder());
+
+			while (reader.hasNext()) {
+				if (reader.peek() != JsonToken.STRING) {
+					throw new ParseMetadataException("Icon path must be a string", reader);
+				}
+
+				String key = reader.nextName();
+
+				int size;
+
+				try {
+					size = Integer.parseInt(key);
+				} catch (NumberFormatException e) {
+					throw new ParseMetadataException("Could not parse icon size '" + key + "'!", e);
+				}
+
+				if (size < 1) {
+					throw new ParseMetadataException("Size must be positive!", reader);
+				}
+			}
+
+			reader.endObject();
+
+			if (iconMap.isEmpty()) {
+				throw new ParseMetadataException("Icon object must not be empty!", reader);
+			}
+
+			return new V1ModMetadata.MapEntry(iconMap);
+		default:
+			throw new ParseMetadataException("Icon entry must be an object or string!", reader);
+		}
+	}
+
+	private static void readLanguageAdapters(JsonReader reader, Map<String, String> languageAdapters) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+			throw new ParseMetadataException("Language adapters must be in an object", reader);
+		}
+
+		reader.beginObject();
+
+		while (reader.hasNext()) {
+			final String adapter = reader.nextName();
+
+			if (reader.peek() != JsonToken.STRING) {
+				throw new ParseMetadataException("Value of language adapter entry must be a string", reader);
+			}
+
+			languageAdapters.put(adapter, reader.nextString());
+		}
+
+		reader.endObject();
+	}
+
+	private static void readCustomValues(JsonReader reader, Map<String, CustomValue> customValues) throws IOException, ParseMetadataException {
+		if (reader.peek() != JsonToken.BEGIN_OBJECT) {
+			throw new ParseMetadataException("Custom values must be in an object!", reader);
+		}
+
+		reader.beginObject();
+
+		while (reader.hasNext()) {
+			customValues.put(reader.nextName(), CustomValueImpl.readCustomValue(reader));
+		}
+
+		reader.endObject();
+	}
+
+	private V1ModMetadataParser() {
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/metadata/VersionOverrides.java b/src/main/java/net/fabricmc/loader/impl/metadata/VersionOverrides.java
new file mode 100644
index 0000000000000000000000000000000000000000..9834e34c006068a634a3ae8c2030c385d47e8893
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/metadata/VersionOverrides.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.metadata;
+
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.impl.util.SystemProperties;
+import net.fabricmc.loader.impl.util.version.VersionParser;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+public final class VersionOverrides {
+	private final Map<String, Version> replacements = new HashMap<>();
+
+	public VersionOverrides() {
+		String property = System.getProperty(SystemProperties.DEBUG_REPLACE_VERSION);
+		if (property == null) return;
+
+		for (String entry : property.split(",")) {
+			int pos = entry.indexOf(":");
+			if (pos <= 0 || pos >= entry.length() - 1) throw new RuntimeException("invalid version replacement entry: "+entry);
+
+			String id = entry.substring(0, pos);
+			String rawVersion = entry.substring(pos + 1);
+			Version version;
+
+			try {
+				version = VersionParser.parse(rawVersion, false);
+			} catch (Exception e) {
+				throw new RuntimeException(String.format("Invalid replacement version for mod %s: %s", id, rawVersion), e);
+			}
+
+			replacements.put(id, version);
+		}
+	}
+
+	public void apply(LoaderModMetadata metadata) {
+		if (replacements.isEmpty()) return;
+
+		Version replacement = replacements.get(metadata.getId());
+
+		if (replacement != null) {
+			metadata.setVersion(replacement);
+		}
+	}
+
+	public Collection<String> getAffectedModIds() {
+		return replacements.keySet();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/transformer/ClassStripper.java b/src/main/java/net/fabricmc/loader/impl/transformer/ClassStripper.java
new file mode 100644
index 0000000000000000000000000000000000000000..376b4764a73aec3bd350fc8a8bb6617f90dfb804
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/transformer/ClassStripper.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.transformer;
+
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.FieldVisitor;
+import org.objectweb.asm.MethodVisitor;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * Strips the specified interfaces, fields and methods from a class.
+ */
+public class ClassStripper extends ClassVisitor {
+	private final Collection<String> stripInterfaces;
+	private final Collection<String> stripFields;
+	private final Collection<String> stripMethods;
+
+	public ClassStripper(int api, ClassVisitor classVisitor, Collection<String> stripInterfaces, Collection<String> stripFields, Collection<String> stripMethods) {
+		super(api, classVisitor);
+		this.stripInterfaces = stripInterfaces;
+		this.stripFields = stripFields;
+		this.stripMethods = stripMethods;
+	}
+
+	@Override
+	public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
+		if (!this.stripInterfaces.isEmpty()) {
+			List<String> interfacesList = new ArrayList<>();
+
+			for (String itf : interfaces) {
+				if (!this.stripInterfaces.contains(itf)) {
+					interfacesList.add(itf);
+				}
+			}
+
+			interfaces = interfacesList.toArray(new String[0]);
+		}
+
+		super.visit(version, access, name, signature, superName, interfaces);
+	}
+
+	@Override
+	public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {
+		if (stripFields.contains(name + descriptor)) return null;
+		return super.visitField(access, name, descriptor, signature, value);
+	}
+
+	@Override
+	public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
+		if (stripMethods.contains(name + descriptor)) return null;
+		return super.visitMethod(access, name, descriptor, signature, exceptions);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/transformer/EnvironmentStrippingData.java b/src/main/java/net/fabricmc/loader/impl/transformer/EnvironmentStrippingData.java
new file mode 100644
index 0000000000000000000000000000000000000000..9dab18f30bb6a0bb5d9be7ba3565bd01e8609221
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/transformer/EnvironmentStrippingData.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.transformer;
+
+import net.fabricmc.api.Environment;
+import net.fabricmc.api.EnvironmentInterface;
+import net.fabricmc.api.EnvironmentInterfaces;
+import org.objectweb.asm.*;
+
+import java.util.Collection;
+import java.util.HashSet;
+
+/**
+ * Scans a class for Environment and EnvironmentInterface annotations to figure out what needs to be stripped.
+ */
+public class EnvironmentStrippingData extends ClassVisitor {
+	private static final String ENVIRONMENT_DESCRIPTOR = Type.getDescriptor(Environment.class);
+	private static final String ENVIRONMENT_INTERFACE_DESCRIPTOR = Type.getDescriptor(EnvironmentInterface.class);
+	private static final String ENVIRONMENT_INTERFACES_DESCRIPTOR = Type.getDescriptor(EnvironmentInterfaces.class);
+
+	private final String envType;
+
+	private boolean stripEntireClass = false;
+	private final Collection<String> stripInterfaces = new HashSet<>();
+	private final Collection<String> stripFields = new HashSet<>();
+	private final Collection<String> stripMethods = new HashSet<>();
+
+	private class EnvironmentAnnotationVisitor extends AnnotationVisitor {
+		private final Runnable onEnvMismatch;
+
+		private EnvironmentAnnotationVisitor(int api, Runnable onEnvMismatch) {
+			super(api);
+			this.onEnvMismatch = onEnvMismatch;
+		}
+
+		@Override
+		public void visitEnum(String name, String descriptor, String value) {
+			if ("value".equals(name) && !envType.equals(value)) {
+				onEnvMismatch.run();
+			}
+		}
+	}
+
+	private class EnvironmentInterfaceAnnotationVisitor extends AnnotationVisitor {
+		private boolean envMismatch;
+		private Type itf;
+
+		private EnvironmentInterfaceAnnotationVisitor(int api) {
+			super(api);
+		}
+
+		@Override
+		public void visitEnum(String name, String descriptor, String value) {
+			if ("value".equals(name) && !envType.equals(value)) {
+				envMismatch = true;
+			}
+		}
+
+		@Override
+		public void visit(String name, Object value) {
+			if ("itf".equals(name)) {
+				itf = (Type) value;
+			}
+		}
+
+		@Override
+		public void visitEnd() {
+			if (envMismatch) {
+				stripInterfaces.add(itf.getInternalName());
+			}
+		}
+	}
+
+	private AnnotationVisitor visitMemberAnnotation(String descriptor, boolean visible, Runnable onEnvMismatch) {
+		if (ENVIRONMENT_DESCRIPTOR.equals(descriptor)) {
+			return new EnvironmentAnnotationVisitor(api, onEnvMismatch);
+		}
+
+		return null;
+	}
+
+	public EnvironmentStrippingData(int api, String envType) {
+		super(api);
+		this.envType = envType;
+	}
+
+	@Override
+	public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
+		if (ENVIRONMENT_DESCRIPTOR.equals(descriptor)) {
+			return new EnvironmentAnnotationVisitor(api, () -> stripEntireClass = true);
+		} else if (ENVIRONMENT_INTERFACE_DESCRIPTOR.equals(descriptor)) {
+			return new EnvironmentInterfaceAnnotationVisitor(api);
+		} else if (ENVIRONMENT_INTERFACES_DESCRIPTOR.equals(descriptor)) {
+			return new AnnotationVisitor(api) {
+				@Override
+				public AnnotationVisitor visitArray(String name) {
+					if ("value".equals(name)) {
+						return new AnnotationVisitor(api) {
+							@Override
+							public AnnotationVisitor visitAnnotation(String name, String descriptor) {
+								return new EnvironmentInterfaceAnnotationVisitor(api);
+							}
+						};
+					}
+
+					return null;
+				}
+			};
+		}
+
+		return null;
+	}
+
+	@Override
+	public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {
+		return new FieldVisitor(api) {
+			@Override
+			public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
+				return visitMemberAnnotation(descriptor, visible, () -> stripFields.add(name + descriptor));
+			}
+		};
+	}
+
+	@Override
+	public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
+		String methodId = name + descriptor;
+		return new MethodVisitor(api) {
+			@Override
+			public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
+				return visitMemberAnnotation(descriptor, visible, () -> stripMethods.add(methodId));
+			}
+		};
+	}
+
+	public boolean stripEntireClass() {
+		return stripEntireClass;
+	}
+
+	public Collection<String> getStripInterfaces() {
+		return stripInterfaces;
+	}
+
+	public Collection<String> getStripFields() {
+		return stripFields;
+	}
+
+	public Collection<String> getStripMethods() {
+		return stripMethods;
+	}
+
+	public boolean isEmpty() {
+		return stripInterfaces.isEmpty() && stripFields.isEmpty() && stripMethods.isEmpty();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/transformer/FabricTransformer.java b/src/main/java/net/fabricmc/loader/impl/transformer/FabricTransformer.java
new file mode 100644
index 0000000000000000000000000000000000000000..b6a56def5a3e69f99c09adc1f65c96436a06a8bb
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/transformer/FabricTransformer.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.transformer;
+
+import net.fabricmc.accesswidener.AccessWidenerClassVisitor;
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.FabricLoaderImpl;
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+
+public final class FabricTransformer {
+	public static byte[] transform(boolean isDevelopment, EnvType envType, String name, byte[] bytes) {
+		boolean isMinecraftClass = name.startsWith("net.minecraft.") || name.startsWith("com.mojang.blaze3d.") || name.indexOf('.') < 0;
+		boolean transformAccess = isMinecraftClass && FabricLauncherBase.getLauncher().getMappingConfiguration().requiresPackageAccessHack();
+		boolean environmentStrip = !isMinecraftClass || isDevelopment;
+		boolean applyAccessWidener = isMinecraftClass && FabricLoaderImpl.INSTANCE.getAccessWidener().getTargets().contains(name);
+
+		if (!transformAccess && !environmentStrip && !applyAccessWidener) {
+			return bytes;
+		}
+
+		ClassReader classReader = new ClassReader(bytes);
+		ClassWriter classWriter = new ClassWriter(classReader, 0);
+		ClassVisitor visitor = classWriter;
+		int visitorCount = 0;
+
+		if (applyAccessWidener) {
+			visitor = AccessWidenerClassVisitor.createClassVisitor(FabricLoaderImpl.ASM_VERSION, visitor, FabricLoaderImpl.INSTANCE.getAccessWidener());
+			visitorCount++;
+		}
+
+		if (transformAccess) {
+			visitor = new PackageAccessFixer(FabricLoaderImpl.ASM_VERSION, visitor);
+			visitorCount++;
+		}
+
+		if (environmentStrip) {
+			EnvironmentStrippingData stripData = new EnvironmentStrippingData(FabricLoaderImpl.ASM_VERSION, envType.toString());
+			classReader.accept(stripData, ClassReader.SKIP_CODE | ClassReader.SKIP_FRAMES);
+
+			if (stripData.stripEntireClass()) {
+				throw new RuntimeException("Cannot load class " + name + " in environment type " + envType);
+			}
+
+			if (!stripData.isEmpty()) {
+				visitor = new ClassStripper(FabricLoaderImpl.ASM_VERSION, visitor, stripData.getStripInterfaces(), stripData.getStripFields(), stripData.getStripMethods());
+				visitorCount++;
+			}
+		}
+
+		if (visitorCount <= 0) {
+			return bytes;
+		}
+
+		classReader.accept(visitor, 0);
+		return classWriter.toByteArray();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/transformer/PackageAccessFixer.java b/src/main/java/net/fabricmc/loader/impl/transformer/PackageAccessFixer.java
new file mode 100644
index 0000000000000000000000000000000000000000..1217e52e8ce5cf187650876c007a7ee7be7c7dc8
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/transformer/PackageAccessFixer.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.transformer;
+
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.FieldVisitor;
+import org.objectweb.asm.MethodVisitor;
+import org.objectweb.asm.Opcodes;
+
+/**
+ * Changes package-private and protected access flags to public.
+ * In a development environment, Minecraft classes may be mapped into a package structure with invalid access across
+ * packages. The class verifier will complain unless we simply change package-private and protected to public.
+ */
+public class PackageAccessFixer extends ClassVisitor {
+	private static int modAccess(int access) {
+		if ((access & 0x7) != Opcodes.ACC_PRIVATE) {
+			return (access & (~0x7)) | Opcodes.ACC_PUBLIC;
+		} else {
+			return access;
+		}
+	}
+
+	public PackageAccessFixer(int api, ClassVisitor classVisitor) {
+		super(api, classVisitor);
+	}
+
+	@Override
+	public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
+		super.visit(version, modAccess(access), name, signature, superName, interfaces);
+	}
+
+	@Override
+	public void visitInnerClass(String name, String outerName, String innerName, int access) {
+		super.visitInnerClass(name, outerName, innerName, modAccess(access));
+	}
+
+	@Override
+	public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {
+		return super.visitField(modAccess(access), name, descriptor, signature, value);
+	}
+
+	@Override
+	public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
+		return super.visitMethod(modAccess(access), name, descriptor, signature, exceptions);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/Arguments.java b/src/main/java/net/fabricmc/loader/impl/util/Arguments.java
new file mode 100644
index 0000000000000000000000000000000000000000..71e1934f90d251995d58a38f36e3eb3685b32435
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/Arguments.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+import java.util.*;
+
+public final class Arguments {
+	// set the game version for the builtin game mod/dependencies, bypassing auto-detection
+	public static final String GAME_VERSION = SystemProperties.GAME_VERSION;
+	// additional mods to load (path separator separated paths, @ prefix for meta-file with each line referencing an actual file)
+	public static final String ADD_MODS = SystemProperties.ADD_MODS;
+
+	private final Map<String, String> values;
+	private final List<String> extraArgs;
+
+	public Arguments() {
+		values = new LinkedHashMap<>();
+		extraArgs = new ArrayList<>();
+	}
+
+	public Collection<String> keys() {
+		return values.keySet();
+	}
+
+	public List<String> getExtraArgs() {
+		return Collections.unmodifiableList(extraArgs);
+	}
+
+	public boolean containsKey(String key) {
+		return values.containsKey(key);
+	}
+
+	public String get(String key) {
+		return values.get(key);
+	}
+
+	public String getOrDefault(String key, String value) {
+		return values.getOrDefault(key, value);
+	}
+
+	public void put(String key, String value) {
+		values.put(key, value);
+	}
+
+	public void addExtraArg(String value) {
+		extraArgs.add(value);
+	}
+
+	public void parse(String[] args) {
+		parse(Arrays.asList(args));
+	}
+
+	public void parse(List<String> args) {
+		for (int i = 0; i < args.size(); i++) {
+			String arg = args.get(i);
+
+			if (arg.startsWith("--") && i < args.size() - 1) {
+				String value = args.get(i + 1);
+
+				if (value.startsWith("--")) {
+					// Give arguments that have no value an empty string.
+					value = "";
+				} else {
+					i += 1;
+				}
+
+				values.put(arg.substring(2), value);
+			} else {
+				extraArgs.add(arg);
+			}
+		}
+	}
+
+	public String[] toArray() {
+		String[] newArgs = new String[values.size() * 2 + extraArgs.size()];
+		int i = 0;
+
+		for (String s : values.keySet()) {
+			newArgs[i++] = "--" + s;
+			newArgs[i++] = values.get(s);
+		}
+
+		for (String s : extraArgs) {
+			newArgs[i++] = s;
+		}
+
+		return newArgs;
+	}
+
+	public String remove(String s) {
+		return values.remove(s);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/DefaultLanguageAdapter.java b/src/main/java/net/fabricmc/loader/impl/util/DefaultLanguageAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..1cb72c343da234c99ade16711edbf2f8145c6647
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/DefaultLanguageAdapter.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+import net.fabricmc.loader.api.LanguageAdapter;
+import net.fabricmc.loader.api.LanguageAdapterException;
+import net.fabricmc.loader.api.ModContainer;
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandleProxies;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.List;
+
+public final class DefaultLanguageAdapter implements LanguageAdapter {
+	public static final DefaultLanguageAdapter INSTANCE = new DefaultLanguageAdapter();
+
+	private DefaultLanguageAdapter() { }
+
+	@SuppressWarnings("unchecked")
+	@Override
+	public <T> T create(ModContainer mod, String value, Class<T> type) throws LanguageAdapterException {
+		String[] methodSplit = value.split("::");
+
+		if (methodSplit.length >= 3) {
+			throw new LanguageAdapterException("Invalid handle format: " + value);
+		}
+
+		Class<?> c;
+
+		try {
+			c = Class.forName(methodSplit[0], true, FabricLauncherBase.getLauncher().getTargetClassLoader());
+		} catch (ClassNotFoundException e) {
+			throw new LanguageAdapterException(e);
+		}
+
+		if (methodSplit.length == 1) {
+			if (type.isAssignableFrom(c)) {
+				try {
+					return (T) c.getDeclaredConstructor().newInstance();
+				} catch (Exception e) {
+					throw new LanguageAdapterException(e);
+				}
+			} else {
+				throw new LanguageAdapterException("Class " + c.getName() + " cannot be cast to " + type.getName() + "!");
+			}
+		} else /* length == 2 */ {
+			List<Method> methodList = new ArrayList<>();
+
+			for (Method m : c.getDeclaredMethods()) {
+				if (!(m.getName().equals(methodSplit[1]))) {
+					continue;
+				}
+
+				methodList.add(m);
+			}
+
+			try {
+				Field field = c.getDeclaredField(methodSplit[1]);
+				Class<?> fType = field.getType();
+
+				if ((field.getModifiers() & Modifier.STATIC) == 0) {
+					throw new LanguageAdapterException("Field " + value + " must be static!");
+				}
+
+				if (!methodList.isEmpty()) {
+					throw new LanguageAdapterException("Ambiguous " + value + " - refers to both field and method!");
+				}
+
+				if (!type.isAssignableFrom(fType)) {
+					throw new LanguageAdapterException("Field " + value + " cannot be cast to " + type.getName() + "!");
+				}
+
+				return (T) field.get(null);
+			} catch (NoSuchFieldException e) {
+				// ignore
+			} catch (IllegalAccessException e) {
+				throw new LanguageAdapterException("Field " + value + " cannot be accessed!", e);
+			}
+
+			if (!type.isInterface()) {
+				throw new LanguageAdapterException("Cannot proxy method " + value + " to non-interface type " + type.getName() + "!");
+			}
+
+			if (methodList.isEmpty()) {
+				throw new LanguageAdapterException("Could not find " + value + "!");
+			} else if (methodList.size() >= 2) {
+				throw new LanguageAdapterException("Found multiple method entries of name " + value + "!");
+			}
+
+			final Method targetMethod = methodList.get(0);
+			Object object = null;
+
+			if ((targetMethod.getModifiers() & Modifier.STATIC) == 0) {
+				try {
+					object = c.getDeclaredConstructor().newInstance();
+				} catch (Exception e) {
+					throw new LanguageAdapterException(e);
+				}
+			}
+
+			MethodHandle handle;
+
+			try {
+				handle = MethodHandles.lookup()
+						.unreflect(targetMethod);
+			} catch (Exception ex) {
+				throw new LanguageAdapterException(ex);
+			}
+
+			if (object != null) {
+				handle = handle.bindTo(object);
+			}
+
+			// uses proxy as well, but this handles default and object methods
+			try {
+				return MethodHandleProxies.asInterfaceInstance(type, handle);
+			} catch (Exception ex) {
+				throw new LanguageAdapterException(ex);
+			}
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/ExceptionUtil.java b/src/main/java/net/fabricmc/loader/impl/util/ExceptionUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..7e4e4a9b4f31c6995fd51c2afc3f4802d45ec281
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/ExceptionUtil.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+import java.io.UncheckedIOException;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.ExecutionException;
+import java.util.function.Function;
+
+public final class ExceptionUtil {
+	private static final boolean THROW_DIRECTLY = System.getProperty(SystemProperties.DEBUG_THROW_DIRECTLY) != null;
+
+	public static <T extends Throwable> T gatherExceptions(Throwable exc, T prev, Function<Throwable, T> mainExcFactory) throws T {
+		exc = unwrap(exc);
+
+		if (THROW_DIRECTLY) throw mainExcFactory.apply(exc);
+
+		if (prev == null) {
+			return mainExcFactory.apply(exc);
+		} else if (exc != prev) {
+			for (Throwable t : prev.getSuppressed()) {
+				if (exc.equals(t)) return prev;
+			}
+
+			prev.addSuppressed(exc);
+		}
+
+		return prev;
+	}
+
+	public static RuntimeException wrap(Throwable exc) {
+		if (exc instanceof RuntimeException) return (RuntimeException) exc;
+
+		exc = unwrap(exc);
+		if (exc instanceof RuntimeException) return (RuntimeException) exc;
+
+		return new WrappedException(exc);
+	}
+
+	private static Throwable unwrap(Throwable exc) {
+		if (exc instanceof WrappedException
+				|| exc instanceof UncheckedIOException
+				|| exc instanceof ExecutionException
+				|| exc instanceof CompletionException) {
+			Throwable ret = exc.getCause();
+			if (ret != null) return unwrap(ret);
+		}
+
+		return exc;
+	}
+
+	@SuppressWarnings("serial")
+	public static final class WrappedException extends RuntimeException {
+		public WrappedException(Throwable cause) {
+			super(cause);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/FileSystemUtil.java b/src/main/java/net/fabricmc/loader/impl/util/FileSystemUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..20448358937d5ad43e703224bfdd859b74d8e171
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/FileSystemUtil.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.file.*;
+import java.util.Collections;
+import java.util.Map;
+import java.util.zip.ZipError;
+
+public final class FileSystemUtil {
+	public static class FileSystemDelegate implements AutoCloseable {
+		private final FileSystem fileSystem;
+		private final boolean owner;
+
+		public FileSystemDelegate(FileSystem fileSystem, boolean owner) {
+			this.fileSystem = fileSystem;
+			this.owner = owner;
+		}
+
+		public FileSystem get() {
+			return fileSystem;
+		}
+
+		@Override
+		public void close() throws IOException {
+			if (owner) {
+				fileSystem.close();
+			}
+		}
+	}
+
+	private FileSystemUtil() { }
+
+	private static final Map<String, String> jfsArgsCreate = Collections.singletonMap("create", "true");
+	private static final Map<String, String> jfsArgsEmpty = Collections.emptyMap();
+
+	public static FileSystemDelegate getJarFileSystem(Path path, boolean create) throws IOException {
+		return getJarFileSystem(path.toUri(), create);
+	}
+
+	public static FileSystemDelegate getJarFileSystem(URI uri, boolean create) throws IOException {
+		URI jarUri;
+
+		try {
+			jarUri = new URI("jar:" + uri.getScheme(), uri.getHost(), uri.getPath(), uri.getFragment());
+		} catch (URISyntaxException e) {
+			throw new IOException(e);
+		}
+
+		boolean opened = false;
+		FileSystem ret = null;
+
+		try {
+			ret = FileSystems.getFileSystem(jarUri);
+		} catch (FileSystemNotFoundException ignore) {
+			try {
+				ret = FileSystems.newFileSystem(jarUri, create ? jfsArgsCreate : jfsArgsEmpty);
+				opened = true;
+			} catch (FileSystemAlreadyExistsException ignore2) {
+				ret = FileSystems.getFileSystem(jarUri);
+			} catch (IOException | ZipError e) {
+				throw new IOException("Error accessing "+uri+": "+e, e);
+			}
+		}
+
+		return new FileSystemDelegate(ret, opened);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/LoaderUtil.java b/src/main/java/net/fabricmc/loader/impl/util/LoaderUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..024d509ee0b39f5433f8207e65137e8d9ff11be1
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/LoaderUtil.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Locale;
+
+public final class LoaderUtil {
+	public static String getClassFileName(String className) {
+		return className.replace('.', '/').concat(".class");
+	}
+
+	public static Path normalizePath(Path path) {
+		if (Files.exists(path)) {
+			return normalizeExistingPath(path);
+		} else {
+			return path.toAbsolutePath().normalize();
+		}
+	}
+
+	public static Path normalizeExistingPath(Path path) {
+		try {
+			return path.toRealPath();
+		} catch (IOException e) {
+			throw new UncheckedIOException(e);
+		}
+	}
+
+	public static void verifyNotInTargetCl(Class<?> cls) {
+		if (cls.getClassLoader().getClass().getName().equals("net.fabricmc.loader.impl.launch.knot.KnotClassLoader")) {
+			// This usually happens when fabric loader has been added to the target class loader. This is a bad state.
+			// Such additions may be indirect, a JAR can use the Class-Path manifest attribute to drag additional
+			// libraries with it, likely recursively.
+			throw new IllegalStateException("trying to load "+cls.getName()+" from target class loader");
+		}
+	}
+
+	public static boolean hasMacOs() {
+		return System.getProperty("os.name").toLowerCase(Locale.ENGLISH).contains("mac");
+	}
+
+	public static boolean hasAwtSupport() {
+		if (hasMacOs()) {
+			// check for JAVA_STARTED_ON_FIRST_THREAD_<pid> which is set if -XstartOnFirstThread is used
+			// -XstartOnFirstThread is incompatible with AWT (force enables embedded mode)
+			for (String key : System.getenv().keySet()) {
+				if (key.startsWith("JAVA_STARTED_ON_FIRST_THREAD_")) return false;
+			}
+		}
+
+		return true;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/Localization.java b/src/main/java/net/fabricmc/loader/impl/util/Localization.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab1ee55eb24e4b80ea6e5e6432e3d1a5123776e4
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/Localization.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.text.MessageFormat;
+import java.util.Locale;
+import java.util.PropertyResourceBundle;
+import java.util.ResourceBundle;
+
+public final class Localization {
+	public static final ResourceBundle BUNDLE = createBundle("net.fabricmc.loader.Messages");
+
+	public static String format(String key, Object... args) {
+		String pattern = BUNDLE.getString(key);
+
+		if (args.length == 0) {
+			return pattern;
+		} else {
+			return MessageFormat.format(pattern, args);
+		}
+	}
+
+	private static ResourceBundle createBundle(String name) {
+		if (System.getProperty("java.version", "").startsWith("1.")) { // below java 9
+			return ResourceBundle.getBundle(name, Locale.getDefault(), new ResourceBundle.Control() {
+				@Override
+				public ResourceBundle newBundle(String baseName, Locale locale, String format, ClassLoader loader, boolean reload)
+						throws IllegalAccessException, InstantiationException, IOException {
+					if (format.equals("java.properties")) {
+						InputStream is = loader.getResourceAsStream(toResourceName(toBundleName(baseName, locale), "properties"));
+
+						if (is != null) {
+							try (InputStreamReader reader = new InputStreamReader(is, StandardCharsets.UTF_8)) {
+								return new PropertyResourceBundle(reader);
+							}
+						}
+					}
+
+					return super.newBundle(baseName, locale, format, loader, reload);
+				};
+			});
+		} else { // java 9 and later
+			return ResourceBundle.getBundle(name);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/ManifestUtil.java b/src/main/java/net/fabricmc/loader/impl/util/ManifestUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7ada9aeac4d748d6e0ea4f72f79a612589c2df6
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/ManifestUtil.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.*;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.security.CodeSource;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.StringTokenizer;
+import java.util.jar.Attributes.Name;
+import java.util.jar.Manifest;
+
+public final class ManifestUtil {
+	public static Manifest readManifest(Class<?> cls) throws IOException, URISyntaxException {
+		CodeSource cs = cls.getProtectionDomain().getCodeSource();
+		if (cs == null) return null;
+
+		URL url = cs.getLocation();
+		if (url == null) return null;
+
+		return readManifest(url);
+	}
+
+	public static Manifest readManifest(URL codeSourceUrl) throws IOException, URISyntaxException {
+		Path path = UrlUtil.asPath(codeSourceUrl);
+
+		if (Files.isDirectory(path)) {
+			return readManifest(path);
+		} else {
+			URLConnection connection = new URL("jar:" + codeSourceUrl.toString() + "!/").openConnection();
+
+			if (connection instanceof JarURLConnection) {
+				return ((JarURLConnection) connection).getManifest();
+			}
+
+			try (FileSystemUtil.FileSystemDelegate jarFs = FileSystemUtil.getJarFileSystem(path, false)) {
+				return readManifest(jarFs.get().getRootDirectories().iterator().next());
+			}
+		}
+	}
+
+	public static Manifest readManifest(Path basePath) throws IOException {
+		Path path = basePath.resolve("META-INF").resolve("MANIFEST.MF");
+		if (!Files.exists(path)) return null;
+
+		try (InputStream stream = Files.newInputStream(path)) {
+			return new Manifest(stream);
+		}
+	}
+
+	public static String getManifestValue(Manifest manifest, Name name) {
+		return manifest.getMainAttributes().getValue(name);
+	}
+
+	public static List<URL> getClassPath(Manifest manifest, Path baseDir) throws MalformedURLException {
+		String cp = ManifestUtil.getManifestValue(manifest, Name.CLASS_PATH);
+		if (cp == null) return null;
+
+		StringTokenizer tokenizer = new StringTokenizer(cp);
+		List<URL> ret = new ArrayList<>();
+		URL context = UrlUtil.asUrl(baseDir);
+
+		while (tokenizer.hasMoreElements()) {
+			ret.add(new URL(context, tokenizer.nextToken()));
+		}
+
+		return ret;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/SimpleClassPath.java b/src/main/java/net/fabricmc/loader/impl/util/SimpleClassPath.java
new file mode 100644
index 0000000000000000000000000000000000000000..b919065bdbe9fd0711325fb08984b202484703b5
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/SimpleClassPath.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipError;
+import java.util.zip.ZipFile;
+
+public final class SimpleClassPath implements Closeable {
+	public SimpleClassPath(List<Path> paths) {
+		this.paths = paths;
+		this.jarMarkers = new boolean[paths.size()];
+		this.openJars = new ZipFile[paths.size()];
+
+		for (int i = 0; i < jarMarkers.length; i++) {
+			if (!Files.isDirectory(paths.get(i))) {
+				jarMarkers[i] = true;
+			}
+		}
+	}
+
+	@Override
+	public void close() throws IOException {
+		IOException exc = null;
+
+		for (int i = 0; i < openJars.length; i++) {
+			Closeable file = openJars[i];
+
+			try {
+				if (file != null) file.close();
+			} catch (IOException e) {
+				if (exc == null) {
+					exc = e;
+				} else {
+					exc.addSuppressed(e);
+				}
+			}
+
+			openJars[i] = null;
+		}
+
+		if (exc != null) throw exc;
+	}
+
+	public List<Path> getPaths() {
+		return paths;
+	}
+
+	public CpEntry getEntry(String subPath) throws IOException {
+		for (int i = 0; i < jarMarkers.length; i++) {
+			if (jarMarkers[i]) {
+				ZipFile zf = openJars[i];
+
+				if (zf == null) {
+					Path path = paths.get(i);
+
+					try {
+						openJars[i] = zf = new ZipFile(path.toFile());
+					} catch (IOException | ZipError e) {
+						throw new IOException(String.format("error opening %s: %s", LoaderUtil.normalizePath(path), e), e);
+					}
+				}
+
+				ZipEntry entry = zf.getEntry(subPath);
+
+				if (entry != null) {
+					return new CpEntry(i, subPath, entry);
+				}
+			} else {
+				Path file = paths.get(i).resolve(subPath);
+
+				if (Files.isRegularFile(file)) {
+					return new CpEntry(i, subPath, file);
+				}
+			}
+		}
+
+		return null;
+	}
+
+	public InputStream getInputStream(String subPath) throws IOException {
+		CpEntry entry = getEntry(subPath);
+
+		return entry != null ? entry.getInputStream() : null;
+	}
+
+	public final class CpEntry {
+		private CpEntry(int idx, String subPath, Object instance) {
+			this.idx = idx;
+			this.subPath = subPath;
+			this.instance = instance;
+		}
+
+		public Path getOrigin() {
+			return paths.get(idx);
+		}
+
+		public String getSubPath() {
+			return subPath;
+		}
+
+		public InputStream getInputStream() throws IOException {
+			if (instance instanceof ZipEntry) {
+				return openJars[idx].getInputStream((ZipEntry) instance);
+			} else {
+				return Files.newInputStream((Path) instance);
+			}
+		}
+
+		@Override
+		public String toString() {
+			return String.format("%s:%s", getOrigin(), subPath);
+		}
+
+		private final int idx;
+		private final String subPath;
+		private final Object instance;
+	}
+
+	private final List<Path> paths;
+	private final boolean[] jarMarkers; // whether the path is a jar (otherwise plain dir)
+	private final ZipFile[] openJars;
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/StringUtil.java b/src/main/java/net/fabricmc/loader/impl/util/StringUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..100f555d8389fcb00f074675ab05e3d7895e389f
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/StringUtil.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+public final class StringUtil {
+	public static String capitalize(String s) {
+		if (s.isEmpty()) return s;
+
+		int cp = s.codePointAt(0);
+		int cpUpper = Character.toUpperCase(cp);
+		if (cpUpper == cp) return s;
+
+		StringBuilder ret = new StringBuilder(s.length());
+		ret.appendCodePoint(cpUpper);
+		ret.append(s, Character.charCount(cp), s.length());
+
+		return ret.toString();
+	}
+
+	public static String[] splitNamespaced(String s, String defaultNamespace) {
+		int i = s.indexOf(':');
+
+		if (i >= 0) {
+			return new String[] { s.substring(0, i), s.substring(i + 1) };
+		} else {
+			return new String[] { defaultNamespace, s };
+		}
+	}
+
+	public static String wrapLines(String str, int limit) {
+		if (str.length() < limit) return str;
+
+		StringBuilder sb = new StringBuilder(str.length() + 20);
+		int lastSpace = -1;
+		int len = 0;
+
+		for (int i = 0, max = str.length(); i <= max; i++) {
+			char c = i < max ? str.charAt(i) : ' ';
+
+			if (c == '\r') {
+				// ignore
+			} else if (c == '\n') {
+				lastSpace = sb.length();
+				sb.append(c);
+				len = 0;
+			} else if (Character.isWhitespace(c)) {
+				if (len > limit && lastSpace >= 0) {
+					sb.setCharAt(lastSpace, '\n');
+					len = sb.length() - lastSpace - 1;
+				}
+
+				if (i == max) break;
+
+				if (len >= limit) {
+					lastSpace = -1;
+					sb.append('\n');
+					len = 0;
+				} else {
+					lastSpace = sb.length();
+					sb.append(c);
+					len++;
+				}
+			} else if (c == '"' || c == '\'') {
+				int next = str.indexOf(c, i + 1) + 1;
+				if (next <= 0) next = str.length();
+				sb.append(str, i, next);
+				len += next - i;
+				i = next - 1;
+			} else {
+				sb.append(c);
+				len++;
+			}
+		}
+
+		return sb.toString();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/SystemProperties.java b/src/main/java/net/fabricmc/loader/impl/util/SystemProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..f2c18c128b9952f7128c2877ad7c347db3e93898
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/SystemProperties.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+public final class SystemProperties {
+	// whether fabric loader is running in a development environment / mode, affects class path mod discovery, remapping, logging, ...
+	public static final String DEVELOPMENT = "fabric.development";
+	public static final String SIDE = "fabric.side";
+	// skips the embedded MC game provider, letting ServiceLoader-provided ones take over
+	public static final String SKIP_MC_PROVIDER = "fabric.skipMcProvider";
+	// game jar paths for common/client/server, replaces lookup from class path if present, env specific takes precedence
+	public static final String GAME_JAR_PATH = "fabric.gameJarPath";
+	public static final String GAME_JAR_PATH_CLIENT = "fabric.gameJarPath.client";
+	public static final String GAME_JAR_PATH_SERVER = "fabric.gameJarPath.server";
+	// set the game version for the builtin game mod/dependencies, bypassing auto-detection
+	public static final String GAME_VERSION = "fabric.gameVersion";
+	// fallback log file for the builtin log handler (dumped on exit if not replaced with another handler)
+	public static final String LOG_FILE = "fabric.log.file";
+	// minimum log level for builtin log handler
+	public static final String LOG_LEVEL = "fabric.log.level";
+	// additional mods to load (path separator separated paths, @ prefix for meta-file with each line referencing an actual file)
+	public static final String ADD_MODS = "fabric.addMods";
+	// file containing the class path for in-dev runtime mod remapping
+	public static final String REMAP_CLASSPATH_FILE = "fabric.remapClasspathFile";
+	// class path groups to map multiple class path entries to a mod (paths separated by path separator, groups by double path separator)
+	public static final String PATH_GROUPS = "fabric.classPathGroups";
+	// throw exceptions from entrypoints, discovery etc. directly instead of gathering and attaching as suppressed
+	public static final String DEBUG_THROW_DIRECTLY = "fabric.debug.throwDirectly";
+	// logs library classification activity
+	public static final String DEBUG_LOG_LIB_CLASSIFICATION = "fabric.debug.logLibClassification";
+	// logs class loading
+	public static final String DEBUG_LOG_CLASS_LOAD = "fabric.debug.logClassLoad";
+	// logs class loading errors to uncover caught exceptions without adequate logging
+	public static final String DEBUG_LOG_CLASS_LOAD_ERRORS = "fabric.debug.logClassLoadErrors";
+	// logs class transformation errors to uncover caught exceptions without adequate logging
+	public static final String DEBUG_LOG_TRANSFORM_ERRORS = "fabric.debug.logTransformErrors";
+	// disables system class path isolation, allowing bogus lib accesses (too early, transient jars)
+	public static final String DEBUG_DISABLE_CLASS_PATH_ISOLATION = "fabric.debug.disableClassPathIsolation";
+	// disables mod load order shuffling to be the same in-dev as in production
+	public static final String DEBUG_DISABLE_MOD_SHUFFLE = "fabric.debug.disableModShuffle";
+	// workaround for bad load order dependencies
+	public static final String DEBUG_LOAD_LATE = "fabric.debug.loadLate";
+	// override the mod discovery timeout, unit in seconds, <= 0 to disable
+	public static final String DEBUG_DISCOVERY_TIMEOUT = "fabric.debug.discoveryTimeout";
+	// override the mod resolution timeout, unit in seconds, <= 0 to disable
+	public static final String DEBUG_RESOLUTION_TIMEOUT = "fabric.debug.resolutionTimeout";
+	// replace mod versions (modA:versionA,modB:versionB,...)
+	public static final String DEBUG_REPLACE_VERSION = "fabric.debug.replaceVersion";
+
+	private SystemProperties() {
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/UrlConversionException.java b/src/main/java/net/fabricmc/loader/impl/util/UrlConversionException.java
new file mode 100644
index 0000000000000000000000000000000000000000..3039d400784c150b014c7496ce9cb2abf6665161
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/UrlConversionException.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+@SuppressWarnings({ "serial" })
+public class UrlConversionException extends Exception {
+	public UrlConversionException() {
+		super();
+	}
+
+	public UrlConversionException(String s) {
+		super(s);
+	}
+
+	public UrlConversionException(Throwable t) {
+		super(t);
+	}
+
+	public UrlConversionException(String s, Throwable t) {
+		super(s, t);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/UrlUtil.java b/src/main/java/net/fabricmc/loader/impl/util/UrlUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..bafeb2c8b4917d1c8f596736d96d8beb41909601
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/UrlUtil.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util;
+
+import java.io.File;
+import java.net.*;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.security.CodeSource;
+
+public final class UrlUtil {
+	public static final Path LOADER_CODE_SOURCE = getCodeSource(UrlUtil.class);
+
+	public static Path getCodeSource(URL url, String localPath) throws UrlConversionException {
+		try {
+			URLConnection connection = url.openConnection();
+
+			if (connection instanceof JarURLConnection) {
+				return asPath(((JarURLConnection) connection).getJarFileURL());
+			} else {
+				String path = url.getPath();
+
+				if (path.endsWith(localPath)) {
+					return asPath(new URL(url.getProtocol(), url.getHost(), url.getPort(), path.substring(0, path.length() - localPath.length())));
+				} else {
+					throw new UrlConversionException("Could not figure out code source for file '" + localPath + "' in URL '" + url + "'!");
+				}
+			}
+		} catch (Exception e) {
+			throw new UrlConversionException(e);
+		}
+	}
+
+	public static Path asPath(URL url) {
+		try {
+			return Paths.get(url.toURI());
+		} catch (URISyntaxException e) {
+			throw ExceptionUtil.wrap(e);
+		}
+	}
+
+	public static URL asUrl(File file) throws MalformedURLException {
+		return file.toURI().toURL();
+	}
+
+	public static URL asUrl(Path path) throws MalformedURLException {
+		return path.toUri().toURL();
+	}
+
+	public static Path getCodeSource(Class<?> cls) {
+		CodeSource cs = cls.getProtectionDomain().getCodeSource();
+		if (cs == null) return null;
+
+		return asPath(cs.getLocation());
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/log/BuiltinLogHandler.java b/src/main/java/net/fabricmc/loader/impl/util/log/BuiltinLogHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..8b6d2dcfaa99c8fd5d2f71a55746a0c753c2a1e5
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/log/BuiltinLogHandler.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.log;
+
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import net.fabricmc.loader.impl.util.SystemProperties;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.StandardOpenOption;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Default LogHandler until Log is initialized.
+ *
+ * <p>The log handler has the following properties:
+ * - log to stdout for anything but LogLevel.ERROR
+ * - log to stderr for LogLevel.ERROR
+ * - option to relay previous log output to another log handler if requested through Log.init
+ * - dumps previous log output to a log file if not closed/relayed yet
+ */
+final class BuiltinLogHandler extends ConsoleLogHandler {
+	private static final String DEFAULT_LOG_FILE = "fabricloader.log";
+
+	private boolean configured;
+	private boolean enableOutput;
+	private List<ReplayEntry> buffer = new ArrayList<>();
+	private final Thread shutdownHook;
+
+	BuiltinLogHandler() {
+		shutdownHook = new ShutdownHook();
+		Runtime.getRuntime().addShutdownHook(shutdownHook);
+	}
+
+	@Override
+	public void log(long time, LogLevel level, LogCategory category, String msg, Throwable exc, boolean fromReplay, boolean wasSuppressed) {
+		boolean output;
+
+		synchronized (this) {
+			if (enableOutput) {
+				output = true;
+			} else if (level.isLessThan(LogLevel.ERROR)) {
+				output = false;
+			} else {
+				startOutput();
+				output = true;
+			}
+
+			if (buffer != null) {
+				buffer.add(new ReplayEntry(time, level, category, msg, exc));
+			}
+		}
+
+		if (output) super.log(time, level, category, msg, exc, fromReplay, wasSuppressed);
+	}
+
+	private void startOutput() {
+		if (enableOutput) return;
+
+		if (buffer != null) {
+			for (int i = 0; i < buffer.size(); i++) { // index based loop to tolerate replay producing log output by itself
+				ReplayEntry entry = buffer.get(i);
+				super.log(entry.time, entry.level, entry.category, entry.msg, entry.exc, true, true);
+			}
+		}
+
+		enableOutput = true;
+	}
+
+	@Override
+	public void close() {
+		Thread shutdownHook = this.shutdownHook;
+
+		if (shutdownHook != null) {
+			try {
+				Runtime.getRuntime().removeShutdownHook(shutdownHook);
+			} catch (IllegalStateException e) {
+				// ignore
+			}
+		}
+	}
+
+	synchronized void configure(boolean buffer, boolean output) {
+		if (!buffer && !output) throw new IllegalArgumentException("can't both disable buffering and the output");
+
+		if (output) {
+			startOutput();
+		} else {
+			enableOutput = false;
+		}
+
+		if (buffer) {
+			if (this.buffer == null) this.buffer = new ArrayList<>();
+		} else {
+			this.buffer = null;
+		}
+
+		configured = true;
+	}
+
+	synchronized void finishConfig() {
+		if (!configured) configure(false, true);
+	}
+
+	synchronized boolean replay(LogHandler target) {
+		if (buffer == null || buffer.isEmpty()) return false;
+
+		for (int i = 0; i < buffer.size(); i++) { // index based loop to tolerate replay producing log output by itself
+			ReplayEntry entry = buffer.get(i);
+			target.log(entry.time, entry.level, entry.category, entry.msg, entry.exc, true, !enableOutput);
+		}
+
+		return true;
+	}
+
+	private static final class ReplayEntry {
+		ReplayEntry(long time, LogLevel level, LogCategory category, String msg, Throwable exc) {
+			this.time = time;
+			this.level = level;
+			this.category = category;
+			this.msg = msg;
+			this.exc = exc;
+		}
+
+		final long time;
+		final LogLevel level;
+		final LogCategory category;
+		final String msg;
+		final Throwable exc;
+	}
+
+	private final class ShutdownHook extends Thread {
+		ShutdownHook() {
+			super("BuiltinLogHandler shutdown hook");
+		}
+
+		@Override
+		public void run() {
+			synchronized (BuiltinLogHandler.this) {
+				if (buffer == null || buffer.isEmpty()) return;
+
+				if (!enableOutput) {
+					enableOutput = true;
+
+					for (int i = 0; i < buffer.size(); i++) { // index based loop to tolerate replay producing log output by itself
+						ReplayEntry entry = buffer.get(i);
+						BuiltinLogHandler.super.log(entry.time, entry.level, entry.category, entry.msg, entry.exc, true, true);
+					}
+				}
+
+				String fileName = System.getProperty(SystemProperties.LOG_FILE, DEFAULT_LOG_FILE);
+				if (fileName.isEmpty()) return;
+
+				try {
+					Path file = LoaderUtil.normalizePath(Paths.get(fileName));
+					Files.createDirectories(file.getParent());
+
+					try (Writer writer = Files.newBufferedWriter(file, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.CREATE)) {
+						for (int i = 0; i < buffer.size(); i++) { // index based loop to tolerate replay producing log output by itself
+							ReplayEntry entry = buffer.get(i);
+							writer.write(formatLog(entry.time, entry.level, entry.category, entry.msg, entry.exc));
+						}
+					}
+				} catch (IOException e) {
+					System.err.printf("Error saving log: %s", e);
+				}
+			}
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/log/ConsoleLogHandler.java b/src/main/java/net/fabricmc/loader/impl/util/log/ConsoleLogHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..81bd5320a855516fde9bbff726520b9b48ad5f1d
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/log/ConsoleLogHandler.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.log;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+public class ConsoleLogHandler implements LogHandler {
+	private static final LogLevel MIN_STDERR_LEVEL = LogLevel.ERROR;
+	private static final LogLevel MIN_STDOUT_LEVEL = LogLevel.getDefault();
+
+	@Override
+	public void log(long time, LogLevel level, LogCategory category, String msg, Throwable exc, boolean fromReplay, boolean wasSuppressed) {
+		String formatted = formatLog(time, level, category, msg, exc);
+
+		if (level.isLessThan(MIN_STDERR_LEVEL)) {
+			System.out.print(formatted);
+		} else {
+			System.err.print(formatted);
+		}
+	}
+
+	protected static String formatLog(long time, LogLevel level, LogCategory category, String msg, Throwable exc) {
+		String ret = String.format("[%tT] [%s] [%s/%s]: %s%n", time, level.name(), category.context, category.name, msg);
+
+		if (exc != null) {
+			StringWriter writer = new StringWriter(ret.length() + 500);
+
+			try (PrintWriter pw = new PrintWriter(writer, false)) {
+				pw.print(ret);
+				exc.printStackTrace(pw);
+			}
+
+			ret = writer.toString();
+		}
+
+		return ret;
+	}
+
+	@Override
+	public boolean shouldLog(LogLevel level, LogCategory category) {
+		return !level.isLessThan(MIN_STDOUT_LEVEL);
+	}
+
+	@Override
+	public void close() { }
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/log/Log.java b/src/main/java/net/fabricmc/loader/impl/util/log/Log.java
new file mode 100644
index 0000000000000000000000000000000000000000..ec89fa8ce1aa6c401ebe6ac02aad884f46329f94
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/log/Log.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.log;
+
+import java.util.Arrays;
+import java.util.IllegalFormatException;
+
+public final class Log {
+	public static final String NAME = "FabricLoader";
+	private static final boolean CHECK_FOR_BRACKETS = true;
+
+	private static LogHandler handler = new BuiltinLogHandler();
+
+	public static void init(LogHandler handler) {
+		if (handler == null) throw new NullPointerException("null log handler");
+
+		LogHandler oldHandler = Log.handler;
+
+		if (oldHandler instanceof BuiltinLogHandler) {
+			((BuiltinLogHandler) oldHandler).replay(handler);
+		}
+
+		Log.handler = handler;
+		oldHandler.close();
+	}
+
+	/**
+	 * Configure builtin log handler.
+	 *
+	 * @param buffer whether to buffer log messages for later replaying
+	 * @param output whether to output log messages directly
+	 */
+	public static void configureBuiltin(boolean buffer, boolean output) {
+		LogHandler handler = Log.handler;
+
+		if (handler instanceof BuiltinLogHandler) {
+			((BuiltinLogHandler) handler).configure(buffer, output);
+		}
+	}
+
+	/**
+	 * Finish configuring builtin log handler, using defaults if unconfigured.
+	 */
+	public static void finishBuiltinConfig() {
+		LogHandler handler = Log.handler;
+
+		if (handler instanceof BuiltinLogHandler) {
+			((BuiltinLogHandler) handler).finishConfig();
+		}
+	}
+
+	public static void error(LogCategory category, String format, Object... args) {
+		logFormat(LogLevel.ERROR, category, format, args);
+	}
+
+	public static void error(LogCategory category, String msg) {
+		log(LogLevel.ERROR, category, msg);
+	}
+
+	public static void error(LogCategory category, String msg, Throwable exc) {
+		log(LogLevel.ERROR, category, msg, exc);
+	}
+
+	public static void warn(LogCategory category, String format, Object... args) {
+		logFormat(LogLevel.WARN, category, format, args);
+	}
+
+	public static void warn(LogCategory category, String msg) {
+		log(LogLevel.WARN, category, msg);
+	}
+
+	public static void warn(LogCategory category, String msg, Throwable exc) {
+		log(LogLevel.WARN, category, msg, exc);
+	}
+
+	public static void info(LogCategory category, String format, Object... args) {
+		logFormat(LogLevel.INFO, category, format, args);
+	}
+
+	public static void info(LogCategory category, String msg) {
+		log(LogLevel.INFO, category, msg);
+	}
+
+	public static void info(LogCategory category, String msg, Throwable exc) {
+		log(LogLevel.INFO, category, msg, exc);
+	}
+
+	public static void debug(LogCategory category, String format, Object... args) {
+		logFormat(LogLevel.DEBUG, category, format, args);
+	}
+
+	public static void debug(LogCategory category, String msg) {
+		log(LogLevel.DEBUG, category, msg);
+	}
+
+	public static void debug(LogCategory category, String msg, Throwable exc) {
+		log(LogLevel.DEBUG, category, msg, exc);
+	}
+
+	public static void trace(LogCategory category, String format, Object... args) {
+		logFormat(LogLevel.TRACE, category, format, args);
+	}
+
+	public static void trace(LogCategory category, String msg) {
+		log(LogLevel.TRACE, category, msg);
+	}
+
+	public static void trace(LogCategory category, String msg, Throwable exc) {
+		log(LogLevel.TRACE, category, msg, exc);
+	}
+
+	public static void log(LogLevel level, LogCategory category, String msg) {
+		LogHandler handler = Log.handler;
+		if (handler.shouldLog(level, category)) log(handler, level, category, msg, null);
+	}
+
+	public static void log(LogLevel level, LogCategory category, String msg, Throwable exc) {
+		LogHandler handler = Log.handler;
+		if (handler.shouldLog(level, category)) log(handler, level, category, msg, exc);
+	}
+
+	public static void logFormat(LogLevel level, LogCategory category, String format, Object... args) {
+		LogHandler handler = Log.handler;
+		if (!handler.shouldLog(level, category)) return;
+
+		String msg;
+		Throwable exc;
+
+		if (args.length == 0) {
+			//assert getRequiredArgs(format.toString()) == 0;
+
+			msg = format;
+			exc = null;
+		} else {
+			if (CHECK_FOR_BRACKETS) {
+				if (format.indexOf("{}") != -1) throw new IllegalArgumentException("log message containing {}: "+format);
+			}
+
+			Object lastArg = args[args.length - 1];
+			Object[] newArgs;
+
+			if (lastArg instanceof Throwable && getRequiredArgs(format) < args.length) {
+				exc = (Throwable) lastArg;
+				newArgs = Arrays.copyOf(args, args.length - 1);
+			} else {
+				exc = null;
+				newArgs = args;
+			}
+
+			assert getRequiredArgs(format) == newArgs.length;
+
+			try {
+				msg = String.format(format, newArgs);
+			} catch (IllegalFormatException e) {
+				msg = "Format error: fmt=["+format+"] args="+Arrays.toString(args);
+				warn(LogCategory.LOG, "Invalid format string.", e);
+			}
+		}
+
+		log(handler, level, category, msg, exc);
+	}
+
+	private static int getRequiredArgs(String format) {
+		int ret = 0;
+		int minRet = 0;
+		boolean wasPct = false;
+
+		for (int i = 0, max = format.length(); i < max; i++) {
+			char c = format.charAt(i);
+
+			if (c == '%') {
+				wasPct = !wasPct;
+			} else if (wasPct) {
+				wasPct = false;
+
+				if (c == 'n' || c == '<') { // not %n or %<x
+					continue;
+				}
+
+				if (c >= '0' && c <= '9') { // abs indexing %12$
+					int start = i;
+
+					while (i + 1 < format.length()
+							&& (c = format.charAt(i + 1)) >= '0' && c <= '9') {
+						i++;
+					}
+
+					if (i + 1 < format.length() && format.charAt(i + 1) == '$') {
+						i++;
+						minRet = Math.max(minRet, Integer.parseInt(format.substring(start, i)) + 1);
+						continue;
+					} else {
+						i = start;
+					}
+				}
+
+				ret++;
+			}
+		}
+
+		return Math.max(ret, minRet);
+	}
+
+	private static void log(LogHandler handler, LogLevel level, LogCategory category, String msg, Throwable exc) {
+		handler.log(System.currentTimeMillis(), level, category, msg.trim(), exc, false, false);
+	}
+
+	public static boolean shouldLog(LogLevel level, LogCategory category) {
+		return handler.shouldLog(level, category);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/log/LogCategory.java b/src/main/java/net/fabricmc/loader/impl/util/log/LogCategory.java
new file mode 100644
index 0000000000000000000000000000000000000000..9d56c5234bc0866536a79bf8d67a866cb0991d71
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/log/LogCategory.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.log;
+
+public final class LogCategory {
+	public static final LogCategory DISCOVERY = create("Discovery");
+	public static final LogCategory ENTRYPOINT = create("Entrypoint");
+	public static final LogCategory GAME_PATCH = create("GamePatch");
+	public static final LogCategory GAME_PROVIDER = create("GameProvider");
+	public static final LogCategory GAME_REMAP = create("GameRemap");
+	public static final LogCategory GENERAL = create();
+	public static final LogCategory KNOT = create("Knot");
+	public static final LogCategory LIB_CLASSIFICATION = create("LibClassify");
+	public static final LogCategory LOG = create("Log");
+	public static final LogCategory MAPPINGS = create("Mappings");
+	public static final LogCategory METADATA = create("Metadata");
+	public static final LogCategory MOD_REMAP = create("ModRemap");
+	public static final LogCategory MIXIN = create("Mixin");
+	public static final LogCategory RESOLUTION = create("Resolution");
+	public static final LogCategory TEST = create("Test");
+
+	public static final String SEPARATOR = "/";
+
+	public final String context;
+	public final String name;
+	public Object data;
+
+	public static LogCategory create(String... names) {
+		return new LogCategory(Log.NAME, names);
+	}
+
+	/**
+	 * Create a log category for external uses, no API guarantees!
+	 */
+	public static LogCategory createCustom(String context, String... names) {
+		return new LogCategory(context, names);
+	}
+
+	private LogCategory(String context, String[] names) {
+		this.context = context;
+		this.name = String.join(SEPARATOR, names);
+	}
+
+	@Override
+	public String toString() {
+		return name.isEmpty() ? context : context+SEPARATOR+name;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/log/LogHandler.java b/src/main/java/net/fabricmc/loader/impl/util/log/LogHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..63c04f57188c70c810c65b8b8e904e6c49424877
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/log/LogHandler.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.log;
+
+public interface LogHandler {
+	void log(long time, LogLevel level, LogCategory category, String msg, Throwable exc, boolean fromReplay, boolean wasSuppressed);
+	boolean shouldLog(LogLevel level, LogCategory category);
+	void close();
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/log/LogLevel.java b/src/main/java/net/fabricmc/loader/impl/util/log/LogLevel.java
new file mode 100644
index 0000000000000000000000000000000000000000..5126d544ff4f88f1e7e18a00510964d4f290aec2
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/log/LogLevel.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.log;
+
+import net.fabricmc.loader.impl.util.SystemProperties;
+
+import java.util.Locale;
+
+public enum LogLevel {
+	ERROR, WARN, INFO, DEBUG, TRACE;
+
+	public boolean isLessThan(LogLevel level) {
+		return ordinal() > level.ordinal();
+	}
+
+	public static LogLevel getDefault() {
+		String val = System.getProperty(SystemProperties.LOG_LEVEL);
+		if (val == null) return INFO;
+
+		LogLevel ret = LogLevel.valueOf(val.toUpperCase(Locale.ENGLISH));
+		if (ret == null) throw new IllegalArgumentException("invalid log level: "+val);
+
+		return ret;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/mappings/MixinIntermediaryDevRemapper.java b/src/main/java/net/fabricmc/loader/impl/util/mappings/MixinIntermediaryDevRemapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..188bdd56b7d62e0ecb1762de4ef1f810143afc46
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/mappings/MixinIntermediaryDevRemapper.java
@@ -0,0 +1,230 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.mappings;
+
+import net.fabricmc.mapping.tree.ClassDef;
+import net.fabricmc.mapping.tree.Descriptored;
+import net.fabricmc.mapping.tree.TinyTree;
+import net.fabricmc.mapping.util.MixinRemapper;
+import org.spongepowered.asm.mixin.transformer.ClassInfo;
+
+import java.util.*;
+
+public class MixinIntermediaryDevRemapper extends MixinRemapper {
+	private static final String ambiguousName = "<ambiguous>"; // dummy value for ambiguous mappings - needs querying with additional owner and/or desc info
+
+	private final Set<String> allPossibleClassNames = new HashSet<>();
+	private final Map<String, String> nameFieldLookup = new HashMap<>();
+	private final Map<String, String> nameMethodLookup = new HashMap<>();
+	private final Map<String, String> nameDescFieldLookup = new HashMap<>();
+	private final Map<String, String> nameDescMethodLookup = new HashMap<>();
+
+	public MixinIntermediaryDevRemapper(TinyTree mappings, String from, String to) {
+		super(mappings, from, to);
+
+		for (ClassDef classDef : mappings.getClasses()) {
+			allPossibleClassNames.add(classDef.getName(from));
+			allPossibleClassNames.add(classDef.getName(to));
+
+			putMemberInLookup(from, to, classDef.getFields(), nameFieldLookup, nameDescFieldLookup);
+			putMemberInLookup(from, to, classDef.getMethods(), nameMethodLookup, nameDescMethodLookup);
+		}
+	}
+
+	private <T extends Descriptored> void putMemberInLookup(String from, String to, Collection<T> descriptored, Map<String, String> nameMap, Map<String, String> nameDescMap) {
+		for (T field : descriptored) {
+			String nameFrom = field.getName(from);
+			String descFrom = field.getDescriptor(from);
+			String nameTo = field.getName(to);
+
+			String prev = nameMap.putIfAbsent(nameFrom, nameTo);
+
+			if (prev != null && prev != ambiguousName && !prev.equals(nameTo)) {
+				nameDescMap.put(nameFrom, ambiguousName);
+			}
+
+			String key = getNameDescKey(nameFrom, descFrom);
+			prev = nameDescMap.putIfAbsent(key, nameTo);
+
+			if (prev != null && prev != ambiguousName && !prev.equals(nameTo)) {
+				nameDescMap.put(key, ambiguousName);
+			}
+		}
+	}
+
+	private void throwAmbiguousLookup(String type, String name, String desc) {
+		throw new RuntimeException("Ambiguous Mixin: " + type + " lookup " + name + " " + desc+" is not unique");
+	}
+
+	private String mapMethodNameInner(String owner, String name, String desc) {
+		String result = super.mapMethodName(owner, name, desc);
+
+		if (result.equals(name)) {
+			String otherClass = unmap(owner);
+			return super.mapMethodName(otherClass, name, unmapDesc(desc));
+		} else {
+			return result;
+		}
+	}
+
+	private String mapFieldNameInner(String owner, String name, String desc) {
+		String result = super.mapFieldName(owner, name, desc);
+
+		if (result.equals(name)) {
+			String otherClass = unmap(owner);
+			return super.mapFieldName(otherClass, name, unmapDesc(desc));
+		} else {
+			return result;
+		}
+	}
+
+	@Override
+	public String mapMethodName(String owner, String name, String desc) {
+		// handle unambiguous values early
+		if (owner == null || allPossibleClassNames.contains(owner)) {
+			String newName;
+
+			if (desc == null) {
+				newName = nameMethodLookup.get(name);
+			} else {
+				newName = nameDescMethodLookup.get(getNameDescKey(name, desc));
+			}
+
+			if (newName != null) {
+				if (newName == ambiguousName) {
+					if (owner == null) {
+						throwAmbiguousLookup("method", name, desc);
+					}
+				} else {
+					return newName;
+				}
+			} else if (owner == null) {
+				return name;
+			} else {
+				// FIXME: this kind of namespace mixing shouldn't happen..
+				// TODO: this should not repeat more than once
+				String unmapOwner = unmap(owner);
+				String unmapDesc = unmapDesc(desc);
+
+				if (!unmapOwner.equals(owner) || !unmapDesc.equals(desc)) {
+					return mapMethodName(unmapOwner, name, unmapDesc);
+				} else {
+					// take advantage of the fact allPossibleClassNames
+					// and nameDescLookup cover all sets; if none are present,
+					// we don't have a mapping for it.
+					return name;
+				}
+			}
+		}
+
+		ClassInfo classInfo = ClassInfo.forName(owner);
+
+		if (classInfo == null) { // unknown class?
+			return name;
+		}
+
+		Queue<ClassInfo> queue = new ArrayDeque<>();
+
+		do {
+			String ownerO = unmap(classInfo.getName());
+			String s;
+
+			if (!(s = mapMethodNameInner(ownerO, name, desc)).equals(name)) {
+				return s;
+			}
+
+			if (!classInfo.getSuperName().startsWith("java/")) {
+				ClassInfo cSuper = classInfo.getSuperClass();
+
+				if (cSuper != null) {
+					queue.add(cSuper);
+				}
+			}
+
+			for (String itf : classInfo.getInterfaces()) {
+				if (itf.startsWith("java/")) {
+					continue;
+				}
+
+				ClassInfo cItf = ClassInfo.forName(itf);
+
+				if (cItf != null) {
+					queue.add(cItf);
+				}
+			}
+		} while ((classInfo = queue.poll()) != null);
+
+		return name;
+	}
+
+	@Override
+	public String mapFieldName(String owner, String name, String desc) {
+		// handle unambiguous values early
+		if (owner == null || allPossibleClassNames.contains(owner)) {
+			String newName = nameDescFieldLookup.get(getNameDescKey(name, desc));
+
+			if (newName != null) {
+				if (newName == ambiguousName) {
+					if (owner == null) {
+						throwAmbiguousLookup("field", name, desc);
+					}
+				} else {
+					return newName;
+				}
+			} else if (owner == null) {
+				return name;
+			} else {
+				// FIXME: this kind of namespace mixing shouldn't happen..
+				// TODO: this should not repeat more than once
+				String unmapOwner = unmap(owner);
+				String unmapDesc = unmapDesc(desc);
+
+				if (!unmapOwner.equals(owner) || !unmapDesc.equals(desc)) {
+					return mapFieldName(unmapOwner, name, unmapDesc);
+				} else {
+					// take advantage of the fact allPossibleClassNames
+					// and nameDescLookup cover all sets; if none are present,
+					// we don't have a mapping for it.
+					return name;
+				}
+			}
+		}
+
+		ClassInfo c = ClassInfo.forName(map(owner));
+
+		while (c != null) {
+			String nextOwner = unmap(c.getName());
+			String s = mapFieldNameInner(nextOwner, name, desc);
+
+			if (!s.equals(name)) {
+				return s;
+			}
+
+			if (c.getSuperName().startsWith("java/")) {
+				break;
+			}
+
+			c = c.getSuperClass();
+		}
+
+		return name;
+	}
+
+	private static String getNameDescKey(String name, String descriptor) {
+		return name+ ";;" + descriptor;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/mappings/TinyRemapperMappingsHelper.java b/src/main/java/net/fabricmc/loader/impl/util/mappings/TinyRemapperMappingsHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..9a8aea652fcb637145702d3b039d911127e73148
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/mappings/TinyRemapperMappingsHelper.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.mappings;
+
+import net.fabricmc.mapping.tree.ClassDef;
+import net.fabricmc.mapping.tree.FieldDef;
+import net.fabricmc.mapping.tree.MethodDef;
+import net.fabricmc.mapping.tree.TinyTree;
+import net.fabricmc.tinyremapper.IMappingProvider;
+
+public class TinyRemapperMappingsHelper {
+	private TinyRemapperMappingsHelper() { }
+
+	private static IMappingProvider.Member memberOf(String className, String memberName, String descriptor) {
+		return new IMappingProvider.Member(className, memberName, descriptor);
+	}
+
+	public static IMappingProvider create(TinyTree mappings, String from, String to) {
+		return (acceptor) -> {
+			for (ClassDef classDef : mappings.getClasses()) {
+				String className = classDef.getName(from);
+				acceptor.acceptClass(className, classDef.getName(to));
+
+				for (FieldDef field : classDef.getFields()) {
+					acceptor.acceptField(memberOf(className, field.getName(from), field.getDescriptor(from)), field.getName(to));
+				}
+
+				for (MethodDef method : classDef.getMethods()) {
+					IMappingProvider.Member methodIdentifier = memberOf(className, method.getName(from), method.getDescriptor(from));
+					acceptor.acceptMethod(methodIdentifier, method.getName(to));
+				}
+			}
+		};
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/version/SemanticVersionImpl.java b/src/main/java/net/fabricmc/loader/impl/util/version/SemanticVersionImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..cdd22f5497a29bcb7731a386e74e0ba843cd3915
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/version/SemanticVersionImpl.java
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.version;
+
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+
+import java.util.Arrays;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.StringTokenizer;
+import java.util.regex.Pattern;
+
+/**
+ * Parser for a superset of the semantic version format described at <a href="https://semver.org">semver.org</a>.
+ *
+ * <p>This superset allows additionally
+ * <ul><li>Arbitrary number of {@code <version core>} components, but at least 1
+ * <li>{@code x}, {@code X} or {@code *} for the last {@code <version core>} component with {@code storeX} if not the first
+ * <li>Arbitrary {@code <build>} contents
+ * </ul>
+ */
+@SuppressWarnings("deprecation")
+public class SemanticVersionImpl implements SemanticVersion {
+	private static final Pattern DOT_SEPARATED_ID = Pattern.compile("|[-0-9A-Za-z]+(\\.[-0-9A-Za-z]+)*");
+	private static final Pattern UNSIGNED_INTEGER = Pattern.compile("0|[1-9][0-9]*");
+	private final int[] components;
+	private final String prerelease;
+	private final String build;
+	private String friendlyName;
+
+	public SemanticVersionImpl(String version, boolean storeX) throws Exception {
+		int buildDelimPos = version.indexOf('+');
+
+		if (buildDelimPos >= 0) {
+			build = version.substring(buildDelimPos + 1);
+			version = version.substring(0, buildDelimPos);
+		} else {
+			build = null;
+		}
+
+		int dashDelimPos = version.indexOf('-');
+
+		if (dashDelimPos >= 0) {
+			prerelease = version.substring(dashDelimPos + 1);
+			version = version.substring(0, dashDelimPos);
+		} else {
+			prerelease = null;
+		}
+
+		if (prerelease != null && !DOT_SEPARATED_ID.matcher(prerelease).matches()) {
+			throw new Exception("Invalid prerelease string '" + prerelease + "'!");
+		}
+
+		if (version.endsWith(".")) {
+			throw new Exception("Negative version number component found!");
+		} else if (version.startsWith(".")) {
+			throw new Exception("Missing version component!");
+		}
+
+		String[] componentStrings = version.split("\\.");
+
+		if (componentStrings.length < 1) {
+			throw new Exception("Did not provide version numbers!");
+		}
+
+		int[] components = new int[componentStrings.length];
+		int firstWildcardIdx = -1;
+
+		for (int i = 0; i < componentStrings.length; i++) {
+			String compStr = componentStrings[i];
+
+			if (storeX) {
+				if (compStr.equals("x") || compStr.equals("X") || compStr.equals("*")) {
+					if (prerelease != null) {
+						throw new Exception("Pre-release versions are not allowed to use X-ranges!");
+					}
+
+					components[i] = COMPONENT_WILDCARD;
+					if (firstWildcardIdx < 0) firstWildcardIdx = i;
+					continue;
+				} else if (i > 0 && components[i - 1] == COMPONENT_WILDCARD) {
+					throw new Exception("Interjacent wildcard (1.x.2) are disallowed!");
+				}
+			}
+
+			if (compStr.trim().isEmpty()) {
+				throw new VersionParsingException("Missing version number component!");
+			}
+
+			try {
+				components[i] = Integer.parseInt(compStr);
+
+				if (components[i] < 0) {
+					throw new VersionParsingException("Negative version number component '" + compStr + "'!");
+				}
+			} catch (NumberFormatException e) {
+				throw new VersionParsingException("Could not parse version number component '" + compStr + "'!", e);
+			}
+		}
+
+		if (storeX && components.length == 1 && components[0] == COMPONENT_WILDCARD) {
+			throw new VersionParsingException("Versions of form 'x' or 'X' not allowed!");
+		}
+
+		// strip extra wildcards (1.x.x -> 1.x)
+		if (firstWildcardIdx > 0 && components.length > firstWildcardIdx + 1) {
+			components = Arrays.copyOf(components, firstWildcardIdx + 1);
+		}
+
+		this.components = components;
+
+		buildFriendlyName();
+	}
+
+	public SemanticVersionImpl(int[] components, String prerelease, String build) {
+		if (components.length == 0 || components[0] == COMPONENT_WILDCARD) throw new IllegalArgumentException("Invalid components: "+Arrays.toString(components));
+
+		this.components = components;
+		this.prerelease = prerelease;
+		this.build = build;
+
+		buildFriendlyName();
+	}
+
+	private void buildFriendlyName() {
+		StringBuilder fnBuilder = new StringBuilder();
+		boolean first = true;
+
+		for (int i : components) {
+			if (first) {
+				first = false;
+			} else {
+				fnBuilder.append('.');
+			}
+
+			if (i == COMPONENT_WILDCARD) {
+				fnBuilder.append('x');
+			} else {
+				fnBuilder.append(i);
+			}
+		}
+
+		if (prerelease != null) {
+			fnBuilder.append('-').append(prerelease);
+		}
+
+		if (build != null) {
+			fnBuilder.append('+').append(build);
+		}
+
+		friendlyName = fnBuilder.toString();
+	}
+
+	@Override
+	public int getVersionComponentCount() {
+		return components.length;
+	}
+
+	@Override
+	public int getVersionComponent(int pos) {
+		if (pos < 0) {
+			throw new RuntimeException("Tried to access negative version number component!");
+		} else if (pos >= components.length) {
+			// Repeat "x" if x-range, otherwise repeat "0".
+			return components[components.length - 1] == COMPONENT_WILDCARD ? COMPONENT_WILDCARD : 0;
+		} else {
+			return components[pos];
+		}
+	}
+
+	public int[] getVersionComponents() {
+		return components.clone();
+	}
+
+	@Override
+	public Optional<String> getPrereleaseKey() {
+		return Optional.ofNullable(prerelease);
+	}
+
+	@Override
+	public Optional<String> getBuildKey() {
+		return Optional.ofNullable(build);
+	}
+
+	@Override
+	public String getFriendlyString() {
+		return friendlyName;
+	}
+
+	@Override
+	public boolean equals(Object o) {
+		if (!(o instanceof SemanticVersionImpl)) {
+			return false;
+		} else {
+			SemanticVersionImpl other = (SemanticVersionImpl) o;
+
+			if (!equalsComponentsExactly(other)) {
+				return false;
+			}
+
+			return Objects.equals(prerelease, other.prerelease) && Objects.equals(build, other.build);
+		}
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(components) * 73 + (prerelease != null ? prerelease.hashCode() * 11 : 0) + (build != null ? build.hashCode() : 0);
+	}
+
+	@Override
+	public String toString() {
+		return getFriendlyString();
+	}
+
+	@Override
+	public boolean hasWildcard() {
+		for (int i : components) {
+			if (i < 0) {
+				return true;
+			}
+		}
+
+		return false;
+	}
+
+	public boolean equalsComponentsExactly(SemanticVersionImpl other) {
+		for (int i = 0; i < Math.max(getVersionComponentCount(), other.getVersionComponentCount()); i++) {
+			if (getVersionComponent(i) != other.getVersionComponent(i)) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	@Override
+	public int compareTo(Version other) {
+		if (!(other instanceof SemanticVersion)) {
+			return getFriendlyString().compareTo(other.getFriendlyString());
+		}
+
+		SemanticVersion o = (SemanticVersion) other;
+
+		for (int i = 0; i < Math.max(getVersionComponentCount(), o.getVersionComponentCount()); i++) {
+			int first = getVersionComponent(i);
+			int second = o.getVersionComponent(i);
+
+			if (first == COMPONENT_WILDCARD || second == COMPONENT_WILDCARD) {
+				continue;
+			}
+
+			int compare = Integer.compare(first, second);
+			if (compare != 0) return compare;
+		}
+
+		Optional<String> prereleaseA = getPrereleaseKey();
+		Optional<String> prereleaseB = o.getPrereleaseKey();
+
+		if (prereleaseA.isPresent() || prereleaseB.isPresent()) {
+			if (prereleaseA.isPresent() && prereleaseB.isPresent()) {
+				StringTokenizer prereleaseATokenizer = new StringTokenizer(prereleaseA.get(), ".");
+				StringTokenizer prereleaseBTokenizer = new StringTokenizer(prereleaseB.get(), ".");
+
+				while (prereleaseATokenizer.hasMoreElements()) {
+					if (prereleaseBTokenizer.hasMoreElements()) {
+						String partA = prereleaseATokenizer.nextToken();
+						String partB = prereleaseBTokenizer.nextToken();
+
+						if (UNSIGNED_INTEGER.matcher(partA).matches()) {
+							if (UNSIGNED_INTEGER.matcher(partB).matches()) {
+								int compare = Integer.compare(partA.length(), partB.length());
+								if (compare != 0) return compare;
+							} else {
+								return -1;
+							}
+						} else {
+							if (UNSIGNED_INTEGER.matcher(partB).matches()) {
+								return 1;
+							}
+						}
+
+						int compare = partA.compareTo(partB);
+						if (compare != 0) return compare;
+					} else {
+						return 1;
+					}
+				}
+
+				return prereleaseBTokenizer.hasMoreElements() ? -1 : 0;
+			} else if (prereleaseA.isPresent()) {
+				return o.hasWildcard() ? 0 : -1;
+			} else { // prereleaseB.isPresent()
+				return hasWildcard() ? 0 : 1;
+			}
+		} else {
+			return 0;
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/version/StringVersion.java b/src/main/java/net/fabricmc/loader/impl/util/version/StringVersion.java
new file mode 100644
index 0000000000000000000000000000000000000000..9914d7165b7a876c2a0646e2fc0f7fdd83e41673
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/version/StringVersion.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.version;
+
+import net.fabricmc.loader.api.Version;
+
+public class StringVersion implements Version {
+	private final String version;
+
+	public StringVersion(String version) {
+		this.version = version;
+	}
+
+	@Override
+	public String getFriendlyString() {
+		return version;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (obj instanceof StringVersion) {
+			return version.equals(((StringVersion) obj).version);
+		} else {
+			return false;
+		}
+	}
+
+	@Override
+	public int compareTo(Version o) {
+		return getFriendlyString().compareTo(o.getFriendlyString());
+	}
+
+	@Override
+	public String toString() {
+		return version;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/version/VersionIntervalImpl.java b/src/main/java/net/fabricmc/loader/impl/util/version/VersionIntervalImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..21d57cefcb957c749f3dbc0b6658bba3a6954778
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/version/VersionIntervalImpl.java
@@ -0,0 +1,478 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.version;
+
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.metadata.version.VersionInterval;
+
+import java.util.*;
+
+public final class VersionIntervalImpl implements VersionInterval {
+	private final Version min;
+	private final boolean minInclusive;
+	private final Version max;
+	private final boolean maxInclusive;
+
+	public VersionIntervalImpl(Version min, boolean minInclusive,
+			Version max, boolean maxInclusive) {
+		this.min = min;
+		this.minInclusive = min != null ? minInclusive : false;
+		this.max = max;
+		this.maxInclusive = max != null ? maxInclusive : false;
+
+		assert min != null || !minInclusive;
+		assert max != null || !maxInclusive;
+		assert min == null || min instanceof SemanticVersion || minInclusive;
+		assert max == null || max instanceof SemanticVersion || maxInclusive;
+		assert min == null || max == null || min instanceof SemanticVersion && max instanceof SemanticVersion || min.equals(max);
+	}
+
+	@Override
+	public boolean isSemantic() {
+		return (min == null || min instanceof SemanticVersion)
+				&& (max == null || max instanceof SemanticVersion);
+	}
+
+	@Override
+	public Version getMin() {
+		return min;
+	}
+
+	@Override
+	public boolean isMinInclusive() {
+		return minInclusive;
+	}
+
+	@Override
+	public Version getMax() {
+		return max;
+	}
+
+	@Override
+	public boolean isMaxInclusive() {
+		return maxInclusive;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (obj instanceof VersionInterval) {
+			VersionInterval o = (VersionInterval) obj;
+
+			return Objects.equals(min, o.getMin()) && minInclusive == o.isMinInclusive()
+					&& Objects.equals(max, o.getMax()) && maxInclusive == o.isMaxInclusive();
+		} else {
+			return false;
+		}
+	}
+
+	@Override
+	public int hashCode() {
+		return (Objects.hashCode(min) + (minInclusive ? 1 : 0)) * 31
+				+ (Objects.hashCode(max) + (maxInclusive ? 1 : 0)) * 31;
+	}
+
+	@Override
+	public String toString() {
+		if (min == null) {
+			if (max == null) {
+				return "(-,)";
+			} else {
+				return String.format("(-,%s%c", max, maxInclusive ? ']' : ')');
+			}
+		} else if (max == null) {
+			return String.format("%c%s,)", minInclusive ? '[' : '(', min);
+		} else {
+			return String.format("%c%s,%s%c", minInclusive ? '[' : '(', min, max, maxInclusive ? ']' : ')');
+		}
+	}
+
+	public static VersionInterval and(VersionInterval a, VersionInterval b) {
+		if (a == null || b == null) return null;
+
+		if (!a.isSemantic() || !b.isSemantic()) {
+			return andPlain(a, b);
+		} else {
+			return andSemantic(a, b);
+		}
+	}
+
+	private static VersionInterval andPlain(VersionInterval a, VersionInterval b) {
+		Version aMin = a.getMin();
+		Version aMax = a.getMax();
+		Version bMin = b.getMin();
+		Version bMax = b.getMax();
+
+		if (aMin != null) { // -> min must be aMin or invalid
+			if (bMin != null && !aMin.equals(bMin) || bMax != null && !aMin.equals(bMax)) {
+				return null;
+			}
+
+			if (aMax != null || bMax == null) {
+				assert Objects.equals(aMax, bMax) || bMax == null;
+				return a;
+			} else {
+				return new VersionIntervalImpl(aMin, true, bMax, b.isMaxInclusive());
+			}
+		} else if (aMax != null) { // -> min must be bMin, max must be aMax or invalid
+			if (bMin != null && !aMax.equals(bMin) || bMax != null && !aMax.equals(bMax)) {
+				return null;
+			}
+
+			if (bMin == null) {
+				return a;
+			} else if (bMax != null) {
+				return b;
+			} else {
+				return new VersionIntervalImpl(bMin, true, aMax, true);
+			}
+		} else {
+			return b;
+		}
+	}
+
+	private static VersionInterval andSemantic(VersionInterval a, VersionInterval b) {
+		int minCmp = compareMin(a, b);
+		int maxCmp = compareMax(a, b);
+
+		if (minCmp == 0) { // aMin == bMin
+			if (maxCmp == 0) { // aMax == bMax -> a == b -> a/b
+				return a;
+			} else { // aMax != bMax -> a/b..min(a,b)
+				return maxCmp < 0 ? a : b;
+			}
+		} else if (maxCmp == 0) { // aMax == bMax, aMin != bMin -> max(a,b)..a/b
+			return minCmp < 0 ? b : a;
+		} else if (minCmp < 0) { // aMin < bMin, aMax != bMax -> b..min(a,b)
+			if (maxCmp > 0) return b; // a > b -> b
+
+			SemanticVersion aMax = (SemanticVersion) a.getMax();
+			SemanticVersion bMin = (SemanticVersion) b.getMin();
+			int cmp = bMin.compareTo((Version) aMax);
+
+			if (cmp < 0 || cmp == 0 && b.isMinInclusive() && a.isMaxInclusive()) {
+				return new VersionIntervalImpl(bMin, b.isMinInclusive(), aMax, a.isMaxInclusive());
+			} else {
+				return null;
+			}
+		} else { // aMin > bMin, aMax != bMax -> a..min(a,b)
+			if (maxCmp < 0) return a; // a < b -> a
+
+			SemanticVersion aMin = (SemanticVersion) a.getMin();
+			SemanticVersion bMax = (SemanticVersion) b.getMax();
+			int cmp = aMin.compareTo((Version) bMax);
+
+			if (cmp < 0 || cmp == 0 && a.isMinInclusive() && b.isMaxInclusive()) {
+				return new VersionIntervalImpl(aMin, a.isMinInclusive(), bMax, b.isMaxInclusive());
+			} else {
+				return null;
+			}
+		}
+	}
+
+	public static List<VersionInterval> and(Collection<VersionInterval> a, Collection<VersionInterval> b) {
+		if (a.isEmpty() || b.isEmpty()) return Collections.emptyList();
+
+		if (a.size() == 1 && b.size() == 1) {
+			VersionInterval merged = and(a.iterator().next(), b.iterator().next());
+			return merged != null ? Collections.singletonList(merged) : Collections.emptyList();
+		}
+
+		// (a0 || a1 || a2) && (b0 || b1 || b2) == a0 && b0 && b1 && b2 || a1 && b0 && b1 && b2 || a2 && b0 && b1 && b2
+
+		List<VersionInterval> allMerged = new ArrayList<>();
+
+		for (VersionInterval intervalA : a) {
+			for (VersionInterval intervalB : b) {
+				VersionInterval merged = and(intervalA, intervalB);
+				if (merged != null) allMerged.add(merged);
+			}
+		}
+
+		if (allMerged.isEmpty()) return Collections.emptyList();
+		if (allMerged.size() == 1) return allMerged;
+
+		List<VersionInterval> ret = new ArrayList<>(allMerged.size());
+
+		for (VersionInterval v : allMerged) {
+			merge(v, ret);
+		}
+
+		return ret;
+	}
+
+	public static List<VersionInterval> or(Collection<VersionInterval> a, VersionInterval b) {
+		if (a.isEmpty()) {
+			if (b == null) {
+				return Collections.emptyList();
+			} else {
+				return Collections.singletonList(b);
+			}
+		}
+
+		List<VersionInterval> ret = new ArrayList<>(a.size() + 1);
+
+		for (VersionInterval v : a) {
+			merge(v, ret);
+		}
+
+		merge(b, ret);
+
+		return ret;
+	}
+
+	private static void merge(VersionInterval a, List<VersionInterval> out) {
+		if (a == null) return;
+
+		if (out.isEmpty()) {
+			out.add(a);
+			return;
+		}
+
+		if (out.size() == 1) {
+			VersionInterval e = out.get(0);
+
+			if (e.getMin() == null && e.getMax() == null) {
+				return;
+			}
+		}
+
+		if (!a.isSemantic()) {
+			mergePlain(a, out);
+		} else {
+			mergeSemantic(a, out);
+		}
+	}
+
+	private static void mergePlain(VersionInterval a, List<VersionInterval> out) {
+		Version aMin = a.getMin();
+		Version aMax = a.getMax();
+		Version v = aMin != null ? aMin : aMax;
+		assert v != null;
+
+		for (int i = 0; i < out.size(); i++) {
+			VersionInterval c = out.get(i);
+
+			if (v.equals(c.getMin())) {
+				if (aMin == null) {
+					assert aMax.equals(c.getMin());
+					out.clear();
+					out.add(INFINITE);
+				} else if (aMax == null && c.getMax() != null) {
+					out.set(i, a);
+				}
+
+				return;
+			} else if (v.equals(c.getMax())) {
+				assert c.getMin() == null;
+
+				if (aMax == null) {
+					assert aMin.equals(c.getMax());
+					out.clear();
+					out.add(INFINITE);
+				}
+
+				return;
+			}
+		}
+
+		out.add(a);
+	}
+
+	private static void mergeSemantic(VersionInterval a, List<VersionInterval> out) {
+		SemanticVersion aMin = (SemanticVersion) a.getMin();
+		SemanticVersion aMax = (SemanticVersion) a.getMax();
+
+		if (aMin == null && aMax == null) {
+			out.clear();
+			out.add(INFINITE);
+			return;
+		}
+
+		for (int i = 0; i < out.size(); i++) {
+			VersionInterval c = out.get(i);
+			if (!c.isSemantic()) continue;
+
+			SemanticVersion cMin = (SemanticVersion) c.getMin();
+			SemanticVersion cMax = (SemanticVersion) c.getMax();
+			int cmp;
+
+			if (aMin == null) { // ..a..]
+				if (cMax == null) { // ..a..] [..c..
+					cmp = aMax.compareTo((Version) cMin);
+
+					if (cmp < 0 || cmp == 0 && !a.isMaxInclusive() && !c.isMinInclusive()) { // ..a..]..[..c.. or ..a..)(..c..
+						out.add(i, a);
+					} else { // ..a..|..c.. or ..a.[..].c..
+						out.clear();
+						out.add(INFINITE);
+					}
+
+					return;
+				} else { // ..a..] [..c..]
+					cmp = compareMax(a, c);
+
+					if (cmp >= 0) { // a encompasses c
+						out.remove(i);
+						i--;
+					} else if (cMin == null) { // c encompasses a
+						return;
+					} else { // aMax < cMax
+						cmp = aMax.compareTo((Version) cMin);
+
+						if (cmp < 0 || cmp == 0 && !a.isMaxInclusive() && !c.isMinInclusive()) { // ..a..]..[..c..] or ..a..)(..c..]
+							out.add(i, a);
+						} else { // c extends a to the right
+							out.set(i, new VersionIntervalImpl(null, false, cMax, c.isMaxInclusive()));
+						}
+
+						return;
+					}
+				}
+			} else if (cMax == null) { // [..c..
+				cmp = compareMin(a, c);
+
+				if (cmp >= 0) { // c encompasses a
+					// no-op
+				} else if (aMax == null) { // a encompasses c
+					while (out.size() > i) out.remove(i);
+					out.add(a);
+				} else { // aMin < cMin
+					cmp = aMax.compareTo((Version) cMin);
+
+					if (cmp < 0 || cmp == 0 && !a.isMaxInclusive() && !c.isMinInclusive()) { // [..a..]..[..c.. or [..a..)(..c..
+						out.add(i, a);
+					} else { // a extends c to the left
+						out.set(i, new VersionIntervalImpl(aMin, a.isMinInclusive(), null, false));
+					}
+				}
+
+				return;
+			} else if ((cmp = aMin.compareTo((Version) cMax)) < 0 || cmp == 0 && (a.isMinInclusive() || c.isMaxInclusive())) {
+				int cmp2;
+
+				if (aMax == null || cMin == null || (cmp2 = aMax.compareTo((Version) cMin)) > 0 || cmp2 == 0 && (a.isMaxInclusive() || c.isMinInclusive())) {
+					int cmpMin = compareMin(a, c);
+					int cmpMax = compareMax(a, c);
+
+					if (cmpMax <= 0) { // aMax <= cMax
+						if (cmpMin < 0) { // aMin < cMin
+							out.set(i, new VersionIntervalImpl(aMin, a.isMinInclusive(), cMax, c.isMaxInclusive()));
+						}
+
+						return;
+					} else if (cmpMin > 0) { // aMin > cMin, aMax > cMax
+						a = new VersionIntervalImpl(cMin, c.isMinInclusive(), aMax, a.isMaxInclusive());
+					}
+
+					out.remove(i);
+					i--;
+				} else {
+					out.add(i, a);
+					return;
+				}
+			}
+		}
+
+		out.add(a);
+	}
+
+	private static int compareMin(VersionInterval a, VersionInterval b) {
+		SemanticVersion aMin = (SemanticVersion) a.getMin();
+		SemanticVersion bMin = (SemanticVersion) b.getMin();
+		int cmp;
+
+		if (aMin == null) { // a <= b
+			if (bMin == null) { // a == b == -inf
+				return 0;
+			} else { // bMin != null -> a < b
+				return -1;
+			}
+		} else if (bMin == null || (cmp = aMin.compareTo((Version) bMin)) > 0 || cmp == 0 && !a.isMinInclusive() && b.isMinInclusive()) { // a > b
+			return 1;
+		} else if (cmp < 0 || a.isMinInclusive() && !b.isMinInclusive()) { // a < b
+			return -1;
+		} else { // cmp == 0 && a.minInclusive() == b.minInclusive() -> a == b
+			return 0;
+		}
+	}
+
+	private static int compareMax(VersionInterval a, VersionInterval b) {
+		SemanticVersion aMax = (SemanticVersion) a.getMax();
+		SemanticVersion bMax = (SemanticVersion) b.getMax();
+		int cmp;
+
+		if (aMax == null) { // a >= b
+			if (bMax == null) { // a == b == inf
+				return 0;
+			} else { // bMax != null -> a > b
+				return 1;
+			}
+		} else if (bMax == null || (cmp = aMax.compareTo((Version) bMax)) < 0 || cmp == 0 && !a.isMaxInclusive() && b.isMaxInclusive()) { // a < b
+			return -1;
+		} else if (cmp > 0 || a.isMaxInclusive() && !b.isMaxInclusive()) { // a > b
+			return 1;
+		} else { // cmp == 0 && a.maxInclusive() == b.maxInclusive() -> a == b
+			return 0;
+		}
+	}
+
+	public static List<VersionInterval> not(VersionInterval interval) {
+		if (interval == null) { // () = empty interval -> infinite
+			return Collections.singletonList(INFINITE);
+		} else if (interval.getMin() == null) { // (-, = at least half-open towards min
+			if (interval.getMax() == null) { // (-,) = infinite -> empty
+				return Collections.emptyList();
+			} else { // (-,x = left open towards min -> half open towards max
+				return Collections.singletonList(new VersionIntervalImpl(interval.getMax(), !interval.isMaxInclusive(), null, false));
+			}
+		} else if (interval.getMax() == null) { // x,) = half open towards max -> half open towards min
+			return Collections.singletonList(new VersionIntervalImpl(null, false, interval.getMin(), !interval.isMinInclusive()));
+		} else if (interval.getMin().equals(interval.getMax()) && !interval.isMinInclusive() && !interval.isMaxInclusive()) { // (x,x) = effectively empty interval -> infinite
+			return Collections.singletonList(INFINITE);
+		} else { // closed interval -> 2 half open intervals on each side
+			List<VersionInterval> ret = new ArrayList<>(2);
+			ret.add(new VersionIntervalImpl(null, false, interval.getMin(), !interval.isMinInclusive()));
+			ret.add(new VersionIntervalImpl(interval.getMax(), !interval.isMaxInclusive(), null, false));
+
+			return ret;
+		}
+	}
+
+	public static List<VersionInterval> not(Collection<VersionInterval> intervals) {
+		if (intervals.isEmpty()) return Collections.singletonList(INFINITE);
+		if (intervals.size() == 1) return not(intervals.iterator().next());
+
+		// !(i0 || i1 || i2) == !i0 && !i1 && !i2
+
+		List<VersionInterval> ret = null;
+
+		for (VersionInterval v : intervals) {
+			List<VersionInterval> inverted = not(v);
+
+			if (ret == null) {
+				ret = inverted;
+			} else {
+				ret = and(ret, inverted);
+			}
+
+			if (ret.isEmpty()) break;
+		}
+
+		return ret;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/version/VersionParser.java b/src/main/java/net/fabricmc/loader/impl/util/version/VersionParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c35e8e300becedfc3e49358ad692abc94c676fc
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/version/VersionParser.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.version;
+
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+
+public final class VersionParser {
+	public static Version parse(String s, boolean storeX) throws Exception {
+		if (s == null || s.isEmpty()) {
+			throw new Exception("Version must be a non-empty string!");
+		}
+
+		Version version;
+
+		try {
+			version = new SemanticVersionImpl(s, storeX);
+		} catch (Exception e) {
+			version = new StringVersion(s);
+		}
+
+		return version;
+	}
+
+	public static SemanticVersion parseSemantic(String s) throws Exception {
+		if (s == null || s.isEmpty()) {
+			throw new Exception("Version must be a non-empty string!");
+		}
+
+		return new SemanticVersionImpl(s, false);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/impl/util/version/VersionPredicateParser.java b/src/main/java/net/fabricmc/loader/impl/util/version/VersionPredicateParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..510ca030145fc49a616e145a2b9853e6610d1a17
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/impl/util/version/VersionPredicateParser.java
@@ -0,0 +1,264 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.impl.util.version;
+
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.api.metadata.version.VersionComparisonOperator;
+import net.fabricmc.loader.api.metadata.version.VersionInterval;
+import net.fabricmc.loader.api.metadata.version.VersionPredicate;
+import net.fabricmc.loader.api.metadata.version.VersionPredicate.PredicateTerm;
+
+import java.util.*;
+
+public final class VersionPredicateParser {
+	private static final VersionComparisonOperator[] OPERATORS = VersionComparisonOperator.values();
+
+	public static VersionPredicate parse(String predicate) throws Exception {
+		List<SingleVersionPredicate> predicateList = new ArrayList<>();
+
+		for (String s : predicate.split(" ")) {
+			s = s.trim();
+
+			if (s.isEmpty() || s.equals("*")) {
+				continue;
+			}
+
+			VersionComparisonOperator operator = VersionComparisonOperator.EQUAL;
+
+			for (VersionComparisonOperator op : OPERATORS) {
+				if (s.startsWith(op.getSerialized())) {
+					operator = op;
+					s = s.substring(op.getSerialized().length());
+					break;
+				}
+			}
+
+			Version version = VersionParser.parse(s, true);
+
+			if (version instanceof SemanticVersion) {
+				SemanticVersion semVer = (SemanticVersion) version;
+
+				if (semVer.hasWildcard()) { // .x version -> replace with conventional version by replacing the operator
+					if (operator != VersionComparisonOperator.EQUAL) {
+						throw new Exception("Invalid predicate: "+predicate+", version ranges with wildcards (.X) require using the equality operator or no operator at all!");
+					}
+
+					assert !semVer.getPrereleaseKey().isPresent();
+
+					int compCount = semVer.getVersionComponentCount();
+					assert compCount == 2 || compCount == 3;
+
+					operator = compCount == 2 ? VersionComparisonOperator.SAME_TO_NEXT_MAJOR : VersionComparisonOperator.SAME_TO_NEXT_MINOR;
+
+					int[] newComponents = new int[semVer.getVersionComponentCount() - 1];
+
+					for (int i = 0; i < semVer.getVersionComponentCount() - 1; i++) {
+						newComponents[i] = semVer.getVersionComponent(i);
+					}
+
+					version = new SemanticVersionImpl(newComponents, "", semVer.getBuildKey().orElse(null));
+				}
+			} else if (!operator.isMinInclusive() && !operator.isMaxInclusive()) { // non-semver without inclusive bound
+				throw new Exception("Invalid predicate: "+predicate+", version ranges need to be semantic version compatible to use operators that exclude the bound!");
+			} else { // non-semver with inclusive bound
+				operator = VersionComparisonOperator.EQUAL;
+			}
+
+			predicateList.add(new SingleVersionPredicate(operator, version));
+		}
+
+		if (predicateList.isEmpty()) {
+			return AnyVersionPredicate.INSTANCE;
+		} else if (predicateList.size() == 1) {
+			return predicateList.get(0);
+		} else {
+			return new MultiVersionPredicate(predicateList);
+		}
+	}
+
+	public static Set<VersionPredicate> parse(Collection<String> predicates) throws Exception {
+		Set<VersionPredicate> ret = new HashSet<>(predicates.size());
+
+		for (String version : predicates) {
+			ret.add(parse(version));
+		}
+
+		return ret;
+	}
+
+	public static VersionPredicate getAny() {
+		return AnyVersionPredicate.INSTANCE;
+	}
+
+	static class AnyVersionPredicate implements VersionPredicate {
+		static final VersionPredicate INSTANCE = new AnyVersionPredicate();
+
+		private AnyVersionPredicate() { }
+
+		@Override
+		public boolean test(Version t) {
+			return true;
+		}
+
+		@Override
+		public List<? extends PredicateTerm> getTerms() {
+			return Collections.emptyList();
+		}
+
+		@Override
+		public VersionInterval getInterval() {
+			return VersionIntervalImpl.INFINITE;
+		}
+
+		@Override
+		public String toString() {
+			return "*";
+		}
+	}
+
+	static class SingleVersionPredicate implements VersionPredicate, PredicateTerm {
+		private final VersionComparisonOperator operator;
+		private final Version refVersion;
+
+		SingleVersionPredicate(VersionComparisonOperator operator, Version refVersion) {
+			this.operator = operator;
+			this.refVersion = refVersion;
+		}
+
+		@Override
+		public boolean test(Version version) {
+			Objects.requireNonNull(version, "null version");
+
+			return operator.test(version, refVersion);
+		}
+
+		@Override
+		public List<PredicateTerm> getTerms() {
+			return Collections.singletonList(this);
+		}
+
+		@Override
+		public VersionInterval getInterval() {
+			if (refVersion instanceof SemanticVersion) {
+				SemanticVersion version = (SemanticVersion) refVersion;
+
+				return new VersionIntervalImpl(operator.minVersion(version), operator.isMinInclusive(),
+						operator.maxVersion(version), operator.isMaxInclusive());
+			} else {
+				return new VersionIntervalImpl(refVersion, true, refVersion, true);
+			}
+		}
+
+		@Override
+		public VersionComparisonOperator getOperator() {
+			return operator;
+		}
+
+		@Override
+		public Version getReferenceVersion() {
+			return refVersion;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (obj instanceof SingleVersionPredicate) {
+				SingleVersionPredicate o = (SingleVersionPredicate) obj;
+
+				return operator == o.operator && refVersion.equals(o.refVersion);
+			} else {
+				return false;
+			}
+		}
+
+		@Override
+		public int hashCode() {
+			return operator.ordinal() * 31 + refVersion.hashCode();
+		}
+
+		@Override
+		public String toString() {
+			return operator.getSerialized().concat(refVersion.toString());
+		}
+	}
+
+	static class MultiVersionPredicate implements VersionPredicate {
+		private final List<SingleVersionPredicate> predicates;
+
+		MultiVersionPredicate(List<SingleVersionPredicate> predicates) {
+			this.predicates = predicates;
+		}
+
+		@Override
+		public boolean test(Version version) {
+			Objects.requireNonNull(version, "null version");
+
+			for (SingleVersionPredicate predicate : predicates) {
+				if (!predicate.test(version)) return false;
+			}
+
+			return true;
+		}
+
+		@Override
+		public List<? extends PredicateTerm> getTerms() {
+			return predicates;
+		}
+
+		@Override
+		public VersionInterval getInterval() {
+			if (predicates.isEmpty()) return AnyVersionPredicate.INSTANCE.getInterval();
+
+			VersionInterval ret = predicates.get(0).getInterval();
+
+			for (int i = 1; i < predicates.size(); i++) {
+				ret = VersionIntervalImpl.and(ret, predicates.get(i).getInterval());
+			}
+
+			return ret;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (obj instanceof MultiVersionPredicate) {
+				MultiVersionPredicate o = (MultiVersionPredicate) obj;
+
+				return predicates.equals(o.predicates);
+			} else {
+				return false;
+			}
+		}
+
+		@Override
+		public int hashCode() {
+			return predicates.hashCode();
+		}
+
+		@Override
+		public String toString() {
+			StringBuilder ret = new StringBuilder();
+
+			for (SingleVersionPredicate predicate : predicates) {
+				if (ret.length() > 0) ret.append(' ');
+				ret.append(predicate.toString());
+			}
+
+			return ret.toString();
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/language/JavaLanguageAdapter.java b/src/main/java/net/fabricmc/loader/language/JavaLanguageAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..4a7e6535b7fe29fd60ce7cb45c05a2dee6a5e9a6
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/language/JavaLanguageAdapter.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.language;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.FabricLoader;
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import net.fabricmc.loader.impl.util.LoaderUtil;
+import org.objectweb.asm.ClassReader;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+
+@Deprecated
+public class JavaLanguageAdapter implements LanguageAdapter {
+	private static boolean canApplyInterface(String itfString) throws IOException {
+		// TODO: Be a bit more involved
+		switch (itfString) {
+		case "net/fabricmc/api/ClientModInitializer":
+			if (FabricLoader.getInstance().getEnvironmentType() == EnvType.SERVER) {
+				return false;
+			}
+
+			break;
+		case "net/fabricmc/api/DedicatedServerModInitializer":
+			if (FabricLoader.getInstance().getEnvironmentType() == EnvType.CLIENT) {
+				return false;
+			}
+		}
+
+		InputStream stream = FabricLauncherBase.getLauncher().getResourceAsStream(LoaderUtil.getClassFileName(itfString));
+		if (stream == null) return false;
+
+		ClassReader reader = new ClassReader(stream);
+
+		for (String s : reader.getInterfaces()) {
+			if (!canApplyInterface(s)) {
+				stream.close();
+				return false;
+			}
+		}
+
+		stream.close();
+		return true;
+	}
+
+	public static Class<?> getClass(String className, Options options) throws ClassNotFoundException, IOException {
+		InputStream stream = FabricLauncherBase.getLauncher().getResourceAsStream(LoaderUtil.getClassFileName(className));
+		if (stream == null) throw new ClassNotFoundException("Could not find or load class " + className);
+
+		ClassReader reader = new ClassReader(stream);
+
+		for (String s : reader.getInterfaces()) {
+			if (!canApplyInterface(s)) {
+				switch (options.getMissingSuperclassBehavior()) {
+				case RETURN_NULL:
+					stream.close();
+					return null;
+				case CRASH:
+				default:
+					stream.close();
+					throw new ClassNotFoundException("Could not find or load class " + s);
+				}
+			}
+		}
+
+		stream.close();
+		return FabricLauncherBase.getClass(className);
+	}
+
+	@Override
+	public Object createInstance(Class<?> modClass, Options options) throws LanguageAdapterException {
+		try {
+			Constructor<?> constructor = modClass.getDeclaredConstructor();
+			return constructor.newInstance();
+		} catch (NoSuchMethodException e) {
+			throw new LanguageAdapterException("Could not find constructor for class " + modClass.getName() + "!", e);
+		} catch (IllegalAccessException e) {
+			throw new LanguageAdapterException("Could not access constructor of class " + modClass.getName() + "!", e);
+		} catch (InvocationTargetException | IllegalArgumentException | InstantiationException e) {
+			throw new LanguageAdapterException("Could not instantiate class " + modClass.getName() + "!", e);
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/language/LanguageAdapter.java b/src/main/java/net/fabricmc/loader/language/LanguageAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..d5f18295b8b838c3df3558ae229c90929377d50d
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/language/LanguageAdapter.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.language;
+
+import java.io.IOException;
+
+@Deprecated
+public interface LanguageAdapter {
+	enum MissingSuperclassBehavior {
+		RETURN_NULL,
+		CRASH
+	}
+
+	default Object createInstance(String classString, Options options) throws ClassNotFoundException, LanguageAdapterException {
+		try {
+			Class<?> c = JavaLanguageAdapter.getClass(classString, options);
+
+			if (c != null) {
+				return createInstance(c, options);
+			} else {
+				return null;
+			}
+		} catch (IOException e) {
+			throw new LanguageAdapterException("I/O error!", e);
+		}
+	}
+
+	Object createInstance(Class<?> baseClass, Options options) throws LanguageAdapterException;
+
+	class Options {
+		private MissingSuperclassBehavior missingSuperclassBehavior;
+
+		public MissingSuperclassBehavior getMissingSuperclassBehavior() {
+			return missingSuperclassBehavior;
+		}
+
+		public static class Builder {
+			private final Options options;
+
+			private Builder() {
+				options = new Options();
+			}
+
+			public static Builder create() {
+				return new Builder();
+			}
+
+			public Builder missingSuperclassBehaviour(MissingSuperclassBehavior value) {
+				options.missingSuperclassBehavior = value;
+				return this;
+			}
+
+			public Options build() {
+				return options;
+			}
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/language/LanguageAdapterException.java b/src/main/java/net/fabricmc/loader/language/LanguageAdapterException.java
new file mode 100644
index 0000000000000000000000000000000000000000..fead05468cef640796bc0487fd7d45fdc850f801
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/language/LanguageAdapterException.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.language;
+
+@SuppressWarnings("serial")
+@Deprecated
+public class LanguageAdapterException extends Exception {
+	public LanguageAdapterException(String s) {
+		super(s);
+	}
+
+	public LanguageAdapterException(String s, Throwable t) {
+		super(s, t);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/launch/common/FabricLauncher.java b/src/main/java/net/fabricmc/loader/launch/common/FabricLauncher.java
new file mode 100644
index 0000000000000000000000000000000000000000..65a45196383ffee7222d8a3b1ba0b44310b69126
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/launch/common/FabricLauncher.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.launch.common;
+
+import net.fabricmc.api.EnvType;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.Collection;
+
+/**
+ * @deprecated Internal API, do not use
+ */
+@Deprecated
+public interface FabricLauncher {
+	MappingConfiguration getMappingConfiguration();
+	void propose(URL url);
+	EnvType getEnvironmentType();
+	boolean isClassLoaded(String name);
+	InputStream getResourceAsStream(String name);
+	ClassLoader getTargetClassLoader();
+	byte[] getClassByteArray(String name, boolean runTransformers) throws IOException;
+	boolean isDevelopment();
+	Collection<URL> getLoadTimeDependencies();
+}
diff --git a/src/main/java/net/fabricmc/loader/launch/common/FabricLauncherBase.java b/src/main/java/net/fabricmc/loader/launch/common/FabricLauncherBase.java
new file mode 100644
index 0000000000000000000000000000000000000000..4624b3abcf896d3fd9ffeec70c4dc661ffba2c49
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/launch/common/FabricLauncherBase.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.launch.common;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.FabricLoader;
+import net.fabricmc.loader.impl.util.UrlUtil;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * @deprecated Internal API, do not use
+ */
+@Deprecated
+public class FabricLauncherBase implements FabricLauncher {
+	private final net.fabricmc.loader.impl.launch.FabricLauncher parent = net.fabricmc.loader.impl.launch.FabricLauncherBase.getLauncher();
+
+	public static Class<?> getClass(String className) throws ClassNotFoundException {
+		return Class.forName(className, true, getLauncher().getTargetClassLoader());
+	}
+
+	public static FabricLauncher getLauncher() {
+		return new FabricLauncherBase();
+	}
+
+	@Override
+	public MappingConfiguration getMappingConfiguration() {
+		return new MappingConfiguration();
+	}
+
+	@Override
+	public void propose(URL url) {
+		parent.addToClassPath(UrlUtil.asPath(url));
+	}
+
+	@Override
+	public EnvType getEnvironmentType() {
+		return FabricLoader.getInstance().getEnvironmentType();
+	}
+
+	@Override
+	public boolean isClassLoaded(String name) {
+		return parent.isClassLoaded(name);
+	}
+
+	@Override
+	public InputStream getResourceAsStream(String name) {
+		return parent.getResourceAsStream(name);
+	}
+
+	@Override
+	public ClassLoader getTargetClassLoader() {
+		return parent.getTargetClassLoader();
+	}
+
+	@Override
+	public byte[] getClassByteArray(String name, boolean runTransformers) throws IOException {
+		return parent.getClassByteArray(name, runTransformers);
+	}
+
+	@Override
+	public boolean isDevelopment() {
+		return FabricLoader.getInstance().isDevelopmentEnvironment();
+	}
+
+	@Override
+	public Collection<URL> getLoadTimeDependencies() {
+		List<URL> ret = new ArrayList<>();
+
+		for (Path path : parent.getClassPath()) {
+			try {
+				ret.add(UrlUtil.asUrl(path));
+			} catch (MalformedURLException e) {
+				throw new RuntimeException(e);
+			}
+		}
+
+		return ret;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/launch/common/MappingConfiguration.java b/src/main/java/net/fabricmc/loader/launch/common/MappingConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..715e7fd7cd40d9d31c2bf376c834cf50e13fb9b4
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/launch/common/MappingConfiguration.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.launch.common;
+
+import net.fabricmc.loader.impl.launch.FabricLauncherBase;
+import net.fabricmc.mapping.tree.TinyTree;
+
+/**
+ * @deprecated Internal API, do not use
+ */
+@Deprecated
+public class MappingConfiguration {
+	public TinyTree getMappings() {
+		return FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/launch/knot/KnotClient.java b/src/main/java/net/fabricmc/loader/launch/knot/KnotClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5526a4f6066c25770eea24d617768198efcb45c
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/launch/knot/KnotClient.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.launch.knot;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.launch.knot.Knot;
+
+/**
+ * @deprecated Use {@link net.fabricmc.loader.impl.launch.knot.KnotClient} instead
+ */
+@Deprecated
+public final class KnotClient {
+	public static void main(String[] args) {
+		Knot.launch(args, EnvType.CLIENT);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/launch/knot/KnotServer.java b/src/main/java/net/fabricmc/loader/launch/knot/KnotServer.java
new file mode 100644
index 0000000000000000000000000000000000000000..b6dd3d422402b1ea15b0cdbf51bb28d44ac8c7f0
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/launch/knot/KnotServer.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.launch.knot;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.launch.knot.Knot;
+
+/**
+ * @deprecated Use {@link net.fabricmc.loader.impl.launch.knot.KnotServer} instead
+ */
+@Deprecated
+public final class KnotServer {
+	public static void main(String[] args) {
+		Knot.launch(args, EnvType.SERVER);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/launch/server/FabricServerLauncher.java b/src/main/java/net/fabricmc/loader/launch/server/FabricServerLauncher.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e407f20daf2fbcc02d70d48beb9ac8f834df36d
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/launch/server/FabricServerLauncher.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.launch.server;
+
+/**
+ * @deprecated Use {@link net.fabricmc.loader.impl.launch.server.FabricServerLauncher} instead
+ */
+@Deprecated
+public final class FabricServerLauncher {
+	public static void main(String[] args) {
+		net.fabricmc.loader.impl.launch.server.FabricServerLauncher.main(args);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/metadata/EntrypointMetadata.java b/src/main/java/net/fabricmc/loader/metadata/EntrypointMetadata.java
new file mode 100644
index 0000000000000000000000000000000000000000..46cdc46b1e80d83ea6315011e9993c8f6d189659
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/metadata/EntrypointMetadata.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.metadata;
+
+/**
+ * @deprecated Internal API, do not use
+ */
+@Deprecated
+public interface EntrypointMetadata {
+	String getAdapter();
+	String getValue();
+}
diff --git a/src/main/java/net/fabricmc/loader/metadata/LoaderModMetadata.java b/src/main/java/net/fabricmc/loader/metadata/LoaderModMetadata.java
new file mode 100644
index 0000000000000000000000000000000000000000..c50c8817328f57a7211e8305c55e4d326b45d8ee
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/metadata/LoaderModMetadata.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.metadata;
+
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.api.metadata.ModMetadata;
+
+import java.util.Collection;
+import java.util.List;
+
+/**
+ * @deprecated Use {@link ModMetadata} instead
+ */
+@Deprecated
+public interface LoaderModMetadata extends ModMetadata {
+	boolean loadsInEnvironment(EnvType type);
+	List<? extends EntrypointMetadata> getEntrypoints(String type);
+	Collection<String> getEntrypointKeys();
+}
diff --git a/src/main/java/net/fabricmc/loader/metadata/MapBackedContactInformation.java b/src/main/java/net/fabricmc/loader/metadata/MapBackedContactInformation.java
new file mode 100644
index 0000000000000000000000000000000000000000..d67f399933dbeab448e9dd24bb99908aa908c516
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/metadata/MapBackedContactInformation.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.metadata;
+
+import net.fabricmc.loader.api.metadata.ContactInformation;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Optional;
+
+/**
+ * @deprecated Use {@link ContactInformation} instead
+ */
+@Deprecated
+public class MapBackedContactInformation implements ContactInformation {
+	private final Map<String, String> map;
+
+	public MapBackedContactInformation(Map<String, String> map) {
+		this.map = Collections.unmodifiableMap(map);
+	}
+
+	@Override
+	public Optional<String> get(String key) {
+		return Optional.ofNullable(map.get(key));
+	}
+
+	@Override
+	public Map<String, String> asMap() {
+		return map;
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/util/DefaultLanguageAdapter.java b/src/main/java/net/fabricmc/loader/util/DefaultLanguageAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..eddb8e9d1115c25ccd66bbffbb7695b4526ae544
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/util/DefaultLanguageAdapter.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.util;
+
+import net.fabricmc.loader.api.LanguageAdapter;
+import net.fabricmc.loader.api.LanguageAdapterException;
+import net.fabricmc.loader.api.ModContainer;
+
+/**
+ * @deprecated Use {@link LanguageAdapter} instead.
+ */
+@Deprecated
+public final class DefaultLanguageAdapter implements LanguageAdapter {
+	public static final DefaultLanguageAdapter INSTANCE = new DefaultLanguageAdapter();
+
+	@Override
+	public <T> T create(ModContainer mod, String value, Class<T> type) throws LanguageAdapterException {
+		return LanguageAdapter.getDefault().create(mod, value, type);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/util/UrlConversionException.java b/src/main/java/net/fabricmc/loader/util/UrlConversionException.java
new file mode 100644
index 0000000000000000000000000000000000000000..969017f37af477ee4456cabc2de893b98c775c76
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/util/UrlConversionException.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.util;
+
+/**
+ * @deprecated Internal API, do not use
+ */
+@SuppressWarnings("serial")
+@Deprecated
+public class UrlConversionException extends Exception {
+	public UrlConversionException() {
+		super();
+	}
+
+	public UrlConversionException(String s) {
+		super(s);
+	}
+
+	public UrlConversionException(Throwable t) {
+		super(t);
+	}
+
+	public UrlConversionException(String s, Throwable t) {
+		super(s, t);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/util/UrlUtil.java b/src/main/java/net/fabricmc/loader/util/UrlUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..6889b1c936798cf1fd42598336fdbc445344e324
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/util/UrlUtil.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.util;
+
+import net.fabricmc.loader.impl.util.ExceptionUtil.WrappedException;
+
+import java.net.URL;
+import java.nio.file.Path;
+
+/**
+ * @deprecated Internal API, do not use
+ */
+@Deprecated
+public final class UrlUtil {
+	private UrlUtil() { }
+
+	public static Path asPath(URL url) throws UrlConversionException {
+		try {
+			return net.fabricmc.loader.impl.util.UrlUtil.asPath(url);
+		} catch (WrappedException e) {
+			throw new UrlConversionException(e.getCause());
+		}
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/util/version/SemanticVersionImpl.java b/src/main/java/net/fabricmc/loader/util/version/SemanticVersionImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..e6f1eda10f7e7958c70f8812d8ccceeb57f8fbbe
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/util/version/SemanticVersionImpl.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.util.version;
+
+import net.fabricmc.loader.api.SemanticVersion;
+import net.fabricmc.loader.api.Version;
+import net.fabricmc.loader.api.VersionParsingException;
+
+import java.util.Optional;
+
+/**
+ * @deprecated Internal API, do not use
+ */
+@Deprecated
+public class SemanticVersionImpl implements SemanticVersion {
+	private final SemanticVersion parent;
+
+	protected SemanticVersionImpl() {
+		parent = null;
+	}
+
+	public SemanticVersionImpl(String version, boolean storeX) throws Exception {
+		parent = SemanticVersion.parse(version);
+	}
+
+	@Override
+	public int getVersionComponentCount() {
+		return parent.getVersionComponentCount();
+	}
+
+	@Override
+	public int getVersionComponent(int pos) {
+		return parent.getVersionComponent(pos);
+	}
+
+	@Override
+	public Optional<String> getPrereleaseKey() {
+		return parent.getPrereleaseKey();
+	}
+
+	@Override
+	public Optional<String> getBuildKey() {
+		return parent.getBuildKey();
+	}
+
+	@Override
+	public String getFriendlyString() {
+		return parent.getFriendlyString();
+	}
+
+	@Override
+	public boolean equals(Object o) {
+		return parent.equals(o);
+	}
+
+	@Override
+	public int hashCode() {
+		return parent.hashCode();
+	}
+
+	@Override
+	public String toString() {
+		return parent.toString();
+	}
+
+	@Override
+	public boolean hasWildcard() {
+		return parent.hasWildcard();
+	}
+
+	public boolean equalsComponentsExactly(SemanticVersionImpl other) {
+		for (int i = 0; i < Math.max(getVersionComponentCount(), other.getVersionComponentCount()); i++) {
+			if (getVersionComponent(i) != other.getVersionComponent(i)) {
+				return false;
+			}
+		}
+
+		return true;
+	}
+
+	@Override
+	public int compareTo(Version o) {
+		return parent.compareTo(o);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/util/version/SemanticVersionPredicateParser.java b/src/main/java/net/fabricmc/loader/util/version/SemanticVersionPredicateParser.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c57471bbc568ea39f00e7cacc5cff547b6ad25d
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/util/version/SemanticVersionPredicateParser.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.util.version;
+
+import net.fabricmc.loader.api.VersionParsingException;
+import net.fabricmc.loader.api.metadata.version.VersionPredicate;
+
+import java.util.function.Predicate;
+
+/**
+ * @deprecated Internal API, do not use
+ */
+@Deprecated
+public final class SemanticVersionPredicateParser {
+	public static Predicate<SemanticVersionImpl> create(String text) throws Exception {
+		VersionPredicate predicate = VersionPredicate.parse(text);
+
+		return v -> predicate.test(v);
+	}
+}
diff --git a/src/main/java/net/fabricmc/loader/util/version/VersionParsingException.java b/src/main/java/net/fabricmc/loader/util/version/VersionParsingException.java
new file mode 100644
index 0000000000000000000000000000000000000000..16cb720d75e7a156c9443eeaf86862f9fd0eab34
--- /dev/null
+++ b/src/main/java/net/fabricmc/loader/util/version/VersionParsingException.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2016 FabricMC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package net.fabricmc.loader.util.version;
+
+/** @deprecated Replaced by {@link net.fabricmc.loader.api.VersionParsingException} */
+@SuppressWarnings("serial")
+@Deprecated
+public class VersionParsingException extends Exception {
+	public VersionParsingException() {
+		super();
+	}
+
+	public VersionParsingException(Throwable t) {
+		super(t);
+	}
+
+	public VersionParsingException(String s) {
+		super(s);
+	}
+
+	public VersionParsingException(String s, Throwable t) {
+		super(s, t);
+	}
+}
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 2386cbb3002d4ad8974054d0b1973e45cab51349..aca7b5ce8774f43fadf83274b721e11875c4c2c7 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -60,11 +60,6 @@ public class Main {
 
     @DontObfuscate
     public static void main(final OptionSet optionset) { // CraftBukkit - replaces main(String[] astring)
-        try {
-            PapiergabelMain.initPapiergabel();
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
         SharedConstants.tryDetectVersion();
         /* CraftBukkit start - Replace everything
         OptionParser optionparser = new OptionParser();
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 344d93f1d7f25a3f26064469e78dd698af66dc0d..b299c89d19e1bc3444d8badcd1201e4345e1b98c 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -2,25 +2,36 @@ package org.bukkit.craftbukkit;
 
 import java.io.File;
 import java.io.IOException;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.net.URISyntaxException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.List;
+import java.util.*;
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+
+import de.hglabor.papiergabel.PapiergabelMain;
+import de.hglabor.papiergabel.config.PapiergabelConfig;
 import joptsimple.OptionParser;
 import joptsimple.OptionSet;
+import net.fabricmc.api.EnvType;
+import net.fabricmc.loader.impl.launch.knot.Knot;
 import net.minecraft.util.ExceptionCollector;
 import net.minecraft.world.level.lighting.LayerLightEventListener;
 import net.minecrell.terminalconsole.TerminalConsoleAppender; // Paper
+import org.slf4j.spi.SLF4JServiceProvider;
+import org.spongepowered.asm.mixin.MixinEnvironment;
 
 public class Main {
     public static boolean useJline = true;
     public static boolean useConsole = true;
 
-    public static void main(String[] args) {
+    public static void main(String[] args) throws URISyntaxException {
         // Paper start
         final String warnWhenLegacyFormattingDetected = String.join(".", "net", "kyori", "adventure", "text", "warnWhenLegacyFormattingDetected");
         if (false && System.getProperty(warnWhenLegacyFormattingDetected) == null) {
@@ -285,8 +296,33 @@ public class Main {
                 }
                 // Paper end
                 System.setProperty( "library.jansi.version", "Paper" ); // Paper - set meaningless jansi version to prevent git builds from crashing on Windows
-                System.out.println("Loading libraries, please wait...");
-                net.minecraft.server.Main.main(options);
+                // papiergabel start
+                try {
+                    PapiergabelMain.initPapiergabel();
+                } catch (Exception e) {
+                    throw new RuntimeException(e);
+                }
+                if(PapiergabelConfig.experimental.loadFabricMods) {
+                    System.out.println("Trying to launch knot, please wait");
+                    try {
+                        new Knot(EnvType.SERVER).init(args);
+                    } catch (Throwable t) {
+                        t.printStackTrace();
+                        System.out.println("**--------------------------------------------------------------------------**");
+                        System.out.println("**                                                                          **");
+                        System.out.println("**      THROWABLE DURING KNOT BOOTUP, STARTING SERVER WITHOUT MIXINS        **");
+                        System.out.println("**              YOU HAVE 15 SECONDS TO CANCEL THE OPERATION                 **");
+                        System.out.println("**                                                                          **");
+                        System.out.println("**--------------------------------------------------------------------------**");
+                        Thread.sleep(15000);
+                        System.out.println("Loading libraries, please wait...");
+                        net.minecraft.server.Main.main(options);
+                    }
+                } else {
+                    System.out.println("Loading libraries, please wait...");
+                    net.minecraft.server.Main.main(options);
+                }
+                // papiergabel end
             } catch (Throwable t) {
                 t.printStackTrace();
             }
diff --git a/src/main/resources/META-INF/services/org.slf4j.spi.SLF4JServiceProvider b/src/main/resources/META-INF/services/org.slf4j.spi.SLF4JServiceProvider
new file mode 100644
index 0000000000000000000000000000000000000000..3548e8857d24123b14f784e7f36eea6a49592461
--- /dev/null
+++ b/src/main/resources/META-INF/services/org.slf4j.spi.SLF4JServiceProvider
@@ -0,0 +1 @@
+org.slf4j.helpers.SubstituteServiceProvider
\ No newline at end of file
diff --git a/src/main/resources/META-INF/services/org.spongepowered.asm.service.IGlobalPropertyService b/src/main/resources/META-INF/services/org.spongepowered.asm.service.IGlobalPropertyService
new file mode 100644
index 0000000000000000000000000000000000000000..43780be2c5b5f8d204bc03a065cc4c3f1d9b8415
--- /dev/null
+++ b/src/main/resources/META-INF/services/org.spongepowered.asm.service.IGlobalPropertyService
@@ -0,0 +1 @@
+net.fabricmc.loader.impl.launch.knot.FabricGlobalPropertyService
\ No newline at end of file
diff --git a/src/main/resources/META-INF/services/org.spongepowered.asm.service.IMixinService b/src/main/resources/META-INF/services/org.spongepowered.asm.service.IMixinService
new file mode 100644
index 0000000000000000000000000000000000000000..d810591e50dda323bd273fd5cdd4829646ba724c
--- /dev/null
+++ b/src/main/resources/META-INF/services/org.spongepowered.asm.service.IMixinService
@@ -0,0 +1 @@
+net.fabricmc.loader.impl.launch.knot.MixinServiceKnot
\ No newline at end of file
diff --git a/src/main/resources/META-INF/services/org.spongepowered.asm.service.IMixinServiceBootstrap b/src/main/resources/META-INF/services/org.spongepowered.asm.service.IMixinServiceBootstrap
new file mode 100644
index 0000000000000000000000000000000000000000..3057481b1b43e0701ab938541ba8b5b98f305fe8
--- /dev/null
+++ b/src/main/resources/META-INF/services/org.spongepowered.asm.service.IMixinServiceBootstrap
@@ -0,0 +1 @@
+net.fabricmc.loader.impl.launch.knot.MixinServiceKnotBootstrap
\ No newline at end of file
diff --git a/src/main/resources/fabric.mod.json b/src/main/resources/fabric.mod.json
new file mode 100644
index 0000000000000000000000000000000000000000..23a946d1068ccfc947593d3494f7b3943212455f
--- /dev/null
+++ b/src/main/resources/fabric.mod.json
@@ -0,0 +1,19 @@
+{
+  "schemaVersion": 1,
+  "id": "fabricloader",
+  "name": "Fabric Loader",
+  "version": "${version}",
+  "environment": "*",
+  "description": "The base mod loader.",
+  "contact": {
+    "homepage": "https://fabricmc.net",
+    "irc": "irc://irc.esper.net:6667/fabric",
+    "issues": "https://github.com/FabricMC/fabric/issues",
+    "sources": "https://github.com/FabricMC/fabric"
+  },
+  "license": "Apache-2.0",
+  "icon": "assets/fabricloader/icon.png",
+  "authors": [
+    "FabricMC"
+  ]
+}
